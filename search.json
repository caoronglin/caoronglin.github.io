[{"title":"Shell 基础","path":"/p/8e5e54a1.shtml","content":"Shell 基础什么是 Shell？Shell 是用户与 Linux 内核之间的命令解释器。它接收用户输入的命令，解释后传递给内核执行，并将结果返回给用户。 用户 ←→ Shell ←→ Linux 内核 ←→ 硬件 常见 Shell 类型 Bourne 系列sh - Bourne Shell，最早的 Unix Shellbash - Bourne Again Shell，Linux 默认dash - Debian Almquist Shell，轻量版zsh - Z Shell，功能强大ksh - Korn Shell，商业 Unix 常用 C 系列csh - C Shell，语法类似 C 语言tcsh - TENEX C Shell，csh 增强版其他fish - Friendly Interactive Shell，用户友好 查看和切换 Shell# 查看当前 Shellecho $SHELL# 查看可用的 Shellchsh -lcat /etc/shells# 临时切换 Shellbashzshfish# 永久切换默认 Shellchsh -s /bin/zsh# 需要重新登录生效 Bash 基础命令基本格式command [options] [arguments]命令 [选项] [参数] 示例： ls -la /home/user│ ││ ││ ││ └── 参数：操作的目标│ │└────── 选项：-l 长格式，-a 显示所有文件│ └──────── 短选项可以合并└──────────── 命令：列出目录内容 命令行快捷键光标移动文本编辑命令控制 快捷键 功能 Ctrl + A 移到行首 Ctrl + E 移到行尾 Ctrl + F 向前移动一个字符（同 →） Ctrl + B 向后移动一个字符（同 ←） Alt + F 向前移动一个单词 Alt + B 向后移动一个单词 快捷键 功能 Ctrl + D 删除当前字符 Ctrl + H 删除前一个字符（同 Backspace） Ctrl + W 删除前一个单词 Alt + D 删除后一个单词 Ctrl + K 删除从光标到行尾的内容 Ctrl + U 删除从行首到光标的内容 Ctrl + Y 粘贴最近删除的内容 快捷键 功能 Ctrl + C 终止当前命令 Ctrl + Z 挂起当前命令（放入后台） Ctrl + L 清屏（同 clear 命令） Ctrl + S 暂停屏幕输出 Ctrl + Q 恢复屏幕输出 Ctrl + R 搜索命令历史 Ctrl + G 取消搜索 Tab 自动补全命令路径 Tab Tab 显示所有可能的补全 历史命令# 查看历史命令historyhistory | tail -20 # 最近20条history | grep apt # 搜索包含 apt 的历史命令# 执行历史命令!! # 执行上一条命令!n # 执行第 n 条历史命令!-n # 执行倒数第 n 条!string # 执行以 string 开头的最近命令!?string # 执行包含 string 的最近命令!$:p # 显示上一条命令的最后一个参数# 历史命令展开示例$ echo Hello WorldHello World$ echo !! # 执行 echo echo Hello Worldecho Hello World$ echo one two three$ echo !^ # 第一个参数: one$ echo !$ # 最后一个参数: three$ echo !* # 所有参数: one two three# 修改并执行上一条命令$ cat file1$ ^cat^ls # 将 cat 替换为 ls，执行 ls file1# 搜索历史命令Ctrl + R # 交互式搜索(reverse-i-search)`apt: sudo apt update # 输入关键词搜索Ctrl + R (again) # 查找上一个匹配Ctrl + S # 向前搜索（如果终端支持）Ctrl + G / Esc # 取消搜索 环境变量常用环境变量 变量 说明 示例 PATH 可执行文件搜索路径 /usr/local/bin:/usr/bin:/bin HOME 当前用户主目录 /home/alice USER LOGNAME 当前用户名 alice SHELL 当前 Shell /bin/bash PWD 当前工作目录 /home/alice/project OLDPWD 上一个工作目录 /home/alice LANG 系统语言区域设置 en_US.UTF-8 TERM 终端类型 xterm-256color EDITOR 默认文本编辑器 vim VISUAL 默认可视化编辑器 vim PS1 主提示符格式 \\u@\\h:\\w\\$ PS2 次提示符 HISTSIZE 历史命令保存数量 1000 HISTFILE 历史命令文件 ~/.bash_history MAIL 用户邮箱 /var/spool/mail/alice SSH_CLIENT SSH 客户端信息 10.0.0.5 12345 22 SSH_TTY SSH 分配的 TTY /dev/pts/0 XDG_SESSION_TYPE 会话类型 x11 或 wayland XDG_CURRENT_DESKTOP 当前桌面环境 GNOME 或 KDE 查看和设置环境变量# 查看单个变量echo $PATHecho $HOMEecho $USER # 使用花括号避免歧义# 查看所有环境变量envprintenvprintenv PATH # 查看特定变量# 设置临时变量（仅当前 shell）MY_VAR=Hello Worldecho $MY_VAR# 导出为环境变量（子进程可用）export MY_VAR=Hello Worldexport PATH=$PATH:/new/path# 删除变量unset MY_VAR# 在命令行临时设置（仅本次命令）LANG=zh_CN.UTF-8 date# 变量操作$VAR:-default # 如果 VAR 未设置，使用 default$VAR:=default # 如果 VAR 未设置，设为 default$VAR:+value # 如果 VAR 已设置，使用 value$VAR:?error # 如果 VAR 未设置，显示 error 并退出$#VAR # 字符串长度$VAR:offset:length # 子字符串$VAR#pattern # 删除最短匹配的前缀$VAR##pattern # 删除最长匹配的前缀$VAR%pattern # 删除最短匹配的后缀$VAR%%pattern # 删除最长匹配的后缀$VAR/pattern/replace # 替换第一个匹配$VAR//pattern/replace # 替换所有匹配$VAR/#pattern/replace # 替换开头匹配$VAR/%pattern/replace # 替换结尾匹配$VAR^ # 首字母大写$VAR^^ # 全部大写$VAR, # 首字母小写$VAR,, # 全部小写 配置环境变量当前用户生效（~/.bashrc 或 ~/.bash_profile）： # 编辑配置文件nano ~/.bashrc# 添加环境变量export PATH=$HOME/bin:$PATHexport EDITOR=vimexport HISTSIZE=10000export HISTTIMEFORMAT=%Y-%m-%d %H:%M:%S # 使配置生效source ~/.bashrc 所有用户生效（/etc/profile 或 /etc/environment）： # 系统级环境变量sudo nano /etc/profile# 添加export PATH=/usr/local/bin:$PATHexport JAVA_HOME=/usr/lib/jvm/java-11# 或者使用 /etc/profile.d/（推荐）sudo nano /etc/profile.d/custom.sh 优先级（由高到低）： 命令行中直接设置 ~/.bashrc ~/.bash_profile ~/.profile /etc/profile /etc/environment 延伸阅读 Bash Reference Manual Advanced Bash-Scripting Guide Explain Shell - 可视化解释命令 熟练掌握 Shell 是成为 Linux 高手的必经之路"},{"title":"进程管理","path":"/p/852cfab6.shtml","content":"进程管理进程基础概念进程 (Process) 是程序的一次执行实例，是系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间和系统资源。 进程与程序的区别 概念 定义 特点 程序 (Program) 存储在磁盘上的可执行文件 静态的、永久的 进程 (Process) 程序的运行实例 动态的、临时的 比喻： 程序 菜谱 进程 按照菜谱做菜的过程 进程的类型 按交互方式分类前台进程 (Foreground)与用户直接交互占据终端可以接收键盘输入后台进程 (Background)在后台运行不占据终端适合长时间运行的任务 按启动方式分类交互式进程由用户从终端启动如：bash、vim、firefox批处理进程与终端无关，提交到作业队列如：at、batch 启动的任务守护进程 (Daemon)系统启动时自动运行一直在后台运行通常以 ‘d’ 结尾命名如：sshd、httpd、crond 按进程关系分类父进程 (Parent Process)创建其他进程的进程子进程 (Child Process)被创建的进程继承父进程的许多属性孤儿进程 (Orphan Process)父进程提前退出被 initsystemd 收养僵尸进程 (Zombie Process)已终止但未被父进程回收占用少量资源 进程标识每个进程都有唯一的标识符： 标识符 说明 获取方式 PID (Process ID) 进程唯一标识 echo $$ PPID (Parent PID) 父进程 ID echo $PPID PGID (Process Group ID) 进程组 ID ps -o pgid= -p pid SID (Session ID) 会话 ID ps -o sid= -p pid UID (User ID) 进程所有者 ID ps -o uid= -p pid EUID (Effective UID) 有效用户 ID ps -o euid= -p pid # 查看当前 Shell 的 PIDecho $$# 查看当前 Shell 的 PPIDecho $PPID# 查看指定进程的信息ps -f -p $$ # 详细格式ps -o pid,ppid,cmd -p $$# 查看所有进程树pstreepstree -p # 显示 PIDpstree -u # 显示用户名 查看进程ps 命令ps (Process Status) 是最基础的进程查看命令。 基本用法输出字段解释进程状态 (STAT)高级用法# 查看当前终端的进程ps# 显示所有进程（BSD 风格）ps aux# 显示所有进程（System V 风格）ps -ef# 显示完整格式ps auxf # 树状格式ps -ejH # 进程树BSD 风格 (ps aux)： 字段 含义 说明 USER 进程所有者 启动进程的用户 PID 进程 ID 唯一标识符 %CPU CPU 使用率 进程占用的 CPU 百分比 %MEM 内存使用率 进程占用的物理内存百分比 VSZ 虚拟内存大小 Virtual Memory Size (KB) RSS 常驻内存大小 Resident Set Size (KB) TTY 控制终端 进程关联的终端 STAT 进程状态 见下方详细说明 START 启动时间 进程开始运行的时间 TIME CPU 时间 进程累计使用的 CPU 时间 COMMAND 命令 启动进程的命令及参数 System V 风格 (ps -ef)： 字段 含义 UID 用户 ID PID 进程 ID PPID 父进程 ID C CPU 使用率 STIME 开始时间 TTY 终端 TIME CPU 时间 CMD 命令 状态码 含义 说明 R Running Runnable 正在运行或在运行队列中等待 S Interruptible Sleep 可中断睡眠，等待某个条件 D Uninterruptible Sleep 不可中断睡眠，通常在进行 IO T Stopped 被信号停止（如 Ctrl+Z） t Tracing Stop 被调试器跟踪停止 Z Zombie 僵尸进程，已终止但未被回收 X Dead 死亡进程（不应该看到） 附加状态标志： 标志 含义 高优先级 N 低优先级 L 有锁定页面（用于实时） s 会话领导者 l 多线程 + 前台进程组 # 自定义输出格式ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head# 查找特定用户的进程ps -u usernameps aux | grep ^username# 按内存使用排序ps aux --sort=-%mem | head -10# 按 CPU 使用排序ps aux --sort=-%cpu | head -10# 显示进程树ps axjfps -eo pid,ppid,cmd | sort -n | head# 显示线程ps -eLfps aux -L# 结合其他命令ps aux | grep nginx | grep -v grepps aux | awk print $11 | sort | uniq -c | sort -rn top 命令top 提供动态的进程监控视图。 top 命令详解 # 基本使用top# 指定刷新间隔（秒）top -d 1# 显示特定用户的进程top -u username# 显示指定进程top -p PID1,PID2,PID3# 批处理模式（用于脚本）top -b -n 1 交互命令（在 top 运行时按）： 按键 功能 ? h 帮助 q 退出 Space 立即刷新 k 终止进程（输入 PID） r 修改进程优先级（renice） c 切换显示完整命令 M 按内存使用排序 P 按 CPU 使用排序 T 按运行时间排序 N 按 PID 排序 u 过滤特定用户 n 设置显示进程数 i 切换显示空闲进程 V 树状显示 t 切换 CPU 状态显示 m 切换内存状态显示 1 显示每个 CPU 核心 W 保存配置到 ~.toprc 输出字段说明： top - 14:30:25 up 3 days, 2:15, 2 users, load average: 0.52, 0.58, 0.59Tasks: 235 total, 1 running, 234 sleeping, 0 stopped, 0 zombie%Cpu(s): 5.2 us, 2.1 sy, 0.0 ni, 92.3 id, 0.2 wa, 0.0 hi, 0.2 si, 0.0 stKiB Mem : 8167844 total, 1234567 free, 3456789 used, 3476488 buff/cacheKiB Swap: 2097148 total, 2097148 free, 0 used. 4321098 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1234 alice 20 0 123456 78901 12345 S 5.2 1.0 2:34.56 firefox ... 行字段 说明 第1行 系统时间和运行时间 14:30:25 当前时间 up 3 days, 2:15 系统已运行时间 2 users 当前登录用户数 load average 1515分钟平均负载 第2行 任务统计 235 total 总进程数 1 running 运行中 234 sleeping 睡眠中 0 stopped 已停止 0 zombie 僵尸进程 第3行 CPU 使用率 us 用户空间 sy 系统空间 ni nice 调整后的用户空间 id 空闲 wa IO 等待 hi 硬中断 si 软中断 st 被虚拟机偷走的时间 第4-5行 内存和交换空间 进程列表 各进程详情 进程控制前台与后台进程后台运行作业控制nohup 和 disown# 在命令末尾加 ，在后台运行long_running_command # 示例sleep 60 ./backup_script.sh output.log 21 # 查看后台作业jobs# 输出示例：[1] + running sleep 60[2] - suspended vim file.txt# 将前台作业挂起（暂停）Ctrl + Z# 查看作业列表jobsjobs -l # 显示 PIDjobs -p # 只显示 PID# 将后台作业切换到前台fg %1 # 作业号 1fg %vim # 以 vim 开头的作业fg %% # 当前作业（+）fg %+ # 当前作业fg %- # 上一个作业# 将作业在后台继续运行bg %1bg %2# 杀死作业kill %1# 等待作业完成wait %1echo $? # 获取作业退出状态# nohup - 忽略挂起信号，退出终端后继续运行nohup command nohup ./script.sh output.log 21 # nohup 会自动将输出重定向到 nohup.out（如果没有指定）nohup python3 server.py # 输出到 nohup.out# disown - 从当前 shell 的作业表中移除作业# 这样退出 shell 时不会向作业发送 SIGHUP# 在后台运行long_running_task # 从作业表中移除disown# 或指定作业disown %1# 或者一开始就 disown(long_running_task ) 信号 (Signals)信号是进程间通信的一种机制，用于通知进程发生了某个事件。 常用信号 信号 数值 名称 默认动作 说明 1 SIGHUP Hangup 终止 终端挂起或控制进程结束 2 SIGINT Interrupt 终止 来自键盘的中断（Ctrl+C） 3 SIGQUIT Quit 核心转储 来自键盘的退出（Ctrl+\\） 6 SIGABRT Abort 核心转储 调用 abort() 产生 9 SIGKILL Kill 终止 强制终止，不可捕获或忽略 15 SIGTERM Terminate 终止 正常终止信号（默认） 18 SIGCONT Continue 继续 继续执行暂停的进程 19 SIGSTOP Stop 暂停 暂停进程执行（Ctrl+Z） 20 SIGTSTP TTY Stop 暂停 终端停止信号 关键信号详解： # SIGHUP (1) - 终端断开信号# 传统上，终端断开时向进程组发送 SIGHUP# nohup 命令就是用来忽略这个信号的# SIGINT (2) - 中断信号# Ctrl+C 发送# 进程可以捕获并优雅地退出# SIGKILL (9) - 强制终止# 不能被捕获、阻塞或忽略# 进程无法清理资源，可能留下临时文件# 最后手段，不是首选# SIGTERM (15) - 终止信号# kill 命令默认发送# 可以被捕获，进程可以优雅地清理和退出# 首选的正常终止方式# SIGSTOP (19) / SIGCONT (18)# 暂停和继续执行# SIGSTOP 不能被捕获或忽略 发送信号的方式： # kill 命令kill PID # 发送 SIGTERM (15)kill -9 PID # 发送 SIGKILL (9)kill -SIGKILL PIDkill -KILL PID# 向多个进程发送信号kill PID1 PID2 PID3# 根据进程名杀死killall process_namekillall -9 process_namekillall -u username process_name# pkill - 根据模式匹配pkill process_namepkill -f full command linepkill -u username# 键盘快捷键Ctrl + C # 发送 SIGINT (2)Ctrl + Z # 发送 SIGTSTP (20)Ctrl + \\ # 发送 SIGQUIT (3) 捕获信号示例： #!/bin/bash# 定义清理函数cleanup() echo 收到终止信号，正在清理... # 清理临时文件 rm -f /tmp/my_script_temp_$$ # 关闭资源 echo 清理完成，退出 exit 0# 捕获信号trap cleanup SIGTERM SIGINT SIGHUP# 主程序echo 程序运行中... (PID: $$)echo 临时文件: /tmp/my_script_temp_$$touch /tmp/my_script_temp_$$# 模拟长时间运行的任务while true; do echo 工作中... $(date) sleep 5done 系统监控工具htop - 交互式进程查看器# 安装sudo apt-get install htop # Debian/Ubuntusudo yum install htop # CentOS/RHEL# 启动htop 交互按键： 按键 功能 F1 ? 帮助 F2 S 设置 F3 / 搜索进程 F4 \\\\ 过滤器 F5 t 树状显示 F6 选择排序字段 F7 [ 降低进程优先级 (nice +) F8 ] 提高进程优先级 (nice -) F9 k 杀死进程 F10 q 退出 u 按用户过滤 M 按内存排序 P 按 CPU 排序 T 按时间排序 I 反转排序 l 显示隐藏线程 vmstat - 虚拟内存统计# 基本用法vmstat # 显示一次vmstat 1 # 每秒更新vmstat 1 10 # 每秒更新，共10次vmstat -s # 显示事件计数器vmstat -a # 显示活跃/非活跃内存vmstat -d # 显示磁盘统计vmstat -D # 显示磁盘活动摘要vmstat -p /dev/sda1 # 显示特定分区统计vmstat -f # 显示 fork 统计# 输出解释procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 2 0 0 123456 78901 456789 0 0 10 20 100 200 5 2 93 0 0procs: r: 运行队列中的进程数 b: 等待 I/O 的进程数memory: swpd: 使用的虚拟内存 (KB) free: 空闲内存 (KB) buff: 用作缓冲区的内存 (KB) cache: 用作缓存的内存 (KB)swap: si: 从磁盘交换入内存 (KB/s) so: 从内存交换出到磁盘 (KB/s)io: bi: 从块设备读取 (blocks/s) bo: 写入块设备 (blocks/s)system: in: 中断数 (/s) cs: 上下文切换数 (/s)cpu: us: 用户空间时间 (%) sy: 系统空间时间 (%) id: 空闲时间 (%) wa: I/O 等待时间 (%) st: 被虚拟机偷走的时间 (%) iostat - IO 统计# 安装sudo apt-get install sysstat# 基本用法iostat # 显示 CPU 和磁盘统计iostat 1 # 每秒更新iostat 1 10 # 每秒更新，共10次iostat -c # 只显示 CPU 统计iostat -d # 只显示磁盘统计iostat -x # 显示扩展统计iostat -m # 以 MB/s 显示iostat -k # 以 KB/s 显示iostat -p sda # 显示特定设备iostat -p ALL # 显示所有设备和分区# 输出解释Linux 5.4.0-65-generic (hostname) 01/15/2024 _x86_64_ (4 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 5.23 0.01 2.15 0.50 0.00 92.11Device tps kB_read/s kB_wrtn/s kB_dscd/s kB_read kB_wrtn kB_dscdsda 12.34 45.67 89.01 0.00 1234567 2345678 0sdb 0.12 1.23 0.45 0.00 12345 4567 0# 扩展统计 (iostat -x)Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %utilsda 2.34 10.00 45.67 89.01 0.12 3.45 4.89 25.67 3.45 8.90 0.12 19.52 8.90 0.80 0.98# 字段说明avg-cpu: %user - 用户空间程序使用的 CPU 百分比 %nice - 带有 nice 优先级的用户程序 %system - 内核空间使用的 CPU 百分比 %iowait - 等待 I/O 完成的时间百分比 %steal - 虚拟机管理程序占用的时间 %idle - CPU 空闲时间百分比Device: tps - 每秒传输次数 (I/O 请求数) kB_read/s - 每秒读取的数据量 (KB) kB_wrtn/s - 每秒写入的数据量 (KB) kB_dscd/s - 每秒丢弃的数据量 (KB)扩展统计: r/s - 每秒读取请求数 w/s - 每秒写入请求数 rkB/s - 每秒读取 KB 数 wkB/s - 每秒写入 KB 数 rrqm/s - 每秒合并的读取请求 wrqm/s - 每秒合并的写入请求 %rrqm - 读取请求合并百分比 %wrqm - 写入请求合并百分比 r_await - 读取请求平均等待时间 (ms) w_await - 写入请求平均等待时间 (ms) aqu-sz - 平均队列长度 rareq-sz - 平均读取请求大小 (KB) wareq-sz - 平均写入请求大小 (KB) svctm - 平均服务时间 (ms) %util - 设备带宽利用率 其他监控工具# dstat - 全能系统监控工具sudo apt-get install dstatdstat # 默认显示 CPU、磁盘、网络、系统负载dstat -y # 带单位显示dstat --full # 完整统计dstat -cdngy 1 # 显示 CPU、磁盘、网络、分页，每秒刷新dstat --output report.csv 1 60 # 输出到 CSV 文件# sar - 系统活动报告sudo apt-get install sysstatsar -u 1 10 # CPU 使用率，每秒，共 10 次sar -r 1 10 # 内存使用率sar -d 1 10 # 块设备活动sar -n DEV 1 10 # 网络设备统计sar -q 1 10 # 队列长度和负载sar -A # 所有统计# 查看历史数据sar -f /var/log/sysstat/sa15 # 查看 15 号的数据# nethogs - 按进程显示网络带宽sudo apt-get install nethogssudo nethogs # 显示每个进程的网络使用sudo nethogs eth0 # 监控特定接口# iotop - I/O 监控sudo apt-get install iotopsudo iotop # 显示 I/O 使用情况sudo iotop -o # 只显示有 I/O 的进程sudo iotop -b -n 5 # 批处理模式，采集 5 次# pidstat - 进程统计sudo apt-get install sysstatpidstat # CPU 统计pidstat -r # 内存统计pidstat -d # I/O 统计pidstat -w # 任务切换统计pidstat -u 1 5 # CPU，每秒，5 次pidstat -t -p PID # 显示指定进程的线程# slabtop - 内核 slab 缓存监控time slabtop# vmstat - 虚拟内存统计（前面已介绍）# perf - 性能分析工具sudo apt-get install linux-tools-common linux-tools-genericsudo perf top # 实时性能分析sudo perf stat -a sleep 5 # 5 秒系统级统计sudo perf record -a -g -- sleep 30 # 记录 30 秒sudo perf report # 查看报告 进程优先级nice 和 renice# nice - 以指定优先级启动进程# 取值范围：-20（最高优先级）到 19（最低优先级）# 默认：0# 普通用户只能设置正 nice 值# 以低优先级运行nice -n 10 long_running_tasknice --10 command # 注意：--10 表示 -10# renice - 修改运行中进程的优先级renice -n 5 -p PID # 修改指定进程renice -n 5 -u username # 修改某用户的所有进程renice -n 5 -g groupname # 修改某群组的所有进程# 查看进程优先级ps -eo pid,ni,cmd | grep firefoxpidstat -u -p PID # PR 列显示优先级# chrt - 实时调度策略chrt -f -p 99 PID # 设置 SCHED_FIFO，优先级 99chrt -r -p 50 PID # 设置 SCHED_RR，优先级 50chrt -o -p 0 PID # 设置 SCHED_OTHER（普通）chrt -p PID # 查看调度策略 实践练习练习：找出最耗资源的进程 #!/bin/bash# find_heavy_processes.shecho === CPU 使用率最高的 10 个进程 ===ps aux --sort=-%cpu | head -11 | tail -10 | awk printf %-10s %6s %5s %5s %s , $1, $2, $3, $4, $11echo echo === 内存使用率最高的 10 个进程 ===ps aux --sort=-%mem | head -11 | tail -10 | awk printf %-10s %6s %5s %5s %s , $1, $2, $3, $4, $11echo echo === 运行时间最长的 10 个进程 ===ps -eo user,pid,etime,cmd --sort=etime | tail -10echo echo === 当前用户的进程统计 ===echo 进程总数: $(ps -u $USER -o pid= | wc -l)echo CPU 使用: $(ps aux | awk -v user=$USER $1==user sum+=$3 END print sum %)echo 内存使用: $(ps aux | awk -v user=$USER $1==user sum+=$4 END print sum %) 练习：监控系统并自动处理高负载 #!/bin/bash# monitor_and_act.shLOG_FILE=/var/log/system_monitor.logCPU_THRESHOLD=80 # CPU 使用率阈值MEM_THRESHOLD=90 # 内存使用率阈值LOAD_THRESHOLD=$(nproc) # 负载阈值（核心数）log_message() echo [$(date +%Y-%m-%d %H:%M:%S)] $1 | tee -a $LOG_FILE# 获取系统信息get_system_info() CPU_USAGE=$(top -bn1 | grep Cpu(s) | awk print $2 | cut -d% -f1) MEM_USAGE=$(free | grep Mem | awk printf %.1f, $3/$2 * 100.0) LOAD_AVG=$(uptime | awk -Fload average: print $2 | awk print $1 | tr -d ,) DISK_USAGE=$(df -h / | tail -1 | awk print $5 | tr -d %)# 杀死最耗 CPU 的用户进程kill_heavy_processes() log_message WARNING: High CPU usage detected ($CPU_USAGE%). Taking action... # 获取最耗 CPU 的用户进程（排除 root 和系统进程） HEAVY_PIDS=$(ps aux --sort=-%cpu | grep -v ^root\\|^USER | head -5 | awk print $2) for PID in $HEAVY_PIDS; do PROCESS_INFO=$(ps -p $PID -o pid,ppid,cmd,%cpu --no-headers 2/dev/null) if [ -n $PROCESS_INFO ]; then log_message Killing process: $PROCESS_INFO kill -TERM $PID 2/dev/null sleep 2 # 检查是否仍在运行 if kill -0 $PID 2/dev/null; then log_message Process $PID still running, using SIGKILL kill -KILL $PID 2/dev/null fi fi done# 清理内存缓存clean_memory() log_message WARNING: High memory usage detected ($MEM_USAGE%). Cleaning caches... # 需要 root 权限 if [ $(id -u) -eq 0 ]; then sync echo 3 /proc/sys/vm/drop_caches log_message Memory caches cleaned else log_message WARNING: Root privileges required to clean memory caches fi# 主监控循环main() log_message System monitor started (PID: $$) log_message Thresholds - CPU: $CPU_THRESHOLD%, Memory: $MEM_THRESHOLD%, Load: $LOAD_THRESHOLD while true; do get_system_info log_message Status - CPU: $CPU_USAGE%, Memory: $MEM_USAGE%, Load: $LOAD_AVG, Disk: $DISK_USAGE% # 检查阈值 if (( $(echo $CPU_USAGE $CPU_THRESHOLD | bc -l) )); then kill_heavy_processes fi if (( $(echo $MEM_USAGE $MEM_THRESHOLD | bc -l) )); then clean_memory fi # 等待下次检查 sleep 60 done# 处理退出信号trap log_message Monitor stopped; exit 0 SIGTERM SIGINT# 运行main 延伸阅读 Linux Process Management Understanding Linux proc Signal Handling in Linux 理解进程管理是系统管理的核心技能"},{"title":"文件权限管理","path":"/p/74b9a2e8.shtml","content":"文件权限管理权限基础概念Linux 使用三种权限控制文件访问：读取(r)、写入(w)、执行(x)。这三种权限分别应用于三类用户：文件所有者(u)、所属群组(g)、其他用户(o)。 权限类型详解 读取权限 (r)文件：可读取文件内容目录：可列出目录内容（ls） 写入权限 (w)文件：可修改文件内容目录：可在目录中创建、删除、重命名文件 执行权限 (x)文件：可作为程序执行目录：可进入目录（cd） 查看文件权限使用 ls -l 命令ls -l filenamels -la /path/to/directory 输出示例解析： $ ls -l test.txt-rw-r--r-- 1 alice developers 1234 Jan 15 10:30 test.txt│└┬┘└┬┘└┬┘│ │ │ │ ││ │ │ │ │ │ │ │ └── 文件名│ │ │ │ │ │ │ └──────────── 修改时间│ │ │ │ │ │ └─────────────────── 所属群组│ │ │ │ │ └────────────────────────── 文件所有者│ │ │ │ └─────────────────────────────── 硬链接数│ │ │ └───────────────────────────────── 其他用户权限│ │ └───────────────────────────────────── 群组权限│ └───────────────────────────────────────── 所有者权限└─────────────────────────────────────────── 文件类型 文件类型标识 标识 类型 说明 - 普通文件 文本、数据、可执行文件等 d 目录 包含文件和其他目录 l 符号链接 指向其他文件的引用 c 字符设备 按字符流访问的设备（如终端） b 块设备 按块访问的设备（如硬盘） s 套接字 进程间通信端点 p 命名管道 进程间通信 修改文件权限chmod 命令详解符号模式数字模式参考速查表chmod [who][operator][permission] file... 参数说明： 类别 选项 含义 Who u 用户（所有者） g 群组 o 其他用户 a 所有用户（等同于 ugo） Operator + 添加权限 - 移除权限 = 设置精确权限 Permission r 读取权限 w 写入权限 x 执行权限 X 仅当文件是目录或已有执行权限时添加执行权限 s 设置 SUID 或 SGID t 设置粘滞位 示例： # 添加执行权限chmod +x script.sh # 给所有用户添加执行权限chmod u+x program # 仅给所有者添加执行权限# 移除权限chmod o-w file.txt # 移除其他用户的写入权限chmod go-rwx secret.txt # 移除群组和其他用户的所有权限# 设置精确权限chmod u=rwx,g=rx,o=r file # 所有者读写执行，群组读执行，其他只读# 递归修改目录chmod -R 755 /path/to/dir # 递归修改目录及其内容chmod [mode] file... 权限数字对应表： 权限 二进制 数字 --- 000 0 --x 001 1 -w- 010 2 -wx 011 3 r-- 100 4 r-x 101 5 rw- 110 6 rwx 111 7 常用权限组合： Mode 权限 用途 777 rwxrwxrwx 完全开放（不推荐） 755 rwxr-xr-x 标准可执行文件目录 750 rwxr-x— 私有可执行文件目录 700 rwx—— 完全私有 644 rw-r–r– 标准普通文件 640 rw-r—– 群组可读 600 rw——- 私有文件 示例： chmod 755 script.sh # 可执行脚本chmod 644 document.txt # 普通文档chmod 600 ~/.ssh/id_rsa # 私钥文件chmod 700 ~/private_dir # 私有目录chmod -R 755 ~/bin # 递归设置常用文件权限设置： # Web 服务器目录find /var/www -type d -exec chmod 755 \\;find /var/www -type f -exec chmod 644 \\;# SSH 密钥chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pubchmod 644 ~/.ssh/authorized_keyschmod 644 ~/.ssh/known_hosts# 脚本文件chmod +x script.sh # 添加执行权限chmod u+s program # 设置 SUID 修改文件所有者和群组chown 命令chown [选项] [所有者][:群组] 文件... 常用选项： -R : 递归修改目录及其内容 -c : 只在发生改变时报告 -v : 显示详细处理过程 --reference=RFILE : 使用参考文件的属主 示例： # 修改所有者chown alice file.txt# 修改群组chown :developers file.txtchgrp developers file.txt # 等效命令# 同时修改所有者和群组chown alice:developers file.txt# 递归修改目录chown -R alice:alice /home/alice/project# 使用参考文件chown --reference=template.txt newfile.txt# 仅修改符号链接本身（而非目标）chown -h alice symlink chgrp 命令专门用于修改群组： chgrp [选项] 群组 文件... 示例： chgrp developers project/chgrp -R www-data /var/www 特殊权限SUID (Set User ID)当可执行文件设置了 SUID 位，用户执行该文件时，进程的有效用户ID会变成文件所有者的ID，而不是执行者的ID。 应用场景：passwd 命令 $ ls -l /usr/bin/passwd-rwsr-xr-x 1 root root 68208 Jul 15 2021 /usr/bin/passwd ↑ SUID 位（所有者的 x 位置） 普通用户可以通过 passwd 修改自己的密码（需要写入 etcshadow），就是因为 passwd 有 SUID 位，执行时临时获得了 root 权限。 设置 SUID： chmod u+s /path/to/program # 符号模式chmod 4755 /path/to/program # 数字模式（4 表示 SUID） 注意： 大写 S 表示没有执行权限但设置了 SUID SUID 对目录无效（在某些 BSD 系统上有特殊用途） 不当使用 SUID 可能带来安全风险 SGID (Set Group ID)对可执行文件类似于 SUID，但继承的是文件所属群组的权限。 $ ls -l /usr/bin/wall-rwxr-sr-x 1 root tty 30800 Feb 28 2022 /usr/bin/wall ↑ SGID 位（群组的 x 位置） 对目录在设置了 SGID 的目录中创建的新文件，其所属群组会自动继承目录的群组，而不是创建者的主群组。 应用场景：共享项目目录 # 创建项目目录mkdir /srv/projectchgrp developers /srv/projectchmod 2770 /srv/project # 设置 SGID# 现在任何在此目录创建的文件都属于 developers 群组 设置 SGID： chmod g+s /path/to/directory # 符号模式chmod 2775 /path/to/directory # 数字模式（2 表示 SGID） 注意：大写 S 表示没有执行权限但设置了 SGID。 Sticky Bit (粘滞位)粘滞位只对目录有效。设置了粘滞位的目录，只有文件所有者、目录所有者或 root 才能删除或重命名该目录中的文件，即使其他用户有写权限也不行。 典型应用：/tmp 目录 $ ls -ld /tmpdrwxrwxrwt 15 root root 4096 Jan 15 10:30 /tmp ↑ 粘滞位（其他人的 x 位置） 所有用户都可以在 /tmp 创建文件，但只能删除自己的文件，防止恶意删除他人的临时文件。 设置粘滞位： chmod +t /path/to/directory # 符号模式chmod 1777 /path/to/directory # 数字模式（1 表示粘滞位） 注意：大写 T 表示没有执行权限但设置了粘滞位。 特殊权限速查表┌─────────────────────────────────────────────────────┐│ 权限位布局 │├─────────────────────────────────────────────────────┤│ SUID │ SGID │ Sticky │ User │ Group │ Other ││ (4) │ (2) │ (1) │ (rwx) │ (rwx) │ (rwx) │└─────────────────────────────────────────────────────┘常用组合：├── 4755 (rwsr-xr-x) = SUID + 755├── 2755 (rwxr-sr-x) = SGID + 755├── 1777 (rwxrwxrwt) = Sticky + 777 (如 /tmp)└── 6755 (rwsr-sr-x) = SUID + SGID + 755符号模式：├── u+s = 设置 SUID├── g+s = 设置 SGID├── o+t = 设置粘滞位└── a = 所有用户 (u+g+o) 实践练习练习：设置共享开发目录 场景：团队共享的项目目录 /srv/webapp # 1. 创建目录并设置正确的群组sudo mkdir -p /srv/webappsudo groupadd webdevsudo chown root:webdev /srv/webapp# 2. 设置 SGID，使新文件继承目录群组sudo chmod 2770 /srv/webapp# 3. 设置目录权限# 2 = SGID, 7 = rwx (所有者), 7 = rwx (群组), 0 = --- (其他)sudo chmod 2770 /srv/webapp# 4. 将开发用户添加到群组sudo usermod -aG webdev alicesudo usermod -aG webdev bob# 5. 验证设置ls -ld /srv/webapp# 预期输出：drwxrws--- 2 root webdev ...# 6. 测试（切换到开发用户）su - alicetouch /srv/webapp/test.txtls -l /srv/webapp/test.txt# 预期：文件群组应该是 webdev，而不是 alice 的主群组 练习：SUID 安全分析 任务：分析系统中的 SUID 文件 # 1. 查找所有 SUID 文件find / -perm -4000 -type f 2/dev/null# 2. 查找所有 SGID 文件find / -perm -2000 -type f 2/dev/null# 3. 详细查看 SUID 文件find /usr/bin -perm -4000 -ls 2/dev/null# 4. 检查可疑的自定义 SUID 程序# 正常的 SUID 程序通常在标准位置# /usr/bin/passwd# /usr/bin/sudo# /usr/bin/su# /usr/bin/mount# /usr/bin/umount# /usr/bin/ping# ...# 5. 安全审计脚本echo === SUID 文件安全审计 ===echo 系统 SUID 文件数量：find / -perm -4000 -type f 2/dev/null | wc -lecho echo 非标准位置的 SUID 文件：find / -perm -4000 -type f 2/dev/null | grep -v -E ^/(usr/|bin/|sbin/|usr/sbin/)echo echo 最近修改的 SUID 文件：find / -perm -4000 -type f -mtime -7 2/dev/null 常见问题 FAQ为什么无法访问文件，即使我是 root？ 可能原因：文件位于挂载为 noexec、nodev 或 nosuid 的文件系统上。 # 查看挂载选项mount | grep /path/to/mount# 示例输出：# /dev/sda1 on /home type ext4 (rw,nosuid,nodev,noexec,relatime)# 解决方案：重新挂载（临时）sudo mount -o remount,exec,suid /home# 或编辑 /etc/fstab 永久修改 如何恢复误删的权限？ 场景：不小心执行了 chmod -R 777 / # 1. 立即停止系统写入（避免更多损坏）# 2. 使用 Live CD/USB 启动# 3. 挂载根分区sudo mount /dev/sda1 /mnt# 4. 使用包管理器恢复默认权限（推荐）# Debian/Ubuntu:sudo dpkg --root=/mnt --configure -a# CentOS/RHEL/Fedora:# 使用 rpm 恢复或重新安装关键包# 5. 手动修复关键目录sudo chmod 755 /mnt/bin /mnt/lib /mnt/lib64 /mnt/sbin /mnt/usrsudo chmod 555 /mnt/bootsudo chmod 1777 /mnt/tmpsudo chmod 755 /mnt/var# 6. 验证并重启 预防措施： 使用 chmod --reference 代替手动设置 重要操作前使用 getfacl -R /path permissions_backup.acl 备份权限 ACL 与基本权限的区别？ 基本权限的局限： 只能设置一个所有者 只能设置一个群组 其他人的权限是统一的 ACL (Access Control List) 的优势： 可以为多个用户设置不同权限 可以为多个群组设置不同权限 支持默认 ACL（新文件自动继承） # 检查文件系统是否支持 ACLmount | grep acl# 安装 ACL 工具sudo apt-get install acl # Debian/Ubuntusudo yum install acl # CentOS/RHEL# 查看 ACLgetfacl filename# 设置 ACLsetfacl -m u:alice:rwx filename # 给用户 alice 设置 rwxsetfacl -m g:developers:rw filename # 给群组 developers 设置 rwsetfacl -x u:alice filename # 移除 alice 的 ACLsetfacl -b filename # 移除所有 ACL# 设置默认 ACL（目录）setfacl -d -m u:alice:rwx /shared/dirsetfacl -R -m u:alice:rwx /shared/dir # 递归设置 延伸阅读 Linux 文件权限完全指南 Understanding Linux File Permissions ACL - Arch Wiki 权限管理是 Linux 安全的基石"},{"title":"文件系统与目录结构","path":"/p/e8e1846f.shtml","content":"文件系统与目录结构Linux 目录结构概览Linux 采用单根目录树结构，所有文件和目录都从根目录 / 开始组织。 / (根目录)│├── /bin # 基本用户命令（二进制文件）├── /boot # 启动加载器文件├── /dev # 设备文件├── /etc # 系统配置文件├── /home # 用户主目录│ ├── /home/alice│ ├── /home/bob│ └── ...├── /lib # 共享库文件├── /media # 可移动媒体挂载点├── /mnt # 临时挂载点├── /opt # 可选应用软件├── /proc # 进程信息虚拟文件系统├── /root # root 用户主目录├── /run # 运行时变量数据├── /sbin # 系统管理命令├── /srv # 服务数据├── /sys # 系统信息虚拟文件系统├── /tmp # 临时文件├── /usr # 用户程序和数据│ ├── /usr/bin # 用户命令│ ├── /usr/lib # 库文件│ ├── /usr/local # 本地安装软件│ └── /usr/share # 共享数据└── /var # 可变数据文件 ├── /var/log # 日志文件 ├── /var/spool # 任务队列 └── /var/tmp # 持久临时文件 重要目录详解 bin 和 sbin/bin - Essential user binaries单用户模式下也需要的命令例如：ls, cp, mv, cat, mkdir/sbin - System binaries系统管理命令例如：fdisk, fsck, reboot, iptables etc系统配置文件重要配置文件：/etc/passwd - 用户账户信息/etc/shadow - 用户密码（加密）/etc/group - 群组信息/etc/hosts - 主机名解析/etc/fstab - 文件系统表/etc/resolv.conf - DNS 配置/etc/crontab - 定时任务/etc/ssh/sshd_config - SSH 配置 home 和 root/home - 普通用户主目录/home/├── alice/ ← 用户 alice 的家├── bob/ ← 用户 bob 的家└── charlie/ ← 用户 charlie 的家/root - root 用户主目录root 是超级管理员与普通用户分离，提高安全性 var可变数据文件/var/log - 系统日志/var/log/syslog 或 /var/log/messages/var/log/auth.log 或 /var/log/secure/var/log/kern.log/var/spool - 任务队列/var/spool/cron - 定时任务/var/spool/mail - 用户邮件/var/cache - 应用缓存/var/lib - 应用状态数据/var/lib/mysql - MySQL 数据/var/lib/dpkg - 包管理状态 文件系统类型常见 Linux 文件系统 文件系统 特点 适用场景 EXT4 稳定、成熟、 journaling 通用，推荐大多数场景 XFS 高性能大文件、并行IO 大数据、媒体存储 Btrfs 快照、压缩、校验和 高级功能需求 ZFS 企业级特性、数据完整性 企业存储、NAS F2FS 针对闪存优化 SSD、嵌入式设备 文件系统层次标准 (FHS)Filesystem Hierarchy Standard (FHS) FHS 定义了类 Unix 系统中目录结构和目录内容的标准，确保软件能在不同的 Linux 发行版间兼容。 查看当前系统 FHS 合规性： # 检查关键目录是否存在ls -la / | grep -E bin|boot|dev|etc|home|lib|media|mnt|opt|proc|root|run|sbin|srv|sys|tmp|usr|var# 查看文件系统挂载情况df -hT# 查看当前挂载的文件系统cat /proc/mounts 实用命令速查目录操作文件操作文件系统管理查找与定位# 显示当前目录pwd# 切换目录cd /path/to/dir # 绝对路径cd ../parent # 相对路径cd ~ # 回到用户主目录cd - # 回到上次目录# 列出目录内容ls # 基本列表ls -la # 显示所有文件（包括隐藏）ls -lh # 人类可读格式ls -lt # 按时间排序ls -ltr # 按时间倒序# 创建目录mkdir dirname # 创建单个目录mkdir -p path/to/nested/dir # 创建嵌套目录# 删除目录rmdir dirname # 删除空目录rm -r dirname # 递归删除目录rm -rf dirname # 强制递归删除（谨慎使用！）# 复制目录cp -r source dest # 递归复制# 移动/重命名目录mv oldname newname # 重命名mv source /path/to/dest # 移动# 创建文件touch filename # 创建空文件 filename # 创建空文件（重定向）# 查看文件内容cat filename # 显示全部内容cat -n filename # 显示行号less filename # 分页查看（支持上下滚动）more filename # 分页查看（只能向下）head filename # 显示前10行head -n 20 filename # 显示前20行tail filename # 显示后10行tail -n 20 filename # 显示后20行tail -f filename # 实时追踪文件更新（常用于日志）# 编辑文件nano filename # 简单编辑器vim filename # 强大编辑器vi filename # 兼容模式# 搜索文件内容grep pattern filename # 基本搜索grep -i pattern filename # 忽略大小写grep -n pattern filename # 显示行号grep -r pattern /path/ # 递归搜索目录grep -v pattern filename # 反向匹配（排除）# 文件比较diff file1 file2 # 比较两个文件差异cmp file1 file2 # 逐字节比较# 文件统计wc filename # 统计行数、单词数、字节数wc -l filename # 只统计行数wc -w filename # 只统计单词数# 查看磁盘空间df -h # 人类可读格式df -hT # 显示文件系统类型df -i # 查看 inode 使用情况# 查看目录/文件大小du -sh /path # 查看目录总大小du -h --max-depth=1 /path # 查看子目录大小du -ah /path | sort -rh | head -20 # 找出最大的20个文件# 文件系统检查（需要卸载或使用 live CD）fsck /dev/sda1 # 检查并修复文件系统e2fsck /dev/sda1 # ext 文件系统专用# 挂载与卸载mount /dev/sdb1 /mnt/usb # 挂载设备mount -o loop iso.iso /mnt/iso # 挂载 ISO 文件umount /mnt/usb # 卸载mount | grep /dev/sda # 查看挂载状态# 创建文件系统mkfs.ext4 /dev/sdb1 # 创建 ext4 文件系统mkfs.xfs /dev/sdb1 # 创建 xfs 文件系统mkswap /dev/sdb2 # 创建 swap 分区# LVM 基本操作pvcreate /dev/sdb # 创建物理卷vgcreate vg0 /dev/sdb # 创建卷组lvcreate -L 10G -n lv0 vg0 # 创建逻辑卷# find 命令（功能最强大）find /path -name *.txt # 按名称查找find /path -iname *.txt # 忽略大小写find /path -type f -name *.log # 只找文件find /path -type d -name backup # 只找目录find /path -size +100M # 大于100MB的文件find /path -size -1k # 小于1KB的文件find /path -mtime -7 # 7天内修改过的文件find /path -user username # 属于某用户的文件find /path -perm 644 # 特定权限的文件find /path -name *.tmp -delete # 查找并删除find /path -name *.log -exec gzip \\; # 查找并压缩find /path -name *.txt | xargs grep pattern # 结合 xargs 使用# locate 命令（基于数据库，速度更快）updatedb # 更新 locate 数据库locate filename # 快速查找文件locate -i filename # 忽略大小写locate *.conf # 支持通配符locate -n 10 *.log # 限制结果数量# which 和 whereiswhich command # 查找命令的可执行文件位置which -a command # 显示所有匹配的路径whereis command # 查找命令的二进制、源码和 man 手册whereis -b command # 只找二进制文件# type 命令type command # 显示命令类型（别名、内置命令、外部命令）type -a command # 显示所有匹配项 延伸阅读 Linux 文件系统层次标准 (FHS) 鸟哥的 Linux 私房菜 - 目录配置 理解目录结构是掌握 Linux 的第一步"},{"title":"Linux 基础入门","path":"/p/23c3e7ed.shtml","content":"Linux 基础入门计算机概论计算机的组成 输入单元：键盘、鼠标、扫描仪等 输出单元：显示器、打印机等 控制单元：协调各组件工作 算术逻辑单元 (ALU)：进行数学和逻辑运算 记忆单元：内存和存储设备 CPU 架构 架构类型 代表厂商 特点 CISC Intel, AMD 复杂指令集，性能强，功耗高 RISC ARM, Apple Silicon 精简指令集，低功耗，高效能 Linux 简介什么是 Linux？Linux 是一种类 Unix 操作系统内核，由 Linus Torvalds 于 1991 年首次发布。 Linux 的组成┌─────────────────────────────────────┐│ 应用程序层 │ ← Shell、编辑器、浏览器等├─────────────────────────────────────┤│ Shell 层 │ ← Bash、Zsh、Fish 等├─────────────────────────────────────┤│ 内核层 (Kernel) │ ← 进程管理、内存管理、文件系统等├─────────────────────────────────────┤│ 硬件层 │ ← CPU、内存、硬盘、外设等└─────────────────────────────────────┘ 流行的 Linux 发行版 服务器领域Red Hat Enterprise Linux - 企业级支持CentOS - 社区企业版 (现已转向 Stream)Ubuntu Server - 易用，社区活跃Debian - 稳定，适合服务器SUSE - 欧洲企业首选 桌面领域Ubuntu - 最受欢迎的桌面版Fedora - 新技术试验田Linux Mint - 适合新手Manjaro - 基于 Arch，易用Pop!_OS - 适合开发者 特殊用途Kali Linux - 安全渗透测试Alpine - 轻量级容器基础Arch Linux - 滚动更新，高度定制Gentoo - 源码编译，极致优化 学习路径建议graph LR A[基础入门] --> B[命令行操作] B --> C[文件系统] C --> D[权限管理] D --> E[Shell脚本] E --> F[系统管理] F --> G[网络配置] G --> H[服务部署] style A fill:#4CAF50 style H fill:#FF5722 千里之行，始于足下"},{"title":"基础配置入门","path":"/p/ddc73fa7.shtml","content":"基础配置入门⭐掌握基础配置是主题装修的核心技能 配置文件概述Stellar 主题的配置分为多个层级，了解它们的关系对于定制非常重要。 配置层级 配置文件 优先级 用途 _config.stellar.yml 最高 站点级覆盖配置（推荐修改） themes/stellar/_config.yml 中等 主题默认配置 _config.yml 基础 Hexo 站点基础配置 **重要提示：**永远不要在 themes/stellar/_config.yml 中直接修改，而是创建 _config.stellar.yml 文件进行覆盖配置。这样主题更新时不会丢失你的定制。 创建覆盖配置文件步骤 1：创建文件在博客站点根目录（与 _config.yml 同级）创建 _config.stellar.yml 文件： # 在博客根目录执行touch _config.stellar.yml 步骤 2：基本结构在 _config.stellar.yml 中，你只需要写需要覆盖的配置项，不需要复制全部内容。 # _config.stellar.yml 示例# 站点基本信息site: name: 我的博客 icon: /img/favicon.ico# 导航菜单menubar: columns: 4 items: - id: home theme: #1BCDFC icon: title: 首页 url: / - id: wiki theme: #3DC550 icon: ... title: 文档 url: /wiki/ 常用配置项详解站点配置（site） 配置项 类型 说明 site.name string 站点名称 site.icon string 站点图标路径 site.desc string 站点描述 site.url string 站点 URL 颜色配置（color）color: # 主色调 - 用于链接、按钮、激活状态 theme: #7bcfa6 # 强调色 - 用于高亮、徽章 accent: #e0f0e9 # 文字颜色 text: #333333 # 次要文字 text-secondary: #666666 # 背景色 background: #ffffff # 代码块背景 code: #f5f5f5 # 边框颜色 border: #e8e8e8 导航栏配置（menubar）menubar: # 列数（1-6） columns: 4 items: - id: home theme: #1BCDFC icon: title: 首页 url: / - id: wiki theme: #3DC550 icon: ... title: 文档 url: /wiki/ 配置验证技巧1. 使用 YAML 检查工具YAML 对缩进非常敏感，建议使用以下方式检查： VS Code 插件：YAML（redhat.vscode-yaml） 在线工具：YAML Lint 2. 启用 Hexo 调试模式# 启动服务器时显示调试信息hexo server --debug# 生成时显示详细日志hexo generate --debug 3. 常见配置错误 错误类型 表现 解决方法 缩进错误 YAML 解析失败 统一使用空格缩进（不要用 Tab） 中文冒号 配置项不生效 使用英文冒号（:）并留空格 路径错误 资源加载失败 检查路径是否以 开头 小结与练习本章重点 理解配置层级：站点级 主题级 默认配置 掌握覆盖配置的方法：使用 _config.stellar.yml 了解常用配置项：站点信息、颜色、导航栏 学会验证配置：使用调试模式和 YAML 检查工具 动手练习 创建 _config.stellar.yml 文件 修改站点名称为你的名字 将主题色改为你喜欢的颜色 在导航栏添加一个新的菜单项 下一步掌握了基础配置后，让我们深入了解各项功能的详细配置： 站点信息配置 - 完善博客的基本信息"},{"title":"了解文件结构","path":"/p/8bf2b494.shtml","content":"了解文件结构⭐理解文件结构是主题装修的第一步 Stellar 主题文件结构概览在开始定制之前，我们需要了解 Stellar 主题的文件组织结构。这有助于你快速定位需要修改的文件。 主题目录结构themes/stellar/├── _config.yml # 主题主配置文件├── _config.stellar.yml # 站点覆盖配置（推荐在这里修改）├── layout/ # 页面模板│ ├── _partial/ # 局部模板（头部、尾部、侧边栏等）│ ├── _widget/ # 小组件模板│ ├── archive.ejs # 归档页│ ├── index.ejs # 首页│ ├── page.ejs # 独立页面│ ├── post.ejs # 文章页│ └── wiki.ejs # Wiki 页├── source/ # 静态资源│ ├── css/ # 主题样式│ ├── js/ # 主题脚本│ └── fonts/ # 字体文件└── scripts/ # Hexo 脚本 └── ... 关键配置文件说明1. 主题配置文件Stellar 主题有两个主要配置文件： themes/stellar/_config.yml - 主题默认配置（不建议直接修改） _config.stellar.yml - 站点根目录下的覆盖配置（推荐） **最佳实践：**在站点根目录创建 _config.stellar.yml 文件来覆盖主题默认配置。这样主题更新时不会丢失你的定制。 2. 数据文件目录Stellar 主题使用 source/_data/ 目录存放各种数据配置： source/_data/├── authors.yml # 作者信息├── wiki.yml # Wiki 项目列表├── wiki/ # Wiki 项目配置│ ├── c.yaml│ └── python.yaml└── widgets.yml # 小组件库 目录与文件的作用布局模板（layout） 文件 用途 index.ejs 首页模板 post.ejs 博客文章页 wiki.ejs Wiki 文档页 page.ejs 独立页面 archive.ejs 归档页面 静态资源（source） 目录 用途 css/ 样式文件（.css、.styl、.scss） js/ JavaScript 脚本 fonts/ 字体文件 img/ 图片资源 装修前的重要提醒备份！备份！备份！在开始任何修改之前，务必备份以下文件： _config.yml - 站点主配置 _config.stellar.yml - 主题覆盖配置 source/_data/ 目录下的所有数据文件 source/ 目录下的自定义资源 修改原则 不修改主题源文件：避免直接修改 themes/stellar/ 下的文件 使用覆盖配置：通过 _config.stellar.yml 覆盖默认配置 使用自定义目录：将自定义资源放在 source/custom/ 或 source/css/ 渐进式修改：每次只修改一处，验证效果后再继续 推荐的开发流程： 本地运行 hexo server 开启开发服务器 修改配置文件或添加自定义样式 浏览器实时预览效果（大部分修改会自动刷新） 满意后提交修改到 Git 仓库 下一步现在你已经了解了 Stellar 主题的文件结构，接下来让我们开始学习基础配置： 基础配置入门 - 了解核心配置文件和常用设置"},{"title":"主题装修指南","path":"/p/fec73520.shtml","content":"主题装修指南⭐打造独一无二的个人博客，从主题装修开始 什么是主题装修？主题装修是指对 Hexo 博客的 Stellar 主题进行个性化定制和美化的过程。通过调整配置、修改样式、添加功能，你可以将默认的主题打造成符合个人风格的独特博客。 本专栏将带你从入门到精通，全面掌握 Stellar 主题的定制技巧，包括： 基础配置：站点信息、导航菜单、侧边栏设置 视觉美化：配色方案、字体定制、背景设置 功能扩展：评论系统、搜索功能、插件集成 进阶技巧：动画效果、自定义组件、性能优化 Stellar 主题简介Stellar 是一个专为博客设计的 Hexo 主题，具有以下特点： 设计理念 极简主义：真正的极简不是简单删减，而是在复杂中创造秩序 降低视觉密度：更多留白、更少颜色，让内容更突出 信息优先级：文章标题最大、对比度最高 消除无效信息：去除字数统计、浏览量等干扰元素 核心功能 多内容类型：文章、Wiki、笔记、说说等多种内容形态 强大的组件系统：丰富的标签插件和小组件 完善的导航：树形目录、面包屑、相关文章推荐 响应式设计：完美适配桌面和移动设备 学习路径本专栏按照由浅入深的原则组织内容，建议你按以下顺序学习： 第一阶段：入门准备 了解文件结构 - 认识 Stellar 主题的组织方式 第二阶段：基础配置 基础配置入门 - 掌握核心配置文件 站点信息配置 - 设置博客基本信息 第三阶段：界面定制 导航定制 - 自定义菜单和导航 侧边栏配置 - 设置左右侧边栏 页脚定制 - 自定义页脚内容 第四阶段：视觉美化 配色与字体 - 自定义颜色和字体 自定义 CSS - 编写自定义样式 背景设置 - 设置各种背景效果 第五阶段：功能扩展 评论系统 - 集成评论功能 搜索功能 - 配置站内搜索 插件集成 - 添加实用插件 第六阶段：进阶技巧 动画效果 - 添加交互动画 自定义组件 - 开发专属组件 性能优化 - 提升加载速度 第七阶段：实战案例 装修实例 - 完整案例分析 常见问题 - FAQ 与疑难解答 准备工作在开始主题装修之前，请确保你已经具备以下条件： 环境要求 已安装 Node.js (14.17.3+) 已安装 Hexo CLI 已克隆或下载 Stellar 主题 本地可以正常运行 hexo server 工具准备 代码编辑器 (VS Code 推荐) 浏览器开发者工具 YAML 语法检查工具 知识储备 基本的 HTMLCSS 知识 YAML 配置语法 Git 基本操作 开始你的装修之旅现在，你已经了解了本专栏的整体结构和学习路径。让我们从基础开始，一步步打造属于你的独特博客主题。 **提示：**主题装修是一个循序渐进的过程，不必急于求成。建议你在学习每个章节后，立即动手实践，这样才能真正掌握每个知识点。 准备好开始了吗？点击下面的链接，进入第一章：了解文件结构。"},{"title":"1.1 计算机基础","path":"/p/c57c4400.shtml","content":"1.1 计算机基础⭐掌握计算机基础知识是学习编程的第一步 计算机特点计算机作为一种通用的信息处理工具，具有极高的处理速度、很强的存储能力、精确的计算和逻辑判断能力。 1. 运算速度快当今计算机的运算速度已经达到每秒几十亿亿次，微机也可以达到每秒亿次以上。 2020年，Fugaku的峰值浮点性能高达537PFLOPS（一秒钟可以进行10^15次运算）。 2. 计算精确度高一般计算机可以有十几位甚至几十位（二进制）有效数字，计算精度可由千分之几到百万分之几。 3. 具有记忆和逻辑判断能力随着计算机的发展，计算机不仅能进行计算，还能把各种数据储存起来，来供人们随时调用。还可以通过编码技术对各种计算信息进行算术运算和逻辑运算，还可以进行推理和证明。 4. 自动控制能力计算机可以按照内部设定好的程序自动控制进行。 计算机常用的数制及编码数制也叫计数制，用一组固定的符号和统一的规则来表示数值的方法。 编码是通过采用少量的基本符号，选用一定的组合原则，以表示大量复杂多样的信息的技术。 1. 二进制二进制是一种数制，它使用两个符号（0和1）来表示所有的数值。在计算机科学中，二进制系统是非常重要的，因为它是大多数现代计算机处理数据的基础。 有两个不同的数字符号，0和1 逢二进一（二进制的基数为2） 2. 其他数制基本概念： 数位：数码在一个数所处的位置 基数：在某种进位数制中，每个数码上所能使用的数码的个数 必须逢N进1 （1）十进制数有十个不同的数码0、1、2、3、4、5、6、7、8、9，基数为10，特点是逢10进一。 （2）八进制八个不同的数码0、1、2、3、4、5、6、7，基数为8，逢八进一。 （3）十六进制有十六个不同的数码符号0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F（可小写）。 二进制数的不同进制对照表 二进制 十进制 八进制 十六进制 0000 0 0 0 0010 2 2 2 0110 6 6 6 1000 8 10 8 1010 10 12 A 1100 12 14 C ASCII 码ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）是一种基于拉丁字母的字符编码，主要用于显示现代英语和其他西欧语言。 原始的ASCII表使用7位二进制数来表示128个可能的不同字符。后来扩展到8位以支持更多的字符，总共可以表示256个不同的值。 常用ASCII码表 十进制 十六进制 字符 描述 0 0x00 NUL 空字符 10 0x0A LF 换行 13 0x0D CR 回车 32 0x20 (空格) 空格 48-57 0x30-0x39 0-9 数字0-9 65-90 0x41-0x5A A-Z 大写英文字母 97-122 0x61-0x7A a-z 小写英文字母 Unicode 编码和 UTF-8 编码Unicode 编码Unicode是一个国际标准，它为世界上几乎所有的字符集定义了一个统一的、唯一的数字编号。每个字符都被赋予了一个唯一的代码点（code point），这个代码点是用十六进制表示的。 例如，拉丁字母”A”的Unicode代码点是U+0041。 UTF-8 编码UTF-8 (Unicode Transformation Format - 8 bit) 是Unicode的一种实现方式，它是一种变长编码，可以使用1到4个字节来表示一个Unicode字符。 对于ASCII范围内的字符（U+0000至U+007F），UTF-8使用单个字节 对于其他基本多语言平面（BMP）内的字符（U+0080至U+FFFF），UTF-8使用两个或三个字节 对于超出BMP的字符，则需要四个字节 💡 UTF-8 的优势由于UTF-8的高效性和向后兼容性，它已成为互联网上最常用的字符编码之一。大多数现代操作系统和编程环境默认都支持UTF-8。 进制转换和二进制运算十进制转二进制整数部分除以2，直到余数为0，然后将余数倒序排列。 原码、反码和补码 正数的原码、反码和补码都一样 负数的反码是用它的原码转化得到的（符号位不变，其他0变1，1变0） 计算机内部用补码进行运算 # Python中的进制表示# 二进制binary_num = 0b1010 # 10的十进制# 八进制octal_num = 0o12 # 10的十进制# 十六进制hex_num = 0xA # 10的十进制print(binary_num) # 输出: 10print(octal_num) # 输出: 10print(hex_num) # 输出: 10 下一步学习掌握了计算机基础知识后，建议继续学习： Python语言简介 - 了解Python的运算符和基本语法 数字类型 - 学习Python中的数字类型"},{"title":"Python语言简介","path":"/p/a4de54c0.shtml","content":"Python语言简介⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"数字类型","path":"/p/4759e471.shtml","content":"数字类型⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"字符串","path":"/p/fc81fbfd.shtml","content":"字符串⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"赋值语句","path":"/p/c3d5663c.shtml","content":"赋值语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"条件语句","path":"/p/25684c8f.shtml","content":"条件语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"循环语句","path":"/p/b38e349f.shtml","content":"循环语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"列表","path":"/p/9eaa2eb6.shtml","content":"列表⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"元组","path":"/p/30e8fbca.shtml","content":"元组⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"字典","path":"/p/730cec53.shtml","content":"字典⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"集合","path":"/p/d366874c.shtml","content":"集合⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"函数定义","path":"/p/d4e36359.shtml","content":"函数定义⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"参数传递","path":"/p/350b832e.shtml","content":"参数传递⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"模块与包","path":"/p/3a3b1e59.shtml","content":"模块与包⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"类与对象","path":"/p/3a517f26.shtml","content":"类与对象⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"继承与多态","path":"/p/3a088510.shtml","content":"继承与多态⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"文件操作","path":"/p/95495db.shtml","content":"文件操作⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"异常处理","path":"/p/28877bf.shtml","content":"异常处理⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"装饰器","path":"/p/da520e93.shtml","content":"装饰器⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"R2 图床服务：打造你的专属高性能图片托管平台","path":"/p/24faff5b.shtml","content":"R2 图床服务：打造你的专属高性能图片托管平台在数字化时代，图片已成为信息传递的重要载体。无论是个人博客、技术文档还是商业应用，都需要一个稳定、快速、经济的图片托管解决方案。今天，我们要介绍的 R2 图床服务 正是这样一款基于 Cloudflare 全球网络的现代化图床系统，它不仅解决了传统图床的种种痛点，更带来了前所未有的使用体验。 🌟 为什么选择 R2 图床服务？1. 极致性能，全球加速依托 Cloudflare 遍布全球的 300+ 数据中心，你的图片将被智能缓存到离用户最近的节点。无论你身在何处，图片加载都能在毫秒级完成，真正实现”秒开”体验。 2. 成本革命，经济实惠相比传统云存储服务，R2 的存储成本降低 90% 以上。对于个人开发者和小型团队而言，这意味着可以用极低的成本获得企业级的服务品质。 3. 无限扩展，无惧增长从几张图片到百万级图片库，系统都能自动适应。无需担心存储容量、带宽限制或并发访问，真正做到”上传即安心”。 🎨 功能亮点：不止于存储📸 智能图片管理 多格式支持：JPG、PNG、GIF、WebP、SVG 一网打尽 拖拽上传：优雅的交互体验，支持批量上传 实时预览：上传过程中即可预览图片效果 智能分类：按日期自动组织文件夹，管理井井有条 🔗 便捷链接管理 一键复制：CDN 链接、原始链接，一键直达剪贴板 多域名支持：自定义域名 + CDN 加速，灵活配置 永久链接：图片链接永不失效，放心使用 📊 实时数据洞察 统计面板：今日上传、总图片数、存储用量一目了然 趋势分析：了解图片使用模式，优化存储策略 🛠️ 技术架构：现代开发的典范核心技术栈 Cloudflare Workers：无服务器架构，自动扩缩容 R2 存储：兼容 S3 API，迁移零成本 边缘计算：全球部署，就近处理请求 JWT 认证：安全可靠的访问控制 开发体验// 5 行代码完成图片上传const formData = new FormData();formData.append(file, imageFile);const response = await fetch(/api/upload, method: POST, body: formData);const cdnUrl = await response.json();// 你的图片现在已在全球加速！ 🚀 部署指南：从 0 到生产环境步骤 1：准备工作（5 分钟）# 安装工具npm install -g wranglerwrangler login# 克隆项目git clone your-repocd r2-workernpm install 步骤 2：配置环境（3 分钟）创建 wrangler.jsonc，填入你的配置： name: my-image-host, r2_buckets: [ binding: image_host_bucket, bucket_name: my-images ], vars: CUSTOM_DOMAIN: images.yourdomain.com, CDN_DOMAIN: cdn.yourdomain.com 步骤 3：一键部署（1 分钟）npm run deploy# 完成！你的图床已上线 💡 使用场景：无限可能个人博客 Markdown 写作：复制图片链接，直接插入文档 HexoHugo：配合静态博客，实现图片资源分离 Obsidian：作为附件存储，保持笔记整洁 🎯 性能实测数据 场景 传统图床 R2 图床服务 提升 图片加载速度 2-5 秒 200-500ms 10 倍提升 并发处理 100 reqs 10,000+ reqs 100 倍提升 存储成本 $0.023GB月 $0.015GB月 35% 节省 全球覆盖 单区域 300+ 节点 全球加速 🔒 安全与隐私 端到端加密：传输过程全程 HTTPS 访问控制：基于 JWT 的细粒度权限管理 数据隔离：每个用户独立命名空间 备份机制：多重备份，数据永不丢失 🌈 开源社区R2 图床服务完全开源，拥抱社区力量： GitHub 仓库：欢迎 Star、Fork、贡献代码 问题反馈：活跃的 Issue 响应 功能建议：社区驱动的功能迭代 中文文档：完善的本土化支持 📱 多端适配无论是桌面端还是移动端，都能获得完美的使用体验： 响应式设计：自适应各种屏幕尺寸 🎪 立即开始准备好体验下一代图床服务了吗？ 在线演示：访问 [Cpicgo - 现代图床](Cpicgo - 现代图床) GitHub 仓库：搜索 “cpicgo” 获取完整源码 部署文档：5 分钟完成从零到生产的部署 R2 图床服务不仅是一个工具，更是你对高效工作流程的投资。加入我们，一起构建更好的图片托管未来！","tags":["serverlsee"],"categories":["建站"]},{"title":"免费域名","path":"/p/5061079.shtml","content":"域名域名是一个网站在互联网上的身份证,是尤其重要的,生活中我们常见的域名由`.cn | .com | .top |`等,这些域名我们称之为`顶级域名`,是很贵的(土豪除外),今天我们将介绍一款`免费的二级域名`,而且可以自己设置`DNS服务商` 介绍EU.ORG是欧盟组织下面的域名，EU代表欧盟 EU.org是由Paul Mockapetris在1996 年 9 月10 日创建的域名，目前个人和组织都是可以免费注册的 维护时间长,稳定 注意在这个域名的审核时间很长,而且国内必须`https`才能访问 步骤第一步第一步肯定要注册账号(这不用想都知道)@传送门 进入到网站,你会看到这样的一个页面 其中只有`Password`和`E-mail`是需要我们认真对待的,其他内容胡乱填写就行,其他信息会显示在`WHOIS`查询上 第二步登录我们的小邮箱,会有以下信息 接下来我们需要如下操作 点击`链接`激活账户 复制`nic-hdl`一会登录要用 登录@传送门 `Handle`就是刚才复制的内容,`密码`是自己设置的 第三步登录都好了,肯定是注册域名啊难不成就看着简陋的页面@传送门 如果是这样的页面就中了,其中`域名`要加`eu.org`且不能太短 第四步这是最最最最最重要的一步`添加NS服务器`,据目前常用DNS提供商,有如下几个提供`二级域名`服务 dnspod(国内用户推荐) cloudflare(赛博菩萨) 只有这些了(其实是博主只测了这些) 添加域名解析这些应该不用介绍了吧,如果你操作顺利,那么应该是这样的 接下来回到域名注册页面,然如下设置(其他DNS提供商一样) 接下来,点击按钮提交即可,等待出现`done`就完成了 如果看完还有不懂得,欢迎`评论区`留言哦~","tags":["建站"],"categories":["免费"]},{"title":"任务二","path":"/p/34fab8c5.shtml","content":"使用STAR（https://github.com/alexdobin/STAR?tab=readme-ov-file）将RNA-seq的reads比对到参考基因组上，比对对象是已经经过过滤后的文件 一、准备（1）安装软件1）二进制安装STAR_2.7.11b.zip 环境变量处理2）conda 安装 conda create -n myenvconda activate myenvconda install -c bioconda star 过程（1）生成索引文件（耗时巨大）STAR \\--runThreadN 12 \\--genomeDir /data1/caoronglin/data/human \\--readFilesIn /data1/caoronglin/data/human/data/GM12878/results/trimmed/ENCFF481BWJ_trimmed.fq.gz \\--outFileNamePrefix /data1/caoronglin/data/human/output/ENCFF481BWJ_ \\--outSAMtype BAM SortedByCoordinate \\--outFilterType BySJout \\--outFilterMultimapNmax 20 \\--alignSJoverhangMin 8 \\--alignSJDBoverhangMin 1 \\--outSAMattrRGline ID:GM12878 SM:GM12878 LB:library1 PU:unit1 PL:ILLUMINA \\--outSAMmapqUnique 60 \\--limitBAMsortRAM 20000000000 \\--readFilesCommand zcat \\--outReadsUnmapped Fastx \\ --quantMode GeneCounts \\ --sjdbOverhang 99 （2）开始比对 STAR \\ --runThreadN 12 \\ --genomeDir /data1/caoronglin/data/human \\ --readFilesIn /data1/caoronglin/data/human/data/GM12878/results/trimmed/ENCFF974EKR_trimmed.fq.gz \\ --outFileNamePrefix /data1/caoronglin/data/human/output/ENCFF974EKR_ \\ --outSAMtype BAM SortedByCoordinate \\ --outFilterType BySJout \\ --outFilterMultimapNmax 20 \\ --alignSJoverhangMin 8 \\ --alignSJDBoverhangMin 1 \\ --outSAMattrRGline ID:GM12878 SM:GM12878 LB:library1 PU:unit1 PL:ILLUMINA \\ --outSAMmapqUnique 60 \\ --limitBAMsortRAM 20000000000 \\ --readFilesCommand zcat \\ --outReadsUnmapped Fastx \\ --quantMode GeneCounts \\ --sjdbOverhang 99 \\ （3） 比对结果ENCFF974EKR_Log.final.out.txt ENCFF824LLV_Log.final.out.txt","tags":["生信"],"categories":["启航计划"]},{"title":"任务一","path":"/p/f7a966c.shtml","content":"任务1:从Ensembl数据库下载最新的人类参考基因组序列（fasta格式）以及对应的注释文件（GFF格式） 任务2:下载人类GM2878的转录组测序数据（GEO:GSE88583） https://www.encodeproject.org/experiments/ENCSR843RJV/ 并进行质量检测（FastQC）和过滤（TrimGalore） 一、准备（1） 所需软件 📎MobaXterm_Installer_v25.2.zip连接服务器使用 fastqc进行质量分析 trim_galore进行过滤 （2）所需资源 1）人类基因组 Homo_sapiens.GRCh38.114.gtf（gtf 解释文件） Homo_sapiens.GRCh38.dna.primary_assembly.fa（人类基因组） 2）GM12828 基因 ENCLB518OAU ENCLB919DEB （2）安装 miniconda1）安装#安装minicondawget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.shbash Miniconda3-latest-Linux-x86_64.sh#配置环境变量echo export PATH=～/miniconda3/bin: $ PATH ～/.bashrcsource ～/.bashrc#验证安装conda --version#创建虚拟环境conda create -n myenvconda activate myenv #激活环境，配置软件包 2）换源echo channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirror.lzu.edu.cn/anaconda/pkgs/main - https://mirror.lzu.edu.cn/anaconda/pkgs/r - https://mirror.lzu.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirror.lzu.edu.cn/anaconda/cloud pytorch: https://mirror.lzu.edu.cn/anaconda/cloud | tee ~/.condarcconda config --set custom_channels.bioconda https://mirror.lzu.edu.cn/anaconda/cloud/#bioconda是常用源，非常重要，大部分软件需要从这里下载 3）利用 conda 安装软件conda create -n myenv python=3.6#创建环境，一定要指定python版本conda activate myenv #激活环境conda install -c bioconda fastqc trim-galore snakemake 二、 编写 snakemake使用 snakemake 工作流，可以简便工作流程，此处不过多解释 Snakemake 的编写规则 （1） 创建 Snakefile 文件（utf-8 编码）# 定义输入输出路径SAMPLES = [ENCFF824LLV, ENCFF974EKR]INPUT_DIR = dataFASTQC_OUTPUT_DIR = results/fastqcTRIMMED_OUTPUT_DIR = results/trimmedconfigfile: config/config.yamlrule all: input: expand(fFASTQC_OUTPUT_DIR/sample_fastqc.html, sample=SAMPLES), expand(fTRIMMED_OUTPUT_DIR/sample_trimmed.fq.gz, sample=SAMPLES), expand(fTRIMMED_OUTPUT_DIR/sample_trimming_report.txt, sample=SAMPLES)rule fastqc_original: input: fINPUT_DIR/sample.fastq.gz output: html=fFASTQC_OUTPUT_DIR/sample_fastqc.html, zip=fFASTQC_OUTPUT_DIR/sample_fastqc.zip shell: mkdir -p FASTQC_OUTPUT_DIR fastqc --outdir FASTQC_OUTPUT_DIR input rule trim_galore: input: fINPUT_DIR/sample.fastq.gz output: trimmed=fTRIMMED_OUTPUT_DIR/sample_trimmed.fq.gz, report=fTRIMMED_OUTPUT_DIR/sample_trimming_report.txt params: adapter=CTGTCTCTTATACACATCT # 根据日志自动检测到的Nextera接头 threads: 4 shell: mkdir -p TRIMMED_OUTPUT_DIR trim_galore \\ --gzip \\ --adapter params.adapter \\ --length 20 \\ --output_dir TRIMMED_OUTPUT_DIR \\ --cores threads \\ input Snakefile 一定要按照格式书写 （2）配置文件trim_galore: cores: 8 # 根据硬件调整核心数name: rnaseq-pipelinechannels: - bioconda - conda-forge - defaultsdependencies: - python=3.10 - fastqc=0.12.1 - trim-galore=0.6.9 - snakemake=8.16.0","tags":["生信"],"categories":["启航计划"]},{"title":"利用Hexo框架搭建静态博客","path":"/p/697f76e7.shtml","content":"前言有很多开源的动态博客框架，我们为什么要用静态博客框架呢？让我们先看看什么是Hexo Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 众所周知，白嫖让我们快乐，利用Hexo搭建的博客可以解锁更多的白嫖技巧（后续文章更新） 初始化博客安装node.jswindows安装 前往node.js官网下载（推荐下载LTS版本） 按照安装提示进行安装（一定要选“添加到环境变量ADD TO PATH”，这样会给后期减少很多麻烦） 安装Git Linux安装安装源里面的node版本（简便方法） debianununtu(需要管理员权限) apt install nodejsapt install npmapt-get install git-corenpm config set registry http://registry.npm.taobao.org/（这一步将NPM源切换为国内淘宝源，可以不做） centos yum install nodejsyun install npmyum install git-corenpm config set registry http://registry.npm.taobao.org/ 利用宝塔面板安装 安装node管理器 选择任意一个版本（建议选一个长期支持版本，宝塔面板安装不好处理），可以使用span class=ne-textnpx hexo使用/span这样的安装方式需要自己添加环境变量 增加环境变量（需要管理员权限—Linux）echo PATH=$PATH:./node_modules/.bin ~/.profile docker安装期待后续更新 安装hexo（推荐使用淘宝源）npm install -g hexo-cli 这样，前期环境搭建就完成了 初始化博客根目录//选定一个你要存放博客的目录，在你选定的目录打开终端（windows用户请复制相对路径，在cmd里cd+进入目录）hexo init 博客目录名 //hexo init myblogcd 博客目录名 //cd myblognpm install / cnpm installhexo s //（在线预览博客，需要放行4000端口）or hexo s -p+端口号 好了，就这样一个静态博客就初始化好了（可以通过http://localhost:4000/127.0.0.1:4000访问） 这是成功后的目录结构，期中_config.yml是前期用的比较多的 对于动态博客看起来会比较麻烦，但后期的备份，白嫖。迁移都有很大的优势。 选择主题爱美之心人皆有之，谁不会想要一个好看的博客主题呢？本文推荐使用博主同款主题butterfly 什么是主题butterfly 获取主题（以下均在刚刚创建的博客根目录进行（myblog））通过git获取（需要提前配置好git）git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 对于没有梯子的，可以采用本站提供的镜像github（任选一个使用） git clone -b master https://git.ypmsk.tk/jerryc127/hexo-theme-butterfly.git themes/butterflygit clone -b master https://git.ypmsk.top/jerryc127/hexo-theme-butterfly.git themes/butterfly 通过npm获取npm i hexo-theme-butterfly 需要手动将node_modules下的hexo-theme-butterfly复制到themes目录下 修改博客主配置,让主题生效# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: butterfly 为博客添加身份（修改基础信息）# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: starsblog //博客题目subtitle: 博客副标题description: keywords: 分享，技术，教程 //自己博客的关键字author: 作者language: zh-CNtimezone: //时区，默认不管它就行# URL## Set your site url here. For example, if you use GitHub Page, set url as https://username.github.io/projecturl: https://www.cnortles.top //博客地址（和版权信息，以及分享有关）permalink: posts/:abbrlink/ //（此处配置为安装了插件）abbrlink: alg: crc32 rep: hexpermalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing index.html from permalinks trailing_html: true # Set to false to remove trailing .html from permalinks 基础信息配置完以后，让我们一键三连 hexo clean // npx hexo cleanhexo g // npx hexo ghexo s //npx hexo s 通过localhost:4000预览博客（关于端口修改上文已提及） 主题更新方法为了方便主题更新，请将主题目录下的_config.yml（原文件不要删除！！！）复制到博客根目录下并改为_config.butterfly.yml 在hexo5.0以上，会自动合并两个配置，默认读取“_config.butterfly.yml”后续关于主题的魔改也会在这里修改 番外番外1：利用语雀写文章本站已有小白版教程（非自动版） 结尾 介绍安装Nodejs 安装hexo docker安装 选择主题 一键三连 简化后续主题更新 如何写作 主题魔改 白嫖进行时 安装插件 番外1：利用语雀写文章（非自动版） 番外2：利用qexo写文章","tags":["hexo"],"categories":["建站"]},{"path":"/go.html","content":"😃页面加载中，请稍候... :root { --card-radius: 22px; --btn-radius: 14px; --shadow: 0 16px 40px rgba(0, 0, 0, 0.12); --shadow-hover: 0 22px 50px rgba(0, 0, 0, 0.18); } body { overflow: hidden; height: 100vh; width: 100vw; margin: 0; padding: 0; font-family: \"HarmonyOS Sans\", \"HarmonyOS Sans SC\", -apple-system, system-ui, \"Microsoft Yahei\", Arial, sans-serif; letter-spacing: 0.2px; } .container { display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; margin: 0; flex-direction: column; gap: 10px; } .avatar-placeholder, .avatar { width: 90px; height: 90px; border-radius: 50%; margin-bottom: 6px; display: block; box-shadow: 0 12px 28px rgba(0, 0, 0, 0.18); } .avatar { display: none; } .description { font-size: 20px; font-weight: 700; } .subtitle { font-size: 14px; margin-bottom: 16px; } .loading { text-align: center; padding: 28px 30px; border-radius: var(--card-radius); animation: fadein 0.6s ease; width: 480px; max-width: 88%; transition: all 0.3s ease-in-out; backdrop-filter: blur(16px); } .loading:hover { transform: translateY(-2px); } @keyframes fadein { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } } .content { margin-bottom: 16px; } .url-text { margin-bottom: 10px; font-size: 15px; letter-spacing: 0.6px; } .jump-url { position: relative; font-size: 15px; display: flex; align-items: center; gap: 10px; margin-top: 6px; margin-bottom: 18px; padding: 12px 14px; border-radius: 16px; min-height: 44px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } #jump-url-text { flex: 1; overflow: hidden; text-overflow: ellipsis; } .copy-btn-container { display: flex; align-items: center; } .copy-btn { width: 38px; height: 38px; border-radius: 12px; border: 1px solid transparent; cursor: pointer; transition: all 0.3s ease-in-out; display: grid; place-items: center; } .copy-btn-container svg { width: 18px; height: 18px; fill: currentColor; } .countdown-text { margin-top: 8px; font-size: 12px; } .button-container { display: flex; justify-content: center; gap: 14px; margin-top: 18px; flex-wrap: wrap; } .button { padding: 10px 16px; border-radius: var(--btn-radius); border: none; cursor: pointer; font-size: 15px; min-width: 120px; height: 40px; font-weight: 600; transition: all 0.2s ease; } .button:hover { transform: translateY(-1px); } .progress-bar { width: 100%; border-radius: 999px; overflow: hidden; height: 8px; margin-top: 16px; } .progress { width: 100%; height: 100%; transition: width 1s; } const host = window.location.host; function GetQueryString(name) { var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); return r ? decodeURI(r[2]) : null; } function decodeSafeUrlParam(paramStr) { const base64 = paramStr.replace(/-/g, '+').replace(/_/g, '/'); const decoded = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join('')); return decoded; } let countdown = ; let jump_url = GetQueryString(''); const UrlReg = '^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)'; if (!jump_url || !jump_url.match(UrlReg)) { document.title = '参数错误，正在返回首页...'; jump_url = location.origin; } let progressElement; let countdownElement; let countdownTextElement; let jumpUrlElement; function updateCountdown() { if (countdown < 0) { countdownTextElement.textContent = \"💡自行点击跳转，请注意您的账号和财产安全\"; return; } countdownElement.textContent = countdown; progressElement.style.width = (countdown / * 100) + '%'; if (countdown === 0) { jump(); } else { countdown--; setTimeout(updateCountdown, 1000); } } function jump() { location.href = jump_url; } function closeWindow() { function isWeChat() { return /MicroMessenger/i.test(navigator.userAgent); } function isQQ() { return /QQ/i.test(navigator.userAgent) && !/MicroMessenger/i.test(navigator.userAgent); } if (isWeChat()) { if (typeof WeixinJSBridge !== \"undefined\") { WeixinJSBridge.call('closeWindow'); } else { document.addEventListener('WeixinJSBridgeReady', function() { WeixinJSBridge.call('closeWindow'); }, false); } } else if (isQQ()) { if (typeof mqq !== \"undefined\" && mqq.ui && mqq.ui.closeWebView) { mqq.ui.closeWebView(); } else { window.history.back(); } } else { window.opener = null; window.open('', '_self'); window.close(); } } function copyToClipboard() { const urlText = document.getElementById('jump-url-text').textContent; const tempInput = document.createElement('input'); tempInput.value = urlText; document.body.appendChild(tempInput); tempInput.select(); document.execCommand('copy'); document.body.removeChild(tempInput); alert('链接已复制到剪贴板！'); } async function loadAvatar() { const avatarImg = document.querySelector('.avatar'); const placeholder = document.querySelector('.avatar-placeholder'); const img = new Image(); img.src = ''; img.onload = function() { avatarImg.src = img.src; avatarImg.style.display = 'block'; placeholder.style.display = 'none'; }; } window.addEventListener('load', function() { loadAvatar(); progressElement = document.getElementById('progress'); countdownElement = document.getElementById('countdown'); countdownTextElement = document.querySelector('.countdown-text'); jumpUrlElement = document.getElementById('jump-url-text'); jumpUrlElement.textContent = jump_url; updateCountdown(); }); 您即将离开本站，跳转到： ⚡将在秒后跳转，请自行确认链接安全性 取消跳转 立即跳转"},{"title":"关于","path":"/about/index.html","content":"RongLinCao 这是个人简介"},{"title":"好物推荐","path":"/equipment/index.html","content":""},{"title":"我的朋友圈","path":"/friends/index.html","content":""},{"title":"我的朋友们","path":"/links/index.html","content":"好朋友们 (ฅ•̀∀•́ฅ) loadQexoFriends(\"friend-content\", \"https://qexo.cnortles.top\") 申请友链 (•̀ᴗ•́)و✧"},{"path":"/notes/index.html","content":"学习笔记这里是各类学习笔记的汇总页面。"},{"title":"文章统计","path":"/charts/index.html","content":"文章统计本站文章发布时间、标签、分类的可视化统计。 文章发布统计图 标签统计图 分类统计图"},{"title":"订阅本站","path":"/subscribe/index.html","content":"订阅本站首先，对每一位来到这里的朋友说声”有幸遇见，很高兴认识你”👋 创立这个博客的初衷是想要有一个能够积累知识、积累兴趣的地方。和他人分享，会让这些成为积累和沉淀。如果能够帮助到更多的人，那一定是非常棒的事情。 订阅方式 推送全部文章推送简介 RSS 推荐订阅方式 推送全部文章更新推送简介 邮件订阅 推荐订阅方式 订阅本站文章更新 确认订阅 关于订阅本博客主要分享生物学、生物信息学、编程开发等内容。通过订阅，您可以： 第一时间获取最新文章更新 系统学习相关技术知识 了解我的学习笔记和经验总结 选择适合您的订阅方式，感谢您的关注！"},{"title":"说说","path":"/talks/index.html","content":"showQexoTalks(\"qexot\", \"https://qexo.cnortles.top\", 5)"},{"title":"任务一","path":"/notes/bio/bio1.html","content":"任务1:从Ensembl数据库下载最新的人类参考基因组序列（fasta格式）以及对应的注释文件（GFF格式） 任务2:下载人类GM2878的转录组测序数据（GEO:GSE88583） https://www.encodeproject.org/experiments/ENCSR843RJV/ 并进行质量检测（FastQC）和过滤（TrimGalore） 一、准备（1） 所需软件 📎MobaXterm_Installer_v25.2.zip连接服务器使用 fastqc进行质量分析 trim_galore进行过滤 （2）所需资源 1）人类基因组 Homo_sapiens.GRCh38.114.gtf（gtf 解释文件） Homo_sapiens.GRCh38.dna.primary_assembly.fa（人类基因组） 2）GM12828 基因 ENCLB518OAU ENCLB919DEB （2）安装 miniconda1）安装#安装minicondawget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.shbash Miniconda3-latest-Linux-x86_64.sh#配置环境变量echo export PATH=～/miniconda3/bin: $ PATH ～/.bashrcsource ～/.bashrc#验证安装conda --version#创建虚拟环境conda create -n myenvconda activate myenv #激活环境，配置软件包 2）换源echo channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirror.lzu.edu.cn/anaconda/pkgs/main - https://mirror.lzu.edu.cn/anaconda/pkgs/r - https://mirror.lzu.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirror.lzu.edu.cn/anaconda/cloud pytorch: https://mirror.lzu.edu.cn/anaconda/cloud | tee ~/.condarcconda config --set custom_channels.bioconda https://mirror.lzu.edu.cn/anaconda/cloud/#bioconda是常用源，非常重要，大部分软件需要从这里下载 3）利用 conda 安装软件conda create -n myenv python=3.6#创建环境，一定要指定python版本conda activate myenv #激活环境conda install -c bioconda fastqc trim-galore snakemake 二、 编写 snakemake使用 snakemake 工作流，可以简便工作流程，此处不过多解释 Snakemake 的编写规则 （1） 创建 Snakefile 文件（utf-8 编码）# 定义输入输出路径SAMPLES = [ENCFF824LLV, ENCFF974EKR]INPUT_DIR = dataFASTQC_OUTPUT_DIR = results/fastqcTRIMMED_OUTPUT_DIR = results/trimmedconfigfile: config/config.yamlrule all: input: expand(fFASTQC_OUTPUT_DIR/sample_fastqc.html, sample=SAMPLES), expand(fTRIMMED_OUTPUT_DIR/sample_trimmed.fq.gz, sample=SAMPLES), expand(fTRIMMED_OUTPUT_DIR/sample_trimming_report.txt, sample=SAMPLES)rule fastqc_original: input: fINPUT_DIR/sample.fastq.gz output: html=fFASTQC_OUTPUT_DIR/sample_fastqc.html, zip=fFASTQC_OUTPUT_DIR/sample_fastqc.zip shell: mkdir -p FASTQC_OUTPUT_DIR fastqc --outdir FASTQC_OUTPUT_DIR input rule trim_galore: input: fINPUT_DIR/sample.fastq.gz output: trimmed=fTRIMMED_OUTPUT_DIR/sample_trimmed.fq.gz, report=fTRIMMED_OUTPUT_DIR/sample_trimming_report.txt params: adapter=CTGTCTCTTATACACATCT # 根据日志自动检测到的Nextera接头 threads: 4 shell: mkdir -p TRIMMED_OUTPUT_DIR trim_galore \\ --gzip \\ --adapter params.adapter \\ --length 20 \\ --output_dir TRIMMED_OUTPUT_DIR \\ --cores threads \\ input Snakefile 一定要按照格式书写 （2）配置文件trim_galore: cores: 8 # 根据硬件调整核心数name: rnaseq-pipelinechannels: - bioconda - conda-forge - defaultsdependencies: - python=3.10 - fastqc=0.12.1 - trim-galore=0.6.9 - snakemake=8.16.0","tags":[null],"categories":[null]},{"title":"任务二","path":"/notes/bio/bio2.html","content":"使用STAR（https://github.com/alexdobin/STAR?tab=readme-ov-file）将RNA-seq的reads比对到参考基因组上，比对对象是已经经过过滤后的文件 一、准备（1）安装软件1）二进制安装STAR_2.7.11b.zip 环境变量处理2）conda 安装 conda create -n myenvconda activate myenvconda install -c bioconda star 过程（1）生成索引文件（耗时巨大）STAR \\--runThreadN 12 \\--genomeDir /data1/caoronglin/data/human \\--readFilesIn /data1/caoronglin/data/human/data/GM12878/results/trimmed/ENCFF481BWJ_trimmed.fq.gz \\--outFileNamePrefix /data1/caoronglin/data/human/output/ENCFF481BWJ_ \\--outSAMtype BAM SortedByCoordinate \\--outFilterType BySJout \\--outFilterMultimapNmax 20 \\--alignSJoverhangMin 8 \\--alignSJDBoverhangMin 1 \\--outSAMattrRGline ID:GM12878 SM:GM12878 LB:library1 PU:unit1 PL:ILLUMINA \\--outSAMmapqUnique 60 \\--limitBAMsortRAM 20000000000 \\--readFilesCommand zcat \\--outReadsUnmapped Fastx \\ --quantMode GeneCounts \\ --sjdbOverhang 99 （2）开始比对 STAR \\ --runThreadN 12 \\ --genomeDir /data1/caoronglin/data/human \\ --readFilesIn /data1/caoronglin/data/human/data/GM12878/results/trimmed/ENCFF974EKR_trimmed.fq.gz \\ --outFileNamePrefix /data1/caoronglin/data/human/output/ENCFF974EKR_ \\ --outSAMtype BAM SortedByCoordinate \\ --outFilterType BySJout \\ --outFilterMultimapNmax 20 \\ --alignSJoverhangMin 8 \\ --alignSJDBoverhangMin 1 \\ --outSAMattrRGline ID:GM12878 SM:GM12878 LB:library1 PU:unit1 PL:ILLUMINA \\ --outSAMmapqUnique 60 \\ --limitBAMsortRAM 20000000000 \\ --readFilesCommand zcat \\ --outReadsUnmapped Fastx \\ --quantMode GeneCounts \\ --sjdbOverhang 99 \\ （3） 比对结果ENCFF974EKR_Log.final.out.txt ENCFF824LLV_Log.final.out.txt","tags":[null],"categories":[null]},{"title":"第零章、计算机概论","path":"/notes/linux/ch00-computer-basics.html","content":"第零章、计算机概论本章内容概要本章介绍计算机的基础知识，为学习 Linux 打下基础。 0.1 电脑：辅助人脑的好工具电脑硬件的五大单元 输入单元：键盘、鼠标、扫描仪等 输出单元：屏幕、打印机等 控制单元：协调各组件工作 算术逻辑单元 (ALU)：负责数学运算和逻辑判断 内存：临时存储数据 CPU 的架构 精简指令集 (RISC)：ARM、SPARC 复杂指令集 (CISC)：x86、x86_64 0.2 个人电脑架构与相关设备元件主板 芯片组：南桥、北桥 CMOS：记录主板参数 BIOS：开机时执行的程序 存储设备 硬盘：HDD、SSD 光驱：CD、DVD、Blu-ray USB 设备：U盘、移动硬盘 显卡 集成显卡：整合在 CPU 中 独立显卡：NVIDIA、AMD 0.3 数据表示方式数字系统 二进制 (Binary)：0 和 1 八进制 (Octal)：0-7 十进制 (Decimal)：0-9 十六进制 (Hexadecimal)：0-9, A-F 单位换算 单位 说明 bit 最小单位，0 或 1 Byte 1 Byte 8 bits KB 1 KB 1024 Bytes MB 1 MB 1024 KB GB 1 GB 1024 MB TB 1 TB 1024 GB 0.4 软件程序运行机器程序 机器码：CPU 可直接执行的二进制代码 编译程序 编译器：将高级语言转换为机器码 GCC、Clang 操作系统 核心功能： 系统调用接口 程序管理 内存管理 文件系统管理 设备驱动 0.5 重点回顾 电脑由硬件五大单元组成：输入、输出、CPU（控制单元+算术逻辑单元）、内存 CPU 有 RISC 和 CISC 两种架构 数据以二进制存储，单位有 bit、Byte、KB、MB 等 操作系统管理硬件资源，提供系统调用接口 0.6 本章习题 请说明电脑硬件的五大单元是什么？ 请解释 CPU 的 RISC 和 CISC 架构的区别？ 1GB 等于多少 Bytes？ 0.7 参考资料与延伸阅读 鸟哥的 Linux 私房菜 维基百科 - 计算机硬件","tags":[null,null,null]},{"title":"第一章、Linux是什么与如何学习","path":"/notes/linux/ch01-linux-intro.html","content":"第一章、Linux是什么与如何学习1.1 Linux是什么Linux的定义Linux 是一个开源的类 Unix 操作系统内核，由林纳斯·托瓦兹（Linus Torvalds）于 1991 年首次发布。 Linux系统的组成 组件 说明 Linux内核 操作系统的核心，负责硬件管理 Shell 命令行解释器，用户与系统的接口 文件系统 组织和管理文件的机制 应用程序 各种工具软件（如文本编辑器、编译器等） Linux发行版由于 Linux 内核是开源的，不同的组织和个人可以基于内核开发出自己的发行版（Distribution）。 常见发行版： 发行版 特点 Ubuntu 用户友好，适合初学者 CentOSRHEL 企业级稳定，服务器首选 Debian 稳定可靠，社区驱动 Fedora 新技术试验场，RedHat上游 Arch Linux 滚动更新，高度可定制 openSUSE 德国品质，YaST配置工具 Linux的应用领域 服务器领域（最大市场） Web服务器（Apache、Nginx） 数据库服务器（MySQL、PostgreSQL） 邮件服务器、DNS服务器等 嵌入式系统 智能手机（Android基于Linux） 路由器、智能家居设备 汽车电子系统 云计算与大数据 OpenStack、Kubernetes Hadoop、Spark大数据平台 桌面应用 开发者工作站 科学计算、图形设计 超级计算机 全球 Top500 超算几乎全用 Linux Linux的优势 开源免费：源代码公开，无授权费用 安全稳定：权限管理严格，病毒少 高效性能：资源占用低，运行效率高 高度可定制：从内核到界面都可定制 强大的命令行：自动化、批处理能力强 丰富的软件生态：包管理器一键安装软件 活跃的社区：遇到问题容易找到解决方案 1.2 Torvalds的Linux发展起源 1991年：芬兰大学生 Linus Torvalds 在学习 Minix 系统时，决定开发自己的操作系统内核 1991年8月25日：Linus 在 comp.os.minix 新闻组发布了著名的帖子，宣布 Linux 的诞生 发展历程 时间 事件 1991 Linux 0.01 发布，仅约 10,000 行代码 1992 Linux 采用 GPL 许可证，正式开源 1993 Slackware、Debian 发行版诞生 1994 Linux 1.0 发布 1995 Red Hat 成立 1998 IBM、Oracle 等大公司开始支持 Linux 2001 Linux 2.4 内核发布 2003 Linux 2.6 内核发布 2007 Android 系统发布（基于 Linux） 2011 Linux 3.0 发布 2015 Linux 4.0 发布 2019 Linux 5.0 发布 2022 Linux 6.0 发布 开源协作模式Linux 的成功得益于开源协作模式： 全球开发者贡献：数千名开发者参与代码贡献 层次化维护： Linus Torvalds：最终决策者 维护者：负责各个子系统 贡献者：提交代码补丁 邮件列表沟通：主要的技术讨论方式 版本控制系统：Git（由 Linus 亲自开发） Linux 基金会 2000年成立，原名 Open Source Development Labs (OSDL) 2007年与 Free Standards Group 合并，更名为 Linux Foundation 职能： 资助 Linus Torvalds 等核心开发者 组织 Linux 相关会议（如 LinuxCon） 推广 Linux 和开源技术 托管开源项目（如 Kubernetes、Node.js 等） 1.3 Linux当前应用的角色企业服务器市场Linux 在服务器市场占据主导地位： Web服务器 超过 70% 的网站使用 Linux 服务器 Apache、Nginx 等主流 Web 服务器原生支持 Linux 数据库服务器 MySQL、PostgreSQL、MongoDB 等数据库首选 Linux 平台 高性能、稳定可靠 云计算平台 Amazon AWS、Google Cloud、Microsoft Azure 都基于 Linux OpenStack、Kubernetes 等云原生技术源于 Linux 移动设备与嵌入式Android系统 全球超过 70% 的智能手机使用 Android Android 基于 Linux 内核 物联网设备 智能路由器、智能家居设备 工业控制系统、医疗设备 汽车电子系统（如 Tesla） 桌面应用虽然 Linux 桌面市场份额较小，但在特定领域表现出色： 开发者工作站 软件开发者首选（尤其是 Web 开发、数据科学） 与服务器环境一致，便于开发部署 科学计算与工程 高性能计算（HPC） 3D 渲染、动画制作（好莱坞大片制作） 金融建模、基因分析 教育与政府 学校计算机教室 政府部门（节省软件授权费用） 超级计算机Linux 在超级计算机领域绝对垄断： 全球 Top500 超级计算机中，超过 99% 运行 Linux 原因： 开源，可深度定制优化 高性能、低延迟 支持并行计算 社区活跃，技术先进 技术发展趋势容器化与微服务 Docker、Kubernetes 成为行业标准 云原生应用开发模式 DevOps与自动化 CICD 流水线 基础设施即代码 (IaC) 人工智能与大数据 TensorFlow、PyTorch 等 AI 框架首选 Linux Hadoop、Spark 大数据平台 边缘计算 5G 网络推动边缘计算发展 Linux 在边缘设备中的重要性增加 1.4 Linux 该如何学习学习前的准备心态准备 耐心：Linux 学习曲线较陡，需要持续投入 实践：多动手操作，不要只看不动手 思考：理解原理，不只是记忆命令 坚持：遇到困难不放弃，逐步积累 环境准备 安装 Linux 系统 物理机安装（推荐，体验最佳） 虚拟机（VMware、VirtualBox） 双系统（Windows + Linux） WSL（Windows Subsystem for Linux） 推荐的入门发行版 Ubuntu：用户友好，社区活跃，文档丰富 Linux Mint：类似 Windows 界面，易上手 Fedora：新技术前沿，适合开发者 CentOS Stream：企业级，服务器方向 学习方法第一阶段：基础入门（1-2个月） 熟悉 Linux 环境 文件系统结构 基本命令操作（ls, cd, pwd, mkdir, rm, cp, mv 等） 文件权限管理 用户和组管理 掌握文本处理 使用文本编辑器（vim 或 nano） 文本查看命令（cat, less, more, head, tail） 文本处理命令（grep, sed, awk） 软件包管理 aptyumdnf 包管理器使用 软件安装、卸载、更新 第二阶段：系统管理（2-3个月） 系统管理 进程管理 服务管理（systemd） 网络配置 磁盘管理 Shell 脚本编程 Bash 基础语法 流程控制（if、for、while） 函数编写 实用脚本案例 系统安全 防火墙配置 SELinux 权限管理 日志分析 第三阶段：进阶应用（持续学习） 网络服务 Web 服务器（Apache、Nginx） 数据库（MySQL、PostgreSQL） DNS 服务器 邮件服务器 FTP 服务器 虚拟化与容器 VMware、KVM Docker 容器技术 Kubernetes 容器编排 云计算 OpenStack AWSAzure阿里云 云原生技术 自动化运维 Ansible Puppet、Chef CICD 流水线 学习资源推荐在线文档 鸟哥的 Linux 私房菜 - 最经典的 Linux 教程 Linux 中国 - 中文 Linux 社区 Arch Wiki - 详细的 Linux 技术文档 在线学习平台 Linux Foundation - Linux 官方基金会 Coursera - Linux 相关课程 Udemy - Linux 实战课程 书籍推荐 入门 《鸟哥的 Linux 私房菜 基础学习篇》- 必读经典 《Linux 命令行与 Shell 脚本编程大全》 《UnixLinux 编程实践教程》 进阶 《深入理解 Linux 内核》 《Linux 设备驱动程序》 《Unix 环境高级编程》 实践项目 Linux Journey - 交互式学习 OverTheWire: Bandit - 通过游戏学习 Linux 命令 Vim Adventures - 学习 Vim 编辑器 实践建议 每天使用 Linux 将 Linux 作为主力系统使用 遇到问题先尝试自己解决 记录学习笔记 整理常用命令 记录问题解决方案 写技术博客分享 参与社区 加入 Linux 用户组 参与开源项目 在技术论坛回答问题 动手实验 搭建实验环境 尝试配置各种服务 模拟故障并解决 持续学习 关注 Linux 新技术 学习相关技术（网络、安全、云计算） 考取认证（如 RHCE、LFCS） 1.5 重点回顾 Linux 是一个开源的类 Unix 操作系统内核 Linux 发行版是基于 Linux 内核的完整操作系统 学习 Linux 需要耐心、实践和坚持 推荐从 Ubuntu 或 CentOS 开始入门 遵循循序渐进的学习路径：基础 → 系统管理 → 进阶应用 1.6 本章习题 什么是 Linux？Linux 与 Linux 发行版有什么区别？ 列举至少 5 个常见的 Linux 发行版及其特点。 你打算如何学习 Linux？制定一个学习计划。 在你的电脑上安装一个 Linux 发行版（虚拟机或双系统）。 1.7 参考资料与延伸阅读 Linux 内核官方网站 GNU 项目 Linux 基金会 DistroWatch - Linux 发行版排行","tags":[null,null,null]},{"title":"第二章、主机规划与磁盘分区","path":"/notes/linux/ch02-partition.html","content":"第二章、主机规划与磁盘分区2.1 Linux与硬件的搭配认识计算机硬件在开始学习Linux之前，我们需要了解计算机的基本硬件组成。 主要硬件组件： 组件 功能 Linux中的设备名 CPU 中央处理器，执行指令 proccpuinfo 内存 (RAM) 临时存储运行中的程序和数据 procmeminfo 硬盘 永久存储数据 devsda, devnvme0n1 主板 连接所有组件 - 显卡 图形处理 devfb0 网卡 网络连接 deveth0, devwlan0 电源 供电 - 查看硬件信息# 查看CPU信息cat /proc/cpuinfolscpu# 查看内存信息cat /proc/meminfofree -hlsmem# 查看硬盘信息lsblkfdisk -lparted -lls -l /dev/sd* /dev/nvme*# 查看PCI设备lspcilspci | grep -i vga # 显卡lspci | grep -i net # 网卡# 查看USB设备lsusb# 查看硬件详细信息dmidecodedmidecode -t memory # 内存dmidecode -t processor # CPU# 查看系统信息uname -ahostnamectl 2.2 磁盘分区为什么要分区磁盘分区的主要目的： 安全性：系统和个人数据分开，重装系统不影响数据 便利性：不同类型数据分类存放 效率：按需分配空间，避免浪费 性能：将频繁访问的数据放在磁盘快速区域 分区表类型MBR (Master Boot Record) 特性 说明 最大磁盘容量 2TB 最大主分区数 4个 扩展分区 1个（占用主分区名额） 逻辑分区 扩展分区内可创建多个 分区信息存储 主引导扇区（512字节） GPT (GUID Partition Table) 特性 说明 最大磁盘容量 18EB（实际受限于操作系统） 最大分区数 128个（Windows默认） 主分区扩展分区 没有这种限制，都是主分区 分区信息存储 磁盘头部和尾部（备份） 兼容性 UEFI启动模式 Linux分区命名规则 设备类型 命名规则 示例 SATASCSI硬盘 devsd[a-z] devsda, devsdb NVMe SSD devnvme[0-9]n[1-9] devnvme0n1 虚拟设备 devvd[a-z] devvda (虚拟机) 分区 设备名+数字 devsda1, devnvme0n1p1 光驱 devsr0 或 devcdrom devsr0 常用分区工具fdisk (MBR分区)# 查看分区表fdisk -lfdisk -l /dev/sda# 编辑分区表fdisk /dev/sda# fdisk交互命令：# m - 显示帮助# p - 显示分区表# n - 新建分区# d - 删除分区# t - 修改分区类型# a - 设置可启动标志# w - 写入并退出# q - 不保存退出 gdisk cgdisk (GPT分区)# GPT分区工具gdisk /dev/sdagdisk交互命令（类似fdisk）：# ? - 帮助# p - 显示分区表# n - 新建分区# d - 删除分区# t - 修改分区类型# c - 修改分区名# x - 专家命令# w - 写入并退出# q - 退出 parted (MBR和GPT都支持)# 查看分区表parted -lparted /dev/sda print# 交互式编辑parted /dev/sda# 非交互式命令parted /dev/sda mklabel gpt # 创建GPT分区表parted /dev/sda mkpart primary ext4 1MiB 100GiBparted /dev/sda mkpart primary linux-swap 100GiB 104GiBparted /dev/sda resizepart 1 200GiBparted /dev/sda rm 2parted /dev/sda set 1 boot on lsblk blkid# 查看块设备信息lsblklsblk -f # 显示文件系统lsblk -o NAME,SIZE,TYPE,MOUNTPOINT,MODEL# 查看UUID和文件系统类型blkidblkid /dev/sda1 文件系统类型 文件系统 特点 适用场景 ext4 稳定、性能好、广泛使用 Linux系统分区、数据分区 xfs 高性能、大容量、扩展性好 大数据、日志系统 btrfs 现代、快照、压缩、多设备 桌面、开发环境 swap 交换分区 内存扩展 vfatfat32 兼容性好 UEFI启动分区、可移动设备 ntfs Windows兼容 双系统数据共享 创建文件系统# 创建ext4文件系统mkfs.ext4 /dev/sda1mkfs.ext4 -L Data /dev/sda2 # 带标签# 创建xfs文件系统mkfs.xfs /dev/sdb1# 创建vfat（FAT32）文件系统mkfs.vfat -F 32 /dev/sdc1# 创建swapmkswap /dev/sda3swapon /dev/sda3 # 启用swapswapoff /dev/sda3 # 关闭swap# 查看文件系统信息dumpe2fs /dev/sda1 # ext2/3/4tune2fs -l /dev/sda1 # 查看/修改参数xfs_info /dev/sdb1 # xfs 挂载文件系统# 手动挂载mount /dev/sda1 /mnt/datamount -t ext4 /dev/sda1 /mnt/datamount -o rw,noatime /dev/sda1 /mnt/data# 常用挂载选项-o ro # 只读-o rw # 读写-o noatime # 不更新访问时间-o nodiratime # 不更新目录访问时间-o sync # 同步写入-o async # 异步写入-o remount # 重新挂载-o bind # 绑定挂载# 查看挂载mountcat /proc/mountsdf -hdf -hT # 显示文件系统类型lsblk -f# 卸载umount /mnt/dataumount /dev/sda1umount -l /mnt/data # 强制卸载（懒卸载）# 开机自动挂载 - 编辑 /etc/fstabcat /etc/fstab# 格式：设备 挂载点 文件系统 选项 dump pass# 示例：# UUID=xxx /home ext4 defaults,noatime 0 2# /dev/sda1 /mnt/data ext4 defaults 0 0# 测试fstab配置（不实际挂载）mount -a --dry-run# 检查fstab是否有错误findmnt --verify 2.3 安装Linux前的规划分区方案建议基础方案（新手推荐） 分区 大小 文件系统 说明 boot 1GB ext4 启动分区，UEFI需要EFI分区 50GB+ ext4 根分区，系统和软件 home 剩余空间 ext4 用户数据 swap 4-8GB swap 交换分区，或使用swap文件 高级方案 分区 大小 文件系统 说明 bootefi 512MB vfat UEFI启动分区 boot 1GB ext4 传统启动文件 30GB ext4xfs 根分区 var 20GB+ ext4xfs 日志和缓存 varlog 10GB+ ext4 日志文件 home 剩余空间 ext4xfs 用户数据 opt 视需要 ext4 第三方软件 tmp 10GB+ ext4 临时文件，或使用tmpfs swap 4-16GB swap 根据内存大小决定 swap大小建议 内存大小 推荐swap大小 说明 4GB 2-4GB 内存小，需要较大swap 4-8GB 2-4GB 正常使用 8-16GB 2-4GB 或根据需要调整 16-32GB 4-8GB 或使用swap文件 32GB 4GB或禁用 根据使用情况决定 swap文件替代分区： # 创建swap文件sudo dd if=/dev/zero of=/swapfile bs=1M count=4096sudo chmod 600 /swapfilesudo mkswap /swapfilesudo swapon /swapfile# 添加到fstabecho /swapfile none swap sw 0 0 | sudo tee -a /etc/fstab 系统要求CentOS 7 最低要求 项目 要求 CPU 1 GHz 或更高 内存 1 GB (建议 2 GB+) 硬盘 20 GB 可用空间 网络 以太网或无线网卡 CentOS 7 推荐配置 项目 推荐 CPU 2核或以上 内存 4 GB 或更多 硬盘 50 GB SSD 或更大 网络 千兆以太网 2.4 重点回顾 硬件认知：了解CPU、内存、硬盘等关键硬件及其Linux设备名 分区必要性：安全性、便利性、效率、性能 分区表类型： MBR：最大2TB，4个主分区 GPT：最大18EB，128个分区，需要UEFI 分区命名：devsda1（SATA）、devnvme0n1p1（NVMe） 分区工具：fdisk（MBR）、gdisk（GPT）、parted（两者） 文件系统：ext4（通用）、xfs（大容量）、swap（交换） 分区方案：建议至少、home、swap三个分区 swap大小：根据内存大小，一般2-4GB或更大 挂载点：分区必须挂载到目录树才能使用 fstab：etcfstab配置开机自动挂载 2.5 本章习题 解释MBR和GPT分区表的主要区别。你的电脑使用哪种分区表？ Linux中SATA硬盘和NVMe SSD的设备名分别是什么格式？ 为什么要进行磁盘分区？至少列出3个理由。 使用fdisk或parted查看你当前系统的分区表，并解释每个分区的作用。 为一个8GB内存、500GB硬盘的服务器设计分区方案，要求有、home、var、swap分区。 解释swap分区的作用。如果系统有16GB内存，你建议swap设置多大？ 如何在Linux中查看硬盘UUID？UUID在fstab中有什么作用？ 实践：使用fdisk或gdisk创建一个测试分区，然后格式化为ext4并挂载到mnttest。 2.6 参考资料与延伸阅读 man fdisk man gdisk man parted man mkfs.ext4 man mount man fstab 鸟哥的Linux私房菜 - 主机规划与磁盘分区","tags":[null,null,null]},{"title":"第三章、安装 CentOS 7.x","path":"/notes/linux/ch03-install.html","content":"第三章、安装 CentOS 7.x3.1 本练习机的规划–尤其是分区参数安装前的准备工作在开始安装 CentOS 7 之前，需要规划好以下内容： 硬件要求检查： CPU：64位处理器 内存：至少 1GB（推荐 2GB 以上） 硬盘：至少 20GB 可用空间 网络：以太网或无线网卡 下载 CentOS 7： # 官方下载地址https://www.centos.org/download/# 常用镜像站https://mirrors.aliyun.com/centos/7/isos/x86_64/https://mirrors.tuna.tsinghua.edu.cn/centos/7/isos/x86_64/# 推荐的 ISO 文件CentOS-7-x86_64-DVD-2009.iso # 完整版（约 4GB）CentOS-7-x86_64-Minimal-2009.iso # 最小化安装（约 900MB） 分区规划示例方案一：基础分区（推荐新手） 分区 大小 文件系统 说明 boot 1GB ext4 启动分区 50GB ext4 根分区 home 剩余空间 ext4 用户数据 swap 4GB swap 交换分区 方案二：高级分区（服务器推荐） 分区 大小 文件系统 说明 boot 1GB ext4 启动分区 bootefi 512MB vfat UEFI 分区 30GB ext4 根分区 var 20GB ext4 日志和缓存 varlog 10GB ext4 日志文件 home 剩余空间 ext4 用户数据 tmp 10GB ext4 临时文件 swap 8GB swap 交换分区 3.2 开始安装 CentOS 7制作启动介质使用 Rufus（Windows）： 下载 Rufus：https://rufus.ie/ 插入 U 盘（至少 8GB） 选择 ISO 文件 分区类型：GPT 或 MBR（根据电脑支持） 点击开始 使用 dd（LinuxMac）： # 查看 U 盘设备名lsblk# 卸载 U 盘分区sudo umount /dev/sdX*# 写入 ISO（注意：sdX 是整个设备，不是分区）sudo dd if=CentOS-7-x86_64-DVD-2009.iso of=/dev/sdX bs=4M status=progress# 同步缓冲区sync 安装步骤1. 启动安装程序 插入启动 U 盘 开机按 F12F2Del 进入 BIOSUEFI 选择从 U 盘启动 选择 “Install CentOS 7” 2. 选择语言 安装过程语言：中文 → 简体中文 键盘布局：汉语 3. 安装摘要 配置以下项目： 日期和时间 选择时区：亚洲上海 开启网络时间同步 键盘 添加布局：汉语 语言支持 添加中文支持 安装源 自动检测到的安装介质 软件选择 最小安装（服务器推荐） 带 GUI 的服务器（需要图形界面） GNOME 桌面（桌面使用） 开发工具（可选） 安装位置（关键） 自动分区： 选择 “自动配置分区” 手动分区（推荐）： 选择 “我要配置分区” 选择分区方案：标准分区 点击 “+” 添加分区： 挂载点 期望容量 文件系统 boot 1GB ext4 50GB ext4 home 剩余 ext4 swap 4GB swap 接受更改 网络和主机名 配置网络连接 设置主机名（如：centos7-server） 4. 开始安装 点击 “开始安装” 设置 ROOT 密码 创建用户（可选但推荐） 5. 完成安装 安装完成后点击 “重启” 移除安装介质 安装后的基本配置1. 更新系统 sudo yum update -y 2. 配置网络 # 查看IP地址ip addr# 配置静态IP（编辑网络配置文件）sudo vi /etc/sysconfig/network-scripts/ifcfg-eth0# 示例配置：TYPE=EthernetBOOTPROTO=staticIPADDR=192.168.1.100NETMASK=255.255.255.0GATEWAY=192.168.1.1DNS1=8.8.8.8DNS2=114.114.114.114ONBOOT=yes# 重启网络服务sudo systemctl restart network 3. 配置防火墙 # 查看防火墙状态sudo systemctl status firewalld# 开放端口sudo firewall-cmd --permanent --add-port=80/tcpsudo firewall-cmd --permanent --add-port=443/tcpsudo firewall-cmd --reload# 或者关闭防火墙（测试环境）sudo systemctl stop firewalldsudo systemctl disable firewalld 4. 安装常用工具 # 安装基本工具sudo yum install -y vim wget curl net-tools telnet tree htop# 安装开发工具sudo yum groupinstall -y Development Tools# 安装EPEL源sudo yum install -y epel-release 3.3 多重开机安装流程与管理（Option）Windows + Linux 双系统安装顺序： 先安装 Windows（如果还没有） 为 Linux 预留空间（压缩卷） 安装 Linux 到预留空间 注意事项： 关闭 Windows 的快速启动 关闭 Secure Boot（或配置 Linux 支持） 使用相同的启动模式（UEFI 或 Legacy） 使用 GRUB 管理多重开机# 查看 GRUB 配置cat /boot/grub2/grub.cfg# 更新 GRUB 配置sudo grub2-mkconfig -o /boot/grub2/grub.cfg# 设置默认启动项sudo grub2-set-default 0 # 第一个菜单项# 查看默认启动项sudo grub2-editenv list 3.4 重点回顾 安装前准备：检查硬件要求，下载 CentOS 7 ISO 分区规划：建议至少 boot、、home、swap 四个分区 启动介质：使用 Rufus（Windows）或 dd（Linux）制作启动U盘 安装过程：语言选择 → 分区配置 → 软件选择 → 设置密码 → 开始安装 安装后配置：网络配置、防火墙、系统更新、常用工具安装 双系统：先安装 Windows，再安装 Linux，使用 GRUB 管理启动 3.5 本章习题 CentOS 7 的最小硬件要求是什么？推荐配置呢？ 列举三种制作 Linux 启动U盘的工具或方法。 为以下场景设计分区方案： 场景A：个人桌面，500GB硬盘，8GB内存 场景B：服务器，2TB硬盘，32GB内存 描述 CentOS 7 的安装步骤，从启动U盘到完成安装。 安装完成后，应该进行哪些基本配置？ 如果你要安装 Windows 和 CentOS 双系统，正确的安装顺序是什么？需要注意什么？ 如何查看和修改 GRUB 的默认启动项？ 实践：在虚拟机中安装 CentOS 7，并完成基本配置。 3.6 参考资料与延伸阅读 CentOS 官方文档 CentOS 下载页面 Rufus 启动盘制作工具 鸟哥的Linux私房菜 - 安装CentOS 7.x GRUB 2 手册","tags":[null,null,null]},{"title":"第四章、首次登陆与线上求助","path":"/notes/linux/ch04-first-login.html","content":"第四章、首次登陆与线上求助4.1 首次登陆系统开机与登陆 开机：按下电源键，系统开始引导 登陆界面：图形界面或命令行界面 输入账号密码： 账号：安装时创建的用户名 密码：输入时不会显示任何字符（安全机制） 命令行界面 (CLI)如果进入的是图形界面，可以打开终端 (Terminal) 来使用命令行。 打开终端的方法： 桌面右键 → 打开终端 应用程序菜单 → 系统工具 → 终端 快捷键：Ctrl + Alt + T（Ubuntu） 基础操作指令1. 显示日期：datedate # 显示当前日期时间date +%Y/%m/%d # 格式化输出：2024/01/01date +%H:%M:%S # 格式化输出：14:30:00 2. 显示日历：calcal # 显示当月日历cal 2024 # 显示整年日历cal 1 2024 # 显示指定月份（2024年1月）cal -3 # 显示前中后三个月 3. 简单计算器：bcbc # 进入交互式计算器scale=3 # 设置小数位数为31/3 # 输出：0.33310+20*2 # 输出：50quit # 退出bc 使用管道直接计算： echo 1+2+3 | bc # 输出：6echo scale=2; 10/3 | bc # 输出：3.33 4. 重要的热键 热键 功能 Tab 命令文件名自动补全（按两下显示所有选项） Ctrl + C 终止当前运行的程序 Ctrl + D 退出当前终端（输入EOF） Ctrl + L 清屏（等同于 clear 命令） Ctrl + A 光标移动到行首 Ctrl + E 光标移动到行尾 Ctrl + U 删除光标前所有内容 Ctrl + K 删除光标后所有内容 Ctrl + R 搜索历史命令 ↑ ↓ 浏览历史命令 5. 错误查看当命令输入错误时，系统会显示错误信息： # 命令不存在$ cmdnotfoundbash: cmdnotfound: command not found# 权限不足$ /etc/shadowbash: /etc/shadow: Permission denied# 文件不存在$ cat /notexistcat: /notexist: No such file or directory 4.2 文字模式下指令的下达指令的基本格式command [-options] [arguments] command：指令名称（如 ls, cp, mv） -options：选项，通常以 - 或 -- 开头 arguments：参数，指令操作的对象 基础指令详解1. 列出文件和目录：lsls # 列出当前目录内容ls -l # 详细列表格式ls -a # 显示所有文件（包括隐藏文件）ls -la # 组合选项：详细+所有文件ls -lh # 人类可读的文件大小（K, M, G）ls -ltr # 按时间倒序排列ls /etc # 列出指定目录内容ls *.txt # 列出所有txt文件（通配符） 输出示例： -rw-r--r-- 1 user group 1234 Jan 1 10:00 file.txtdrwxr-xr-x 2 user group 4096 Jan 1 09:00 directory/ 2. 切换目录：cdcd /home/user # 切换到指定目录cd ~ # 切换到用户主目录cd # 同上（默认回到主目录）cd .. # 切换到上级目录cd ../.. # 切换到上上级目录cd - # 切换到上一次所在的目录cd / # 切换到根目录cd ~/Documents # 切换到主目录下的Documents 3. 显示当前目录：pwdpwd # 显示当前完整路径pwd -P # 显示物理路径（解析所有符号链接） 4. 创建目录：mkdirmkdir dirname # 创建一个目录mkdir dir1 dir2 dir3 # 同时创建多个目录mkdir -p parent/child # 递归创建多级目录mkdir -m 755 mydir # 创建时指定权限 5. 删除文件或目录：rmrm file.txt # 删除文件rm file1 file2 # 删除多个文件rm -i file.txt # 交互模式（删除前询问）rm -f file.txt # 强制删除（不提示，忽略不存在文件）rm -r directory # 递归删除目录及其内容rm -rf directory # 强制递归删除（危险命令！）rm *.log # 删除所有log文件 ⚠️ 警告： rm -rf / 会删除整个系统！使用时要特别小心。 6. 复制文件或目录：cpcp source.txt dest.txt # 复制文件cp file.txt /path/to/ # 复制到目录cp file1 file2 /dest/ # 复制多个文件到目录cp -i file.txt dest.txt # 覆盖前询问cp -f file.txt dest.txt # 强制覆盖cp -r dir1 dir2 # 递归复制目录cp -a dir1 dir2 # 归档模式（保留权限、时间戳等）cp -v source dest # 显示详细信息 7. 移动或重命名文件：mvmv oldname newname # 重命名文件mv file.txt /path/to/ # 移动文件mv file1 file2 /dest/ # 移动多个文件mv dir1 /path/to/ # 移动目录mv -i source dest # 覆盖前询问mv -f source dest # 强制覆盖mv -v source dest # 显示详细信息 8. 查看文件内容cat - 显示整个文件内容 cat file.txt # 显示文件内容cat -n file.txt # 显示行号cat -A file.txt # 显示特殊字符cat file1 file2 file3 # 合并文件cat file.txt # 创建文件并输入内容 less - 分页浏览（推荐） less file.txt # 分页查看# 在 less 中的操作：# 空格 / PageDown - 下一页# b / PageUp - 上一页# /pattern - 搜索# n - 下一个匹配# q - 退出 head - 显示文件开头 head file.txt # 显示前10行head -n 20 file.txt # 显示前20行head -20 file.txt # 同上head -c 100 file.txt # 显示前100字节 tail - 显示文件结尾 tail file.txt # 显示后10行tail -n 20 file.txt # 显示后20行tail -f file.txt # 实时跟踪文件更新（常用）tail -f /var/log/syslog # 实时查看系统日志 wc - 统计文件 wc file.txt # 输出行数、词数、字节数wc -l file.txt # 只显示行数wc -w file.txt # 只显示词数wc -c file.txt # 只显示字节数 sort - 排序 sort file.txt # 按字母顺序排序sort -r file.txt # 逆序排序sort -n file.txt # 按数字排序sort -u file.txt # 去重并排序sort -t: -k3 -n /etc/passwd # 按第3字段（UID）数字排序 uniq - 去重 uniq file.txt # 删除相邻的重复行uniq -c file.txt # 统计每行出现的次数uniq -d file.txt # 只显示重复的行uniq -u file.txt # 只显示不重复的行 搜索与查找find - 查找文件（强大但较慢） find /path -name file.txt # 按名称查找find /path -name *.txt # 查找所有txt文件find /path -type d -name dir # 查找目录find /path -type f -size +100M # 查找大于100M的文件find /path -mtime -7 # 查找7天内修改过的文件find /path -user username # 查找属于某用户的文件find /path -perm 644 # 查找特定权限的文件find /path -name *.log -delete # 查找并删除find /path -type f -exec ls -l \\; # 对找到的文件执行命令 locate - 快速查找（基于数据库） locate filename # 快速查找文件locate -i filename # 忽略大小写locate *.txt # 支持通配符sudo updatedb # 更新locate数据库 grep - 文本搜索（常用） grep pattern file.txt # 在文件中搜索grep -i pattern file.txt # 忽略大小写grep -v pattern file.txt # 显示不匹配的行grep -n pattern file.txt # 显示行号grep -r pattern /path/ # 递归搜索目录grep -l pattern *.txt # 只显示包含匹配的文件名grep -E pattern1|pattern2 file.txt # 扩展正则表达式（或）grep -c pattern file.txt # 统计匹配行数grep ^start file.txt # 以start开头grep end$ file.txt # 以end结尾ps aux | grep nginx # 管道结合使用 which whereis - 查找命令位置 which ls # 查找命令的可执行文件位置which -a python # 查找所有匹配的路径whereis ls # 查找命令的二进制、源码和man手册位置whereis -b ls # 只找二进制文件 系统信息uname - 系统信息 uname -a # 显示所有系统信息uname -r # 显示内核版本uname -m # 显示机器硬件名称uname -n # 显示主机名 hostname - 主机名 hostname # 显示主机名hostname -i # 显示IP地址hostnamectl # 显示和修改主机名信息 whoami who w - 用户信息 whoami # 显示当前用户名who # 显示已登录用户who am i # 显示当前终端信息w # 显示登录用户及其正在执行的操作users # 显示用户名列表last # 显示最近登录记录lastlog # 显示所有用户的最后登录时间 df - 磁盘空间 df # 显示文件系统磁盘使用情况df -h # 人类可读格式（推荐）df -T # 显示文件系统类型df -i # 显示inode使用情况df -h /home # 查看特定目录所在分区的空间 du - 目录大小 du # 显示目录大小du -h # 人类可读格式du -sh /path # 查看目录总大小（推荐）du -h --max-depth=1 /path # 只显示一层子目录大小du -ah /path | sort -rh | head -20 # 找出最大的20个文件/目录 free - 内存使用 free # 显示内存使用情况free -h # 人类可读格式（推荐）free -m # 以MB为单位显示free -g # 以GB为单位显示free -s 5 # 每5秒刷新一次 top htop - 系统进程 top # 实时显示系统进程（按q退出）top -u username # 只显示某用户的进程top -p PID # 只显示指定PID的进程top -d 5 # 每5秒刷新 在 top 中可用的操作： P - 按CPU使用率排序 M - 按内存使用率排序 T - 按运行时间排序 k - 杀死进程 q - 退出 ps - 进程状态 ps # 显示当前终端的进程ps aux # 显示所有进程的详细信息（推荐）ps -ef # 全格式显示所有进程ps aux | grep nginx # 查找特定进程ps aux --sort=-%cpu # 按CPU使用率排序ps aux --sort=-%mem # 按内存使用率排序ps -u username # 查看某用户的进程ps -p PID -o pid,ppid,cmd,%cpu,%mem # 显示指定PID的特定信息 lscpu cat /proc/cpuinfo - CPU信息 lscpu # 显示CPU架构信息cat /proc/cpuinfo # 详细的CPU信息cat /proc/cpuinfo | grep model name # 查看CPU型号cat /proc/cpuinfo | grep -c processor # 查看CPU核心数nproc # 显示可用CPU核心数 lsblk fdisk - 磁盘信息 lsblk # 列出所有块设备df -h # 查看磁盘使用情况lsblk -f # 显示文件系统类型fdisk -l # 查看磁盘分区表（需要root权限）cat /proc/partitions # 查看分区信息blkid # 查看块设备的UUID ifconfig ip ss - 网络信息 ifconfig # 显示网络接口信息ip addr # 显示IP地址（现代命令）ip link # 显示网络接口状态ip route # 显示路由表ss -tuln # 显示监听端口netstat -tuln # 显示网络连接ping google.com # 测试网络连通性curl ifconfig.me # 查看公网IPhostname -I # 查看本机IP地址 env printenv - 环境变量 env # 显示所有环境变量printenv # 显示所有环境变量printenv PATH # 显示特定环境变量echo $PATH # 显示PATH变量echo $HOME # 显示家目录echo $USER # 显示当前用户export VAR=value # 设置环境变量 history - 命令历史 history # 显示命令历史history | less # 分页显示history | grep apt # 搜索历史命令!100 # 执行历史第100条命令!! # 执行上一条命令!apt # 执行最近以apt开头的命令history -c # 清除历史记录history -w # 将历史写入文件 关机与重启shutdown - 安全关机 shutdown now # 立即关机shutdown +5 # 5分钟后关机shutdown 14:00 # 指定时间关机shutdown -r now # 立即重启shutdown -r +5 # 5分钟后重启shutdown -c # 取消关机计划shutdown -h now # 立即关机并停止电源 reboot poweroff halt reboot # 重启poweroff # 关机并断电halt # 停止系统（不断电）init 0 # 关机init 6 # 重启systemctl reboot # 使用systemctl重启systemctl poweroff # 使用systemctl关机 sync - 同步数据到磁盘 sync # 将内存中的数据写入磁盘 ⚠️ 重要提示：关机或重启前，建议先执行 sync 命令，确保数据已写入磁盘。 4.3 Linux系统的线上求助man page与info pageman page 手册页Linux 系统内置了详细的帮助文档，称为 manual pages（手册页），简称 man page。 基本用法man command # 查看命令的手册页man ls # 查看ls命令的帮助man -f command # 查看命令的简短描述（等同于 whatis）man -k keyword # 搜索包含关键词的手册页（等同于 apropos） 手册页的分类（Sections）手册页分为不同的章节： 章节 内容 1 用户命令（普通用户可执行的命令） 2 系统调用（内核提供的函数） 3 库函数（程序库中的函数） 4 特殊文件（通常在 dev 中的设备） 5 文件格式和规范（如 etcpasswd） 6 游戏和屏保 7 杂项（包括宏包和约定） 8 系统管理命令（通常需要 root 权限） 9 内核例程 指定章节查看： man 1 ls # 查看第1章节的ls命令man 5 passwd # 查看第5章节的passwd文件格式 手册页中的导航进入 man page 后，可以使用以下按键导航： 按键 功能 空格 Page Down 向下翻页 Page Up b 向上翻页 ↓ Enter 向下滚动一行 ↑ 向上滚动一行 g 跳转到开头 G 跳转到结尾 /keyword 向下搜索关键词 ?keyword 向上搜索关键词 n 跳转到下一个匹配 N 跳转到上一个匹配 h 显示帮助 q 退出 man page 手册页的结构一个典型的 man page 包含以下部分： NAME # 命令名称和简要描述SYNOPSIS # 语法格式DESCRIPTION # 详细描述OPTIONS # 选项说明EXAMPLES # 示例EXIT STATUS # 退出状态码SEE ALSO # 相关参考BUGS # 已知问题AUTHOR # 作者信息 info page 信息页GNU 项目开发的另一种帮助系统，比 man page 更详细，支持超链接导航。 基本用法info command # 查看命令的info文档info ls # 查看ls的info文档info # 进入info主菜单info coreutils # 查看核心工具集的info文档 导航按键 按键 功能 Enter 跟随光标下的超链接 Tab 跳转到下一个链接 n 下一节 p 上一节 u 上一级 l 返回上一页 空格 向下翻页 Del Page Up 向上翻页 s 搜索 q 退出 ? h 显示帮助 info page 的优点 超链接导航：可以像浏览网页一样跳转 层级结构：清晰的章节组织 更详细的说明：通常比 man page 更详尽 示例丰富：提供更多使用示例 其他求助方式1. –help 选项大多数命令都支持 --help 选项，显示简要帮助： ls --helpcp --helpsystemctl --help 优点： 快速查看，无需进入 man page 显示常用选项 适合快速参考 2. whatis 命令显示命令的简要描述： whatis ls # ls (1) - list directory contentswhatis cp # cp (1) - copy files and directorieswhatis man # man (1) - an interface to the on-line reference manuals 3. apropos 命令通过关键词搜索相关的命令： apropos editor # 搜索与编辑器相关的命令apropos copy # 搜索与复制相关的命令apropos list directory # 支持多词搜索 4. 在线资源 官方文档：各发行版的官方 Wiki 和文档 Stack Overflow：技术问答社区 GitHub：开源项目托管平台 Linux 中国：中文 Linux 社区 鸟哥的 Linux 私房菜：经典教程网站 5. usrsharedoc 目录许多软件包会在此目录下安装额外的文档： ls /usr/share/doc/ # 查看已安装的文档ls /usr/share/doc/bash/ # 查看 bash 的额外文档 帮助系统的选择建议 场景 推荐方式 快速查看命令用法 command --help 查看详细文档 man command 查看GNU工具的详细说明 info command 不知道命令名字 apropos keyword 快速了解命令功能 whatis command 搜索具体问题的解决方案 在线搜索 实践练习 使用 man 查看 ls 命令的手册页，找出如何按时间排序的选项 使用 info 查看 coreutils 的文档 使用 apropos 搜索与 “delete” 相关的命令 使用 whatis 查看常用命令（cat, grep, find, chmod）的功能描述 比较 man ls 和 ls --help 的输出差异 4.4 超简单文书编辑器：nanonano 简介nano 是一个简单易用的文本编辑器，适合初学者。它比 vivim 更容易上手。 启动 nanonano # 打开新文件nano filename.txt # 打开或创建文件nano +10 filename.txt # 打开文件并跳到第10行 基本操作界面说明GNU nano 2.9.3 filename.txt[文件内容显示区域]^G 帮助 ^O 保存 ^W 搜索 ^K 剪切 ^J 对齐^X 退出 ^R 读取 ^Y 上一页 ^C 位置 ^T 拼写 ^ 表示 Ctrl 键 ^G Ctrl + G 常用快捷键 快捷键 功能 Ctrl + G 显示帮助 Ctrl + O 保存文件 Ctrl + X 退出 nano Ctrl + R 插入其他文件 Ctrl + W 搜索 Ctrl + V Page Down 下一页 Ctrl + Y Page Up 上一页 Ctrl + K 剪切当前行 Ctrl + U 粘贴 Ctrl + J 对齐当前段落 Ctrl + C 显示光标位置 Ctrl + T 拼写检查 Ctrl + _ Ctrl + / 跳到指定行 Alt + U 撤销 Alt + E 重做 编辑操作 移动光标：使用方向键 输入文本：直接打字 删除：使用 Backspace 或 Delete 保存：Ctrl + O，然后按 Enter 确认 退出：Ctrl + X，如有修改会提示保存 搜索和替换搜索： 按 Ctrl + W 输入要搜索的文本 按 Enter 按 Alt + W 查找下一个 替换： 按 Ctrl + \\ 输入要搜索的文本，按 Enter 输入替换文本，按 Enter 按 Y 确认替换，N 跳过，A 全部替换 nano 配置配置文件位置 系统级配置：/etc/nanorc 用户级配置：~/.nanorc 常用配置选项# 显示行号set linenumbers# 自动缩进set autoindent# 使用空格代替Tabset tabstospacesset tabsize 4# 语法高亮（nano 2.1.5+）include /usr/share/nano/*.nanorc# 平滑滚动set smooth# 显示光标位置set constantshow# 启用鼠标set mouse# 自动换行set wordwrap# 制表符宽度set tabsize 4 nano 与 vivim 的选择 编辑器 优点 缺点 适用场景 nano 简单易学，界面直观 功能相对简单 新手入门，简单编辑 vivim 功能强大，效率高 学习曲线陡峭 专业用户，频繁编辑 建议： 初学者先用 nano 入门 熟练后学习 vim，提高工作效率 服务器环境通常都有 vi，nano 可能需要额外安装 实践练习 使用 nano 创建一个文本文件，输入一些内容，保存并退出 使用 nano 打开系统配置文件（如 /etc/hosts），观察界面 在 nano 中使用搜索功能查找特定文本 配置 nano 的行号显示和语法高亮 比较 nano 和 vim 的使用体验 4.5 正确的关机方法为什么需要正确关机Linux 是多用户、多任务系统，后台可能有许多进程在运行。直接断电可能导致： 数据丢失：未写入磁盘的数据会丢失 文件系统损坏：正在写入的文件可能损坏 系统不稳定：下次启动可能出现错误 查看系统状态在关机前，可以先查看系统状态： who # 查看当前登录的用户w # 查看用户及其活动ps aux # 查看运行的进程top # 实时查看系统状态 关机命令shutdown（推荐）功能最强大的关机命令，可以定时关机、重启，并发送通知给所有用户。 # 立即关机shutdown now# 定时关机（10分钟后）shutdown +10# 指定时间关机shutdown 14:00# 立即重启shutdown -r nowshutdown -r +5 System will reboot in 5 minutes# 关机并停止电源（需要硬件支持）shutdown -h now# 取消关机计划shutdown -c 发送消息给所有用户： shutdown +10 System will shutdown for maintenance in 10 minutes. Please save your work. poweroff直接关闭系统并切断电源。 poweroff # 关机并断电poweroff -f # 强制关机poweroff -p # 关机并断电（默认） halt停止系统运行，但不一定断电。 halt # 停止系统halt -p # 停止系统并断电halt -f # 强制停止 reboot重启系统。 reboot # 重启reboot now # 立即重启reboot -f # 强制重启 init通过改变运行级别来关机或重启。 init 0 # 关机（运行级别0）init 6 # 重启（运行级别6） 运行级别（Runlevel）Linux 系统有不同的运行级别，对应不同的系统状态： 运行级别 说明 0 关机 1 单用户模式（救援模式） 2 多用户模式（无网络） 3 完全多用户模式（命令行） 4 保留，未使用 5 图形界面模式 6 重启 查看当前运行级别： runlevel # 显示之前的和当前的运行级别who -r # 显示当前运行级别systemctl get-default # 查看默认启动目标 切换运行级别： init 3 # 切换到命令行模式init 5 # 切换到图形界面systemctl isolate multi-user.target # 切换到多用户目标systemctl isolate graphical.target # 切换到图形目标 使用 systemd 管理电源现代 Linux 发行版（如 CentOS 7+、Ubuntu 15+）使用 systemd 作为初始化系统。 关机： systemctl poweroff # 关机systemctl halt # 停止系统 重启： systemctl reboot # 重启 挂起和休眠： systemctl suspend # 挂起（保存到内存）systemctl hibernate # 休眠（保存到硬盘）systemctl hybrid-sleep # 混合睡眠 注意事项 保存工作：关机前确保所有重要数据已保存 通知用户：多用户系统应提前通知其他用户 关闭程序：尽量正常关闭应用程序 避免强制关机：除非系统无响应，否则不要使用强制关机 定期重启：长期运行的系统建议定期重启以清理内存 实践练习 查看当前系统的运行级别 使用 shutdown 命令设置 10 分钟后关机，然后取消 查看 reboot 命令的手册页 使用 systemctl 查看系统的电源管理命令 了解你的系统的默认运行级别（目标） 4.6 重点回顾 Linux 系统有图形界面和命令行界面两种操作方式 基础命令：date, cal, bc, ls, cd, pwd, mkdir, rm, cp, mv, cat, less, head, tail 重要热键：Tab（补全），Ctrl+C（中断），Ctrl+D（退出） 使用 man, info, --help 获取帮助 文本编辑器 nano：简单易学，适合初学者 正确关机很重要，使用 shutdown, reboot, poweroff 等命令 4.7 本章习题 如何查看当前日期和时间？如何显示2024年的日历？ 列出当前目录下所有文件（包括隐藏文件）的详细信息。 如何在后台运行一个程序？如何终止它？ 使用 man 查看 cp 命令的手册页，找出如何保留文件属性的选项。 使用 nano 创建一个文件，输入一些内容，保存并退出。 系统将在10分钟后关机，如何取消这个关机计划？ 解释 df, du, free 命令的区别。 如何查看系统的内存使用情况？如何查看磁盘使用情况？ 4.8 参考资料与延伸阅读 man man - 查看 man 命令的手册页 man intro - Linux 简介 Linux 命令大全 Linux 命令行大全","tags":[null,null,null]},{"title":"第六章、Linux 文件与目录管理","path":"/notes/linux/ch06-file-management.html","content":"第六章、Linux 文件与目录管理6.1 目录与路径目录的相关操作特殊目录符号 符号 含义 . 当前目录 .. 上级目录 - 上一次所在的目录 ~ 当前用户的主目录 ~username 指定用户的主目录 常见目录操作命令cd - 切换目录 cd /etc # 切换到绝对路径cd ../.. # 切换到上上级目录cd ~ # 切换到主目录cd - # 切换到上次所在目录cd /var/log pwd # 组合使用 pwd - 显示当前路径 pwd # 显示逻辑路径（可能包含符号链接）pwd -P # 显示物理路径（解析符号链接） mkdir - 创建目录 mkdir dirname # 创建单个目录mkdir -p a/b/c/d # 递归创建多级目录mkdir -m 700 private # 创建时指定权限mkdir dir1,2,3 # 创建多个目录（花括号展开）mkdir -v newdir # 显示创建过程 rmdir - 删除空目录 rmdir emptydir # 删除空目录rmdir -p a/b/c # 递归删除空目录 rm - 删除文件或目录 rm file.txt # 删除文件rm -r directory # 递归删除目录rm -rf directory # 强制递归删除（谨慎使用！）rm -i file.txt # 删除前询问rm -f *.log # 强制删除所有log文件 PATH 环境变量什么是 PATHPATH 是一个环境变量，指定了系统查找可执行程序的目录列表。当你在命令行输入一个命令时，系统会在 PATH 指定的目录中查找对应的程序。 查看 PATHecho $PATH # 显示PATH值printenv PATH # 同上env | grep PATH # 在环境变量中查找PATH PATH 输出示例： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin PATH 的搜索顺序系统按照 PATH 中目录的顺序从左到右搜索命令： /usr/local/sbin → /usr/local/bin → /usr/sbin → /usr/bin → /sbin → /bin → ... 第一个匹配的命令将被执行。 修改 PATH临时修改（当前终端会话）： # 追加目录到PATHexport PATH=$PATH:/new/directory# 在PATH开头添加目录（优先搜索）export PATH=/new/directory:$PATH# 设置全新的PATHexport PATH=/bin:/usr/bin:/usr/local/bin 永久修改（对所有用户）：编辑 /etc/profile 或 /etc/environment： sudo nano /etc/profile# 添加：export PATH=$PATH:/opt/myapp/bin 永久修改（仅对当前用户）：编辑 ~/.bashrc 或 ~/.profile： nano ~/.bashrc# 添加：export PATH=$PATH:$HOME/binexport PATH=$PATH:$HOME/.local/bin# 使修改生效source ~/.bashrc 查看命令位置which command # 查找命令的可执行文件路径which -a command # 查找所有匹配的路径whereis command # 查找命令的二进制、源码和手册位置whereis -b command # 只找二进制文件whatis command # 显示命令的简短描述type command # 显示命令类型（别名、函数、内置、外部）type -a command # 显示所有匹配 PATH 相关技巧# 检查目录是否在PATH中echo $PATH | grep -q /my/dir echo 存在 || echo 不存在# 删除PATH中的某个目录export PATH=$(echo $PATH | sed s|/unwanted/dir:||)# 美化显示PATH（每行一个目录）echo $PATH | tr : # 统计PATH中有多少个目录echo $PATH | tr : | wc -l 6.2 Linux 文件与目录管理文件与目录的检视：lsls 命令详解ls (list) 命令用于列出目录内容，是使用最频繁的命令之一。 基本用法： ls # 列出当前目录内容ls /path/to/directory # 列出指定目录内容ls file.txt # 显示单个文件信息ls file1 file2 dir1/ # 列出多个文件/目录 常用选项 选项 全称 说明 -l long 使用长列表格式（详细信息） -a all 显示所有文件，包括隐藏文件（以.开头） -A almost-all 显示所有文件，但不包括 . 和 .. -h human-readable 以人类可读的方式显示文件大小（K, M, G） -d directory 显示目录本身，而不是其内容 -t time 按修改时间排序（最新的在前） -r reverse 反向排序 -S size 按文件大小排序（最大的在前） -i inode 显示文件的 inode 号 -R recursive 递归列出子目录内容 -F classify 在文件名后添加类型指示符（*@|） --color 使用颜色区分文件类型 组合使用示例ls -la # 显示所有文件（包括隐藏）的详细信息ls -lh # 以人类可读的方式显示详细信息ls -ltr # 按时间倒序排列（最老的在前）ls -lS # 按文件大小排序（最大的在前）ls -ld /etc # 显示 /etc 目录本身的信息ls -R /path # 递归列出所有子目录ls -la --color=auto # 使用颜色显示（通常为默认设置）ls -i # 显示 inode 号 输出解析ls -l 输出格式： -rwxr-xr-x 1 user group 12345 Jan 1 10:00 filename│└┬┘└┬┘└┬┘ │ │ │ │ │ │ ││ │ │ │ │ │ │ │ │ │ └─ 文件名│ │ │ │ │ │ │ │ │ └────── 时间│ │ │ │ │ │ │ │ └────────── 日期│ │ │ │ │ │ │ └─────────────── 文件大小（字节）│ │ │ │ │ │ └───────────────────── 所属群组│ │ │ │ │ └────────────────────────── 所有者│ │ │ │ └───────────────────────────── 硬链接数│ │ │ └───────────────────────────────── 其他用户权限│ │ └─────────────────────────────────── 群组权限│ └────────────────────────────────────── 所有者权限└──────────────────────────────────────── 文件类型 文件类型标识： - 普通文件 d 目录 l 符号链接 b 块设备 c 字符设备 s 套接字 p 管道 实用技巧1. 列出最近修改的文件： ls -lt | head -10 # 最近修改的10个文件ls -ltr | tail -10 # 最早修改的10个文件 2. 按大小排序： ls -lS | head -10 # 最大的10个文件ls -lSr | head -10 # 最小的10个文件 3. 查找大文件： ls -lhS | grep -E ^-.+[MG] # 显示大于1MB的文件 4. 统计文件数量： ls | wc -l # 当前目录文件数ls -a | wc -l # 包括隐藏文件ls -l | grep ^- | wc -l # 只统计普通文件ls -l | grep ^d | wc -l # 只统计目录 5. 显示文件大小总和： ls -l | awk sum+=$5 END print sum # 字节数ls -l | awk sum+=$5 END printf %.2f MB , sum/1024/1024 6. 查找空文件或空目录： ls -l | grep ^-\\s*1\\s.*\\s0\\s # 空文件（硬链接数为1，大小为0）find . -type f -empty # 更准确的空文件查找find . -type d -empty # 空目录 7. 使用通配符列出特定文件： ls *.txt # 所有txt文件ls file?.txt # file0.txt, file1.txt 等（单个字符）ls file[0-9].txt # file0.txt 到 file9.txtls file[!0-9].txt # 不匹配数字的文件ls a,b,c*.txt # 以a、b或c开头的txt文件ls **/*.txt # 递归查找所有txt文件（需要启用globstar） 8. 结合其他命令使用： # 查找并删除旧文件ls -t /path/*.log | tail -n +8 | xargs rm -f# 打包最近修改的文件ls -t | head -20 | tar -czf recent.tar.gz -T -# 复制特定文件到另一目录ls -d *.txt | xargs -I cp /backup/ 复制、删除与移动：cp, rm, mvcp (复制)基本语法： cp [选项] 源文件 目标文件cp [选项] 源文件... 目标目录 常用选项： 选项 说明 -a 归档模式，保留所有属性（相当于 -dpR） -d 复制符号链接本身，而非指向的文件 -f 强制覆盖 -i 覆盖前询问确认 -l 创建硬链接而非复制 -p 保留文件属性（时间戳、权限、所有者等） -r -R 递归复制目录 -s 创建符号链接 -u 只在源文件比目标文件新或目标不存在时复制 -v 显示详细过程 示例： # 基本复制cp file.txt /backup/cp file.txt /backup/newname.txt# 保留属性cp -p file.txt /backup/ # 保留时间戳等属性cp -a dir1/ dir2/ # 归档模式复制整个目录# 递归复制目录cp -r /source/dir /destination/cp -rv /source/dir /destination/ # 显示详细过程# 覆盖确认cp -i file.txt /existing/path/ # 覆盖前询问cp -f file.txt /existing/path/ # 强制覆盖# 条件复制cp -u /source/file /destination/ # 只复制更新的文件# 复制多个文件cp file1 file2 file3 /destination/cp *.txt /backup/# 复制时显示进度（使用 pv 命令）pv source.iso | cp /dev/stdin /dest/backup.iso rm (删除)基本语法： rm [选项] 文件... 常用选项： 选项 说明 -f 强制删除，不提示 -i 删除前询问确认 -r -R 递归删除目录及其内容 -v 显示详细过程 --preserve-root 不允许删除根目录（默认） --no-preserve-root 允许删除根目录（极度危险！） 示例： # 删除文件rm file.txtrm file1 file2 file3# 删除前确认rm -i file.txt# 强制删除（不提示）rm -f file.txt# 删除目录rm -r directory/rm -rf directory/ # 强制递归删除（谨慎使用！）# 显示删除过程rm -rv directory/# 删除特定类型的文件rm *.logrm -rf /tmp/*.tmp# 安全删除（覆盖后删除）shred -u file.txt # 覆盖后删除（更安全）# 删除空目录find /path -type d -empty -delete# 删除 N 天前的文件find /path -name *.log -mtime +30 -delete ⚠️ 极度危险命令（永远不要执行）： rm -rf / # 删除整个系统！rm -rf /* # 同上rm -rf ~ # 删除主目录rm -rf . # 删除当前目录rm -rf .* # 删除所有隐藏文件和上级目录 mv (移动重命名)基本语法： mv [选项] 源文件 目标文件 # 重命名或移动单个文件mv [选项] 源文件... 目标目录 # 移动多个文件到目录 常用选项： 选项 说明 -f 强制覆盖，不提示 -i 覆盖前询问确认 -n 不覆盖已存在的文件 -u 只在源文件比目标文件新或目标不存在时移动 -v 显示详细过程 --backup 覆盖前创建备份 --suffix 指定备份文件的后缀 示例： # 重命名文件mv oldname.txt newname.txt# 移动文件mv file.txt /destination/mv file.txt /destination/newname.txt# 移动多个文件mv file1 file2 file3 /destination/mv *.txt /backup/# 移动目录mv old_dir/ /new/location/mv old_dir/ /new/location/new_name/# 覆盖确认mv -i file.txt /existing/mv -f file.txt /existing/ # 强制覆盖# 条件移动（只移动更新的文件）mv -u /source/file /destination/# 显示详细过程mv -v file.txt /destination/# 安全移动（备份已存在的文件）mv --backup=numbered file.txt /existing/mv --suffix=.bak file.txt /existing/# 交互式移动（不覆盖）mv -n file.txt /existing/ 文件内容查阅直接检视文件内容cat (concatenate) 将文件内容输出到标准输出（屏幕）。 cat file.txt # 显示文件内容cat -n file.txt # 显示行号cat -A file.txt # 显示特殊字符（$行尾，^I制表符）cat -b file.txt # 对非空行编号cat -E file.txt # 在行尾显示$cat -T file.txt # 将制表符显示为^Icat file1 file2 # 连接多个文件cat file1 file2 file3 # 合并文件到新文件cat file.txt # 创建文件并输入内容（Ctrl+D结束）cat file.txt # 追加内容到文件 ⚠️ 注意：cat 适合查看小文件，大文件应该使用 less 或 more。 tac 反向输出文件内容（从最后一行开始）。 tac file.txt # 反向显示文件内容（最后一行在前）tac file.txt reversed.txt # 保存反向内容到新文件 nl (number lines) 添加行号显示文件内容，比 cat -n 更灵活。 nl file.txt # 显示文件并添加行号（非空行）nl -b a file.txt # 所有行都编号（包括空行）nl -b t file.txt # 只对非空行编号（默认）nl -b pBRE file.txt # 对匹配正则表达式的行编号nl -n ln file.txt # 行号左对齐（默认）nl -n rn file.txt # 行号右对齐nl -n rz file.txt # 行号右对齐并补零nl -w 5 file.txt # 设置行号宽度为5位nl -s . file.txt # 设置分隔符为. nl -v 10 file.txt # 行号从10开始nl -i 2 file.txt # 行号每次增加2 more 分页显示文件内容，适合查看大文件。 more file.txt # 分页显示文件more +10 file.txt # 从第10行开始显示more -10 file.txt # 每屏显示10行ls -la | more # 管道结合使用cat file.txt | more # 分页显示 在 more 中的操作： 空格 - 下一页 Enter - 下一行 b - 上一页 /pattern - 搜索 q - 退出 = - 显示当前行号 ⚠️ 注意：more 不能向前翻页（只能用 b），现在一般使用 less。 less (推荐) 更强大的分页显示工具，比 more 功能更丰富。 less file.txt # 分页显示文件less +10 file.txt # 从第10行开始less -N file.txt # 显示行号less -S file.txt # 不换行，可左右滚动less -i file.txt # 搜索时忽略大小写less +F file.txt # 实时监控文件变化（类似tail -f）ls -la | less # 管道结合使用 在 less 中的操作： 按键 功能 ↓ Enter e j 向下滚动一行 ↑ y k 向上滚动一行 空格 Page Down f 向下翻页 b Page Up 向上翻页 d 向下翻半页 u 向上翻半页 → ← 水平滚动（当使用 -S 时） g Home 跳转到文件开头 G End 跳转到文件结尾 = / Ctrl+G 显示当前位置信息 /pattern 向下搜索 ?pattern 向上搜索 n 跳到下一个匹配 N 跳到上一个匹配 pattern 只显示匹配的行 : 进入命令模式 -N 切换行号显示 q 退出 Q 退出，不保存标记 h 显示帮助 less 的高级用法： # 同时查看多个文件less file1.txt file2.txt file3.txt# 在less中：# :n - 下一个文件# :p - 上一个文件# :e file.txt - 打开新文件# 标记位置# m + 字母（如 ma）- 标记当前位置# + 字母（如 a）- 跳转到标记# 过滤内容# pattern - 只显示匹配的行# - 取消过滤# 编辑文件# v - 用默认编辑器编辑文件 head 和 tailhead - 显示文件开头部分 head file.txt # 显示前10行（默认）head -n 20 file.txt # 显示前20行head -20 file.txt # 同上（简写）head -c 100 file.txt # 显示前100字节head -n -5 file.txt # 显示除了最后5行的所有行 tail - 显示文件结尾部分 tail file.txt # 显示后10行（默认）tail -n 20 file.txt # 显示后20行tail -20 file.txt # 同上（简写）tail -c 100 file.txt # 显示后100字节tail -n +5 file.txt # 从第5行开始显示到末尾tail -f file.txt # 实时追踪文件更新（常用！）tail -F file.txt # 追踪文件，即使文件被重命名或删除也会重试 tail -f 的典型用法： # 实时监控日志文件tail -f /var/log/syslogtail -f /var/log/nginx/access.logtail -f /var/log/apache2/error.log# 监控多个日志文件tail -f /var/log/syslog /var/log/auth.log# 结合grep过滤tail -f /var/log/nginx/access.log | grep 500# 后台运行nohup tail -f /var/log/app.log head 和 tail 的组合使用： # 显示第10行head -10 file.txt | tail -1# 显示第10到20行head -20 file.txt | tail -11# 显示中间某部分（使用sed更方便）sed -n 10,20p file.txt 文件查找：findfind 命令是在目录层次结构中搜索文件的强大工具。 基本语法find [搜索路径] [表达式] 默认行为： 如果不指定路径，使用当前目录 . 递归搜索所有子目录 按名称查找# 按精确名称查找find /path -name file.txt# 忽略大小写find /path -iname File.txt # 匹配 file.txt, FILE.TXT, File.txt 等# 使用通配符（需要引号）find /path -name *.txt # 所有txt文件find /path -name file?.txt # file0.txt, file1.txt 等find /path -name [ab]* # 以a或b开头的文件# 排除特定名称find /path ! -name *.tmp # 排除.tmp文件find /path -not -name *.log # 排除.log文件# 正则表达式find /path -regex .*/file[0-9]+\\.txtfind /path -iregex .*\\.jpg # 忽略大小写 按类型查找# 文件类型find /path -type f # 普通文件find /path -type d # 目录find /path -type l # 符号链接find /path -type b # 块设备find /path -type c # 字符设备find /path -type s # 套接字find /path -type p # 管道# 组合条件find /path -type f -name *.log # 所有log文件find /path -type d -name test* # 以test开头的目录 按大小查找# 按文件大小find /path -size 10c # 正好10字节find /path -size 10k # 正好10KBfind /path -size 10M # 正好10MBfind /path -size 10G # 正好10GB# 大小范围find /path -size +10M # 大于10MBfind /path -size -10M # 小于10MBfind /path -size +1M -size -10M # 1MB到10MB之间# 组合find /path -type f -size +100M # 大于100MB的文件find /path -type f -size +1G -exec ls -lh \\; # 显示大于1GB的文件 按时间查找# 访问时间（access）find /path -atime 7 # 正好7天前访问过find /path -atime +7 # 超过7天前访问过（7天前以上）find /path -atime -7 # 最近7天内访问过find /path -amin +60 # 超过60分钟前访问过# 修改时间（modify）find /path -mtime 7 # 正好7天前修改过find /path -mtime +7 # 超过7天前修改过find /path -mtime -7 # 最近7天内修改过find /path -mmin -30 # 最近30分钟内修改过# 状态改变时间（change）find /path -ctime 7 # 正好7天前状态改变find /path -ctime +7 # 超过7天前状态改变find /path -ctime -7 # 最近7天内状态改变# 空文件或目录find /path -empty # 空文件或空目录find /path -type f -empty # 空文件find /path -type d -empty # 空目录# 组合使用find /path -type f -mtime +30 -size +100M # 30天前修改且大于100MBfind /path -type f -atime +365 # 1年以上未访问的文件 按用户和群组查找# 按所有者find /path -user username # 属于指定用户的文件find /path -uid 1000 # 属于指定UID的文件find /path ! -user root # 不属于root的文件# 按群组find /path -group groupname # 属于指定群组的文件find /path -gid 1000 # 属于指定GID的文件# 无用户或无群组find /path -nouser # 没有用户的文件（删除用户后遗留）find /path -nogroup # 没有群组的文件# 组合find /path -user alice -group developers # 特定用户和群组 按权限查找# 精确权限匹配find /path -perm 644 # 权限正好是644的文件find /path -perm /u=s # 有SUID位的文件find /path -perm /g=s # 有SGID位的文件find /path -perm /o=t # 有粘滞位的文件# 任意权限位（/）find /path -perm /222 # 任何人有写权限（2=写）find /path -perm /111 # 任何人有执行权限# 所有权限位必须匹配（-）find /path -perm -444 # 所有人至少有读权限find /path -perm -755 # 至少755权限# SUID/SGID/SBITfind /path -perm -4000 # 有SUID位的文件find /path -perm -2000 # 有SGID位的文件find /path -perm -1000 # 有粘滞位的目录find /path -perm /6000 # 有SUID或SGID位的文件# 查找所有特殊权限文件find / -perm /6000 -type f 2/dev/null 对找到的文件执行操作-exec 选项： # 基本语法find /path -name *.log -exec rm \\;# 代表找到的文件# \\; 表示命令结束# 示例：删除30天前的日志find /var/log -name *.log -mtime +30 -exec rm \\;# 示例：修改权限find /path -type f -exec chmod 644 \\;find /path -type d -exec chmod 755 \\;# 示例：复制文件find /source -name *.txt -exec cp /backup/ \\;# 示例：移动文件find /source -name *.tmp -exec mv /tmp/ \\;# 示例：重命名（使用-exec限制较多，通常使用管道+xargs或-find的-printf+sh）find /path -name *.txt -exec mv .bak \\; -exec ... + 选项（更高效）： # 将多个文件作为参数一次性传递给命令（类似xargs）find /path -name *.txt -exec rm +# 等效于: rm file1.txt file2.txt file3.txt...# 示例：统计多个文件的总行数find . -name *.py -exec wc -l +# 示例：计算总大小find /path -type f -exec du -ch + | grep total -ok 选项（交互式）： # 对每个文件执行命令前询问确认find /path -name *.log -ok rm \\;# 会提示: rm ...? 输入y确认，n跳过# 适用于危险操作前的确认find /path -type f -ok chmod 600 \\; 结合管道和 xargs对于复杂的操作，可以将 find 的结果通过管道传递给 xargs 或其他命令： # 基本用法find /path -name *.log | xargs rm# 处理文件名中有空格的情况find /path -name *.log -print0 | xargs -0 rm# 限制每次处理的参数数量find /path -name *.txt | xargs -n 10 -I cp /backup/# 结合其他命令find /path -name *.py | xargs grep importfind /path -type f | xargs du -h | sort -h# 使用 -exec 和管道的组合find /path -name *.log -exec ls -lh \\; | awk print $5, $9 find 的优化技巧# 1. 限制搜索深度find /path -maxdepth 2 -name *.txtfind /path -mindepth 2 -name *.txt# 2. 排除某些目录find /path -name /path/to/exclude -prune -o -name *.txt -print# 3. 使用 -xdev 不跨越文件系统find / -xdev -name *.txt # 只在当前文件系统搜索# 4. 先搜索文件名再执行操作（效率更高）find /path -name *.log -mtime +30 -delete# 5. 使用 -ls 代替 -exec ls（更快）find /path -name *.txt -ls# 6. 并行处理（使用 GNU parallel）find /path -name *.txt | parallel -j 4 gzip 实用 find 命令合集# ===== 文件清理 =====# 删除空文件find /path -type f -empty -delete# 删除空目录find /path -type d -empty -delete# 删除N天前的文件find /path -mtime +30 -type f -delete# 删除大文件（超过1GB）find /path -size +1G -type f -delete# ===== 权限修复 =====# 批量修改文件权限find /path -type f -exec chmod 644 \\;find /path -type d -exec chmod 755 \\;# 修复用户/群组find /path -user olduser -exec chown newuser \\;find /path -group oldgroup -exec chgrp newgroup \\;# ===== 查找特定文件 =====# 查找最近修改的文件find /path -mtime -1 -type f# 查找最大的文件find /path -type f -exec ls -lh \\; | sort -k5 -rh | head# 查找重复文件（按MD5）find /path -type f -exec md5sum \\; | sort | uniq -d -w32# ===== 批量操作 =====# 批量重命名（删除特定后缀）find /path -name *.bak -exec rename s/\\.bak$// \\;# 批量压缩find /path -name *.log -exec gzip \\;# 批量转换编码find /path -name *.txt -exec iconv -f GBK -t UTF-8 -o .utf8 \\;# 批量图片处理find /path -name *.jpg -exec convert -resize 800x600 .small.jpg \\; 本章重点总结 目录操作：cd, pwd, mkdir, rmdir, rm 文件操作：cp, mv, rm 内容查看：cat, tac, nl, more, less, head, tail 文件查找：find（按名称、类型、大小、时间、权限、用户等） 执行操作：-exec, -ok, xargs PATH 环境变量：系统查找命令的路径列表 练习题 如何在目录树中快速切换？写出5种cd的用法。 如何创建多级目录结构？如何同时创建多个目录？ 解释 rm -rf 的危险性。如何安全地删除文件？ 大文件应该用什么命令查看？如何实时监控日志文件？ 编写 find 命令： 查找 varlog 中7天前的日志文件 查找当前目录下大于100MB的文件 查找 home 中不属于任何用户的文件 查找所有设置了SUID位的文件 如何为自定义脚本添加执行权限并添加到PATH？ 使用 find 和 tar 组合备份最近修改的文件。","tags":[null,null,null]},{"title":"第五章、Linux 的文件权限与目录配置","path":"/notes/linux/ch05-permissions.html","content":"第五章、Linux 的文件权限与目录配置5.1 使用者与群组Linux 的多用户多任务Linux 是一个多用户、多任务的操作系统： 多用户：多个用户可以同时使用系统 多任务：系统可以同时运行多个程序 三种身份Linux 系统中的每个文件都有三种身份： 身份 说明 user (u) 文件所有者（owner） group (g) 文件所属群组 others (o) 其他人（非所有者且非群组成员） 特殊身份： root：超级管理员，拥有系统最高权限，不受权限限制 使用者与群组的关系系统使用者├── root (超级管理员)├── user1 (属于 groups: users, developers)├── user2 (属于 groups: users, designers)└── user3 (属于 groups: users) 一个用户可以属于多个群组，但只有一个主要群组（primary group）。 查看用户信息whoami # 显示当前用户名id # 显示当前用户的UID、GID和所属群组id username # 显示指定用户的信息who # 显示当前登录的用户w # 显示登录用户及其活动users # 显示用户名列表last # 显示最近登录记录lastlog # 显示所有用户的最后登录时间finger username # 显示用户信息（需安装finger包） id 命令输出示例： $ iduid=1000(username) gid=1000(username) groups=1000(username),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),131(lxd),132(sambashare) 输出说明： uid：用户ID gid：主要群组ID groups：所属的所有群组 5.2 Linux 文件权限概念查看文件权限使用 ls -l 命令查看文件权限： ls -l filenamels -la # 查看所有文件（包括隐藏文件）ls -ld directory # 查看目录本身的信息（而非内容） 输出示例： $ ls -l-rw-r--r-- 1 user group 1234 Jan 1 10:00 file.txtdrwxr-xr-x 2 user group 4096 Jan 1 09:00 directory/lrwxrwxrwx 1 user group 11 Jan 1 08:00 link - /path/to/target 权限字符串解析权限字符串共 10 个字符： -rwxr-xr-x│└┬┘└┬┘└┬┘│ │ │ ││ │ │ └── 其他人(others)的权限│ │ └───── 群组(group)的权限│ └──────── 所有者(user)的权限└────────── 文件类型 第1位：文件类型 符号 类型 - 普通文件 d 目录 l 符号链接（软链接） b 块设备文件（如硬盘） c 字符设备文件（如键盘） s 套接字文件 p 管道文件 第2-10位：权限每组3个字符，共3组： 位置 含义 字符 r 读权限 可读（文件内容目录列表） w 写权限 可写（修改文件创建删除目录内容） x 执行权限 可执行（运行程序进入目录） - 无权限 该权限未授予 权限的具体含义文件权限 权限 对文件的作用 r (读) 可以读取文件内容（cat, less, 打开） w (写) 可以修改文件内容（编辑、覆盖、追加） x (执行) 可以将文件作为程序运行（.script.sh） 目录权限 权限 对目录的作用 r (读) 可以列出目录内容（ls） w (写) 可以在目录中创建、删除、重命名文件 x (执行) 可以进入目录（cd），访问目录中的文件 ⚠️ 重要说明： 对目录有 w 权限，就可以删除目录中的任何文件，即使对该文件没有权限！ 要访问目录中的文件，需要对目录有 x 权限 修改文件权限：chmodchmod 命令用于修改文件或目录的权限。 符号模式chmod [ugoa][+-=][rwx] file# 用户类别u = user (所有者)g = group (群组)o = others (其他人)a = all (所有人，相当于 ugo)# 操作+ = 添加权限- = 移除权限= = 设置权限（覆盖）# 权限r = read (读)w = write (写)x = execute (执行) 示例： chmod u+x script.sh # 给所有者添加执行权限chmod go-w file.txt # 移除群组和其他人的写权限chmod u=rwx,go=rx directory # 所有者全权限，群组和其他人读+执行chmod a+r file.txt # 给所有人添加读权限chmod a-x script.sh # 移除所有人的执行权限chmod u+s program # 设置 SUID 位chmod g+s directory # 设置 SGID 位chmod +t directory # 设置粘滞位 数字模式（八进制）权限可以用数字表示： 权限 数值 二进制 r (读) 4 100 w (写) 2 010 x (执行) 1 001 - (无) 0 000 组合值： 数字 权限 说明 7 rwx 读+写+执行 6 rw- 读+写 5 r-x 读+执行 4 r– 只读 3 -wx 写+执行 2 -w- 只写 1 –x 只执行 0 — 无权限 语法： chmod XYZ file# X = 所有者权限# Y = 群组权限# Z = 其他人权限 示例： chmod 755 script.sh # -rwxr-xr-x (所有者全权限，其他读+执行)chmod 644 file.txt # -rw-r--r-- (所有者读写，其他只读)chmod 700 private.key # -rwx------ (只有所有者可访问)chmod 777 shared_dir/ # drwxrwxrwx (所有人全权限)chmod 600 ~/.ssh/id_rsa # 私钥文件的标准权限chmod 644 ~/.ssh/id_rsa.pub # 公钥文件的标准权限 常见文件权限组合： 文件类型 权限 说明 普通文件 644 (-rw-r–r–) 普通文档 可执行脚本 755 (-rwxr-xr-x) 脚本程序 配置文件 600 (-rw——-) 敏感配置 日志文件 640 (-rw-r—–) 日志（组可读） 目录 755 (drwxr-xr-x) 普通目录 共享目录 2775 (drwxrwsr-x) 组共享（SGID） 临时目录 1777 (drwxrwxrwt) 公共可写（粘滞位） 递归修改权限对目录及其所有内容修改权限： chmod -R 755 directory/ # 递归修改目录及其内容的权限chmod -R u+w directory/ # 递归添加写权限chmod -R go-w directory/ # 递归移除组和其他人的写权限 ⚠️ 警告： 谨慎使用 -R 选项，特别是在系统目录上！ 修改文件所有者和群组：chownchown 命令用于修改文件或目录的所有者和或群组。 基本语法chown [选项] [所有者][:[群组]] 文件...# 只改所有者chown user file# 只改群组chown :group file# 或chgrp group file# 同时改所有者和群组chown user:group filechown user.group file 示例chown alice file.txt # 将文件所有者改为 alicechown :developers file.txt # 将文件群组改为 developerschown alice:developers file.txt # 同时修改所有者和群组chown -R alice:alice /home/alice # 递归修改用户主目录的所有者chown root:root /etc/passwd # 恢复系统文件的标准所有者chown $USER:$USER script.sh # 使用环境变量设置所有者 常用选项chown -R user:group dir/ # 递归修改目录及其内容chown --reference=file1 file2 # 将file2的所有者改为与file1相同chown -c user file # 只在发生更改时显示信息chown -v user file # 显示详细的处理信息 只修改群组：chgrpchgrp 专门用于修改文件的群组，功能与 chown :group 相同。 chgrp group file # 修改文件群组chgrp -R group directory/ # 递归修改目录群组chgrp --reference=file1 file2 # 参照file1修改file2的群组 特殊权限位除了基本的 rwx 权限，Linux 还有三种特殊权限位： 1. SUID (Set User ID) 符号：s（在所有者的 x 位置） 数值：4000 作用：执行该文件时，以文件所有者的身份运行 # 设置SUIDchmod u+s filechmod 4755 file# 示例：/usr/bin/passwd 命令ls -l /usr/bin/passwd# -rwsr-xr-x 1 root root ... /usr/bin/passwd 注意： SUID 对脚本文件无效，只对二进制可执行文件有效。 2. SGID (Set Group ID) 符号：s（在群组的 x 位置） 数值：2000 作用： 对文件：执行时以文件群组的身份运行 对目录：在该目录下创建的文件继承目录的群组 # 设置SGIDchmod g+s file_or_dirchmod 2755 dir/# 示例：共享目录mkdir /sharedchown :developers /sharedchmod 2775 /shared# 现在任何人在这个目录创建的文件都属于 developers 群组 3. Sticky Bit (粘滞位) 符号：t（在其他的 x 位置） 数值：1000 作用：只有文件所有者、目录所有者或 root 才能删除该目录下的文件 # 设置粘滞位chmod +t directorychmod 1777 directory# 示例：/tmp 目录ls -ld /tmp# drwxrwxrwt 10 root root ... /tmp 典型应用： tmp 目录允许所有人读写，但只能删除自己的文件。 特殊权限总结表 权限 符号 数值 作用 SUID s (u+s) 4000 以文件所有者身份执行 SGID s (g+s) 2000 以文件群组身份执行 继承目录群组 Sticky t (+t) 1000 限制删除权限 设置特殊权限# 符号模式chmod u+s file # 设置SUIDchmod g+s dir # 设置SGIDchmod +t dir # 设置粘滞位chmod u-s file # 移除SUIDchmod g-s dir # 移除SGIDchmod -t dir # 移除粘滞位# 数字模式（在普通权限前加一位）chmod 4755 file # -rwsr-xr-x (SUID)chmod 2755 dir # drwxr-sr-x (SGID)chmod 1755 dir # drwxr-xr-t (Sticky)chmod 6755 file # -rwsr-sr-x (SUID+SGID)chmod 7777 dir # drwsrwsrwt (所有特殊权限) 查看特殊权限ls -l /usr/bin/passwd # 查看SUIDls -ld /tmp # 查看Sticky bitls -ld /var/cache/man # 查看SGIDfind / -perm -4000 2/dev/null # 查找所有SUID文件find / -perm -2000 2/dev/null # 查找所有SGID文件find / -perm -1000 2/dev/null # 查找所有Sticky目录 文件隐藏属性Linux 文件系统还支持隐藏属性，使用 chattr 命令设置，lsattr 命令查看。 lsattr file # 查看文件隐藏属性chattr +i file # 设置不可变属性（连root都不能修改删除）chattr -i file # 移除不可变属性chattr +a file # 设置只能追加属性（只能添加内容，不能修改删除）chattr -a file # 移除追加属性 常用属性： 属性 说明 i 不可变（immutable），不能修改、删除、重命名、创建链接 a 只能追加（append-only），只能添加内容 A 不更新访问时间（atime） S 同步更新（synchronous），立即写入磁盘 d dump 命令忽略 e 使用extents格式（ext4） 文件访问控制列表 (ACL)ACL (Access Control List) 提供了比传统权限更细粒度的访问控制。 # 查看ACLgetfacl file# 设置ACLsetfacl -m u:username:rwx file # 给用户添加权限setfacl -m g:groupname:rx file # 给群组添加权限setfacl -m o::r file # 修改其他人权限setfacl -m m::rwx file # 修改masksetfacl -x u:username file # 移除用户的ACLsetfacl -b file # 移除所有ACLsetfacl -R -m u:username:rx dir/ # 递归设置 示例： # 允许特定用户读写文件setfacl -m u:alice:rw file.txt# 允许特定群组只读setfacl -m u:developers:r file.txt# 查看ACLgetfacl file.txt# file: file.txt# owner: bob# group: users# user::rw-# user:alice:rw-# group::r--# mask::rw-# other::r-- 5.3 Linux目录配置Linux 目录结构标准 (FHS)FHS (Filesystem Hierarchy Standard) 定义了 Linux 系统中目录的用途和组织方式。 根目录结构/├── bin/ # 基本命令（所有用户可用）├── boot/ # 启动相关文件├── dev/ # 设备文件├── etc/ # 系统配置文件├── home/ # 用户主目录├── lib/ # 共享库文件├── lib64/ # 64位共享库├── media/ # 可移动媒体挂载点├── mnt/ # 临时挂载点├── opt/ # 可选软件包├── proc/ # 进程信息虚拟文件系统├── root/ # root用户主目录├── run/ # 运行时变量数据├── sbin/ # 系统管理命令├── srv/ # 服务数据├── sys/ # 系统信息虚拟文件系统├── tmp/ # 临时文件├── usr/ # 用户程序和数据└── var/ # 可变数据 重要目录详解bin (Binary) 用途：存放所有用户都可以使用的基本命令 内容：ls, cp, mv, rm, cat, echo, mkdir 等 特点：单用户模式下也可用 sbin (System Binary) 用途：存放系统管理命令 内容：fdisk, fsck, reboot, shutdown, ifconfig 等 特点：通常需要 root 权限 usrbin 和 usrsbin 用途：存放应用程序的命令 关系：现代 Linux 中，bin 和 sbin 通常是到 usrbin 和 usrsbin 的符号链接 boot 用途：存放启动加载器相关文件 内容： 内核文件（vmlinuz-*） 初始化内存盘（initrd.img-* 或 initramfs-*） GRUB 配置文件 注意事项：不要删除此目录中的文件 dev (Device) 用途：存放设备文件 类型： 块设备（b）：如硬盘（devsda）、光驱 字符设备（c）：如终端（devtty）、键盘 伪设备：如 devnull（黑洞）、devzero（零字节）、devrandom（随机数）、devurandom 常用设备文件： /dev/sda # 第一块SCSI/SATA硬盘/dev/sda1 # 第一块硬盘的第一个分区/dev/nvme0n1 # 第一块NVMe硬盘/dev/cdrom # 光驱（符号链接）/dev/tty1 # 第一个虚拟终端/dev/console # 系统控制台/dev/null # 黑洞（写入的数据消失）/dev/zero # 提供无限零字节/dev/random # 真随机数（阻塞式）/dev/urandom # 伪随机数（非阻塞） etc (Editable Text Configuration) 用途：存放系统配置文件 特点：纯文本格式，可编辑 重要配置文件： /etc/passwd # 用户账户信息/etc/shadow # 用户密码（加密）/etc/group # 群组信息/etc/gshadow # 群组密码/etc/hosts # 主机名到IP的映射/etc/resolv.conf # DNS配置/etc/fstab # 文件系统挂载表/etc/hosts.allow # 允许访问的服务/etc/hosts.deny # 拒绝访问的服务/etc/ssh/sshd_config # SSH服务器配置/etc/crontab # 系统定时任务/etc/profile # 系统环境变量/etc/bash.bashrc # 系统bash配置/etc/apt/sources.list # 软件源（Debian/Ubuntu）/etc/yum.repos.d/ # 软件源（RHEL/CentOS）/etc/selinux/config # SELinux配置 home 用途：普通用户的主目录 结构：/home/├── alice/ # 用户alice的主目录├── bob/ # 用户bob的主目录└── charlie/ # 用户charlie的主目录 环境变量：$HOME 或 ~ 指向当前用户的主目录 注意：root 用户的主目录是 /root，不在 /home 下 用户主目录中的常见文件： ~/.bashrc # bash配置~/.bash_profile # 登录bash配置~/.profile # 通用shell配置~/.bash_history # 命令历史~/.bash_logout # 退出bash时执行~/.ssh/ # SSH配置目录~/.vimrc # vim配置~/.gitconfig # git配置~/.config/ # 现代应用的配置目录~/.local/ # 用户本地数据~/.cache/ # 缓存数据 lib, lib64, lib32 用途：存放共享库文件（Shared Libraries） 内容： 动态链接库（.so 文件，如 libc.so.6） 内核模块 启动所需的库 目录说明： /lib：32位和通用的库 /lib64：64位库（在64位系统上） /lib32：32位库（在32位系统上） 常见库文件： /lib/x86_64-linux-gnu/libc.so.6 # C标准库/lib/x86_64-linux-gnu/libm.so.6 # 数学库/lib/x86_64-linux-gnu/libdl.so.2 # 动态链接库/lib/x86_64-linux-gnu/libpthread.so.0 # 线程库/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 # 动态链接器/lib/modules/ # 内核模块 查看程序依赖的库： ldd /bin/ls # 查看ls命令依赖的库ldd /usr/bin/python3 # 查看python3依赖的库 media 和 mnt 用途：挂载点（Mount Points） 区别： /media：系统自动挂载的可移动设备（U盘、光盘、移动硬盘） /mnt：手动挂载临时文件系统的传统挂载点 现代趋势：/media 越来越常用，/mnt 更多用于临时手动挂载 查看挂载的文件系统： mount # 显示所有挂载点df -h # 查看磁盘使用情况lsblk # 列出块设备blkid # 查看块设备UUID opt 用途：存放可选的应用程序包 内容：通常是第三方商业软件或大型独立软件 特点： 每个软件有自己的子目录 不依赖于系统包管理器 可以方便地安装和卸载 典型结构： /opt/├── google/│ └── chrome/ # Google Chrome├── vscode/ # Visual Studio Code├── node-v14.x.x/ # Node.js└── some-app/ ├── bin/ ├── lib/ └── conf/ proc 用途：虚拟文件系统，提供进程和内核信息 特点： 不占用磁盘空间，存在于内存中 实时反映系统状态 许多文件是只读的 重要文件和目录： /proc/cpuinfo # CPU信息cat /proc/cpuinfo | grep model name | head -1/proc/meminfo # 内存信息/proc/loadavg # 系统负载/proc/uptime # 系统运行时间/proc/version # 内核版本/proc/cmdline # 内核启动参数/proc/filesystems # 支持的文件系统/proc/partitions # 分区信息/proc/swaps # 交换分区信息/proc/net/ # 网络信息/proc/sys/ # 内核参数（可调整）/proc/PID/ # 进程信息（PID为进程ID） 查看进程信息： ls /proc/$$ # 查看当前shell的信息ls /proc/1/ # 查看init/systemd进程# 进程目录中的文件/proc/PID/cmdline # 启动命令/proc/PID/cwd # 当前工作目录（符号链接）/proc/PID/environ # 环境变量/proc/PID/exe # 可执行文件（符号链接）/proc/PID/fd/ # 打开的文件描述符/proc/PID/maps # 内存映射/proc/PID/status # 进程状态/proc/PID/task/ # 线程信息 通过 proc 调整内核参数： # 查看当前值cat /proc/sys/net/ipv4/ip_forward# 临时修改（重启失效）echo 1 /proc/sys/net/ipv4/ip_forward# 永久修改（写入配置文件）echo net.ipv4.ip_forward = 1 /etc/sysctl.confsysctl -p # 重新加载配置 root 用途：root 用户的主目录 为什么单独： root 是超级管理员，拥有最高权限 为了安全，与其他用户主目录分开 系统故障时，其他分区可能无法挂载，但 root 在根分区上始终可用 路径：/root（不是 /home/root） 权限：通常是 700 (drwx——)，只有 root 能访问 run 用途：存放运行时变量数据 内容： 进程 PID 文件（runnginx.pid） 服务状态信息 运行时生成的临时数据 特点： tmpfs 文件系统（内存中） 重启后清空 早期在 varrun，现在迁移到 run 相关路径： /run /var/run（符号链接） /run/lock /var/lock sbin 用途：存放系统管理命令 与 bin 的区别： /bin：基本命令，所有用户都需要 /sbin：系统管理命令，通常需要 root 权限 内容： fdisk、mkfs：磁盘分区格式化 ifconfig、ip：网络配置 reboot、shutdown、poweroff：关机重启 iptables：防火墙配置 srv 用途：存放服务提供的数据 内容： Web 服务器的数据（srvwww） FTP 服务器的数据（srvftp） Git 仓库（srvgit） 与 var 的区别： /srv：服务的数据文件 /var：运行时产生的可变数据（日志、缓存等） sys 用途：虚拟文件系统，提供内核参数和设备信息 与 proc 的区别： /proc：进程信息和运行时内核数据 /sys：设备和内核对象的统一视图（sysfs） 内容： /sys/class/ # 按类别组织的设备（块设备、网络接口等）/sys/devices/ # 设备树/sys/block/ # 块设备/sys/bus/ # 总线信息（PCI、USB等）/sys/kernel/ # 内核配置和状态/sys/module/ # 已加载的内核模块/sys/power/ # 电源管理/sys/fs/ # 文件系统信息 常用操作： # 查看CPU信息ls /sys/devices/system/cpu/cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor# 查看内存信息cat /sys/devices/system/memory/memory0/state# 查看块设备ls /sys/block/cat /sys/block/sda/size # 块数（乘以512得字节数）# 控制LED（如果有的话）echo 1 /sys/class/leds/input0::capslock/brightness 通过 sys 调整内核参数： # 开启/关闭IP转发（临时，重启失效）echo 1 /proc/sys/net/ipv4/ip_forward# 或sysctl -w net.ipv4.ip_forward=1# 修改swappinesssysctl -w vm.swappiness=10 tmp 用途：存放临时文件 特点： 所有用户都有读写权限（通常是 777 + sticky bit 1777） 定期清理（通常每天或重启时） 可能使用 tmpfs（内存文件系统） 使用场景： 程序运行时的临时数据 下载和解压文件 编译过程中的临时文件 usr (Unix System Resources) 用途：存放用户程序和文件 含义：历史上是 “user” 的缩写，现在是 “Unix System Resources” 结构： /usr/├── bin/ # 用户命令（非基本命令）├── include/ # C/C++ 头文件├── lib/ # 库文件├── lib64/ # 64位库文件├── libexec/ # 其他程序运行的程序├── local/ # 本地安装的软件│ ├── bin/│ ├── etc/│ ├── include/│ ├── lib/│ ├── sbin/│ └── share/├── sbin/ # 非基本的系统管理命令├── share/ # 架构无关的数据文件│ ├── doc/ # 文档│ ├── man/ # 手册页│ ├── info/ # info文档│ └── ...└── src/ # 源代码（可选） 重要子目录： /usr/bin：用户命令，比 /bin 更丰富（如 gcc, python, vim） /usr/sbin：系统管理命令，比 /sbin 更丰富（如 apachectl, mysqld） /usr/lib：程序的库文件 /usr/share：与架构无关的共享数据（文档、图标、字体等） /usr/local：本地安装的软件，与系统包管理器分开 var (Variable) 用途：存放运行时产生的可变数据 特点：数据会随时间增长或变化 内容： /var/├── cache/ # 缓存数据│ ├── apt/ # apt缓存│ └── ...├── lib/ # 可变状态数据│ ├── dpkg/ # dpkg状态│ ├── mysql/ # MySQL数据│ ├── docker/ # Docker数据│ └── ...├── log/ # 日志文件（重要！）│ ├── syslog # 系统日志│ ├── auth.log # 认证日志│ ├── kern.log # 内核日志│ ├── nginx/ # Nginx日志│ └── ...├── mail/ # 用户邮件├── run/ # 运行时数据（PID文件等）├── spool/ # 队列数据│ ├── cron/ # cron任务│ ├── mail/ # 邮件队列│ └── ...└── tmp/ # 临时文件（重启保留） 重要子目录： /var/log：日志文件，排查问题的重要依据 /var/lib：程序的运行时数据（如数据库文件） /var/cache：缓存数据，可清理以释放空间 /var/spool：队列数据（如邮件队列、打印队列） 路径与目录操作绝对路径与相对路径绝对路径 (Absolute Path)： 从根目录 / 开始的完整路径 不管当前在什么位置，都能准确找到 示例：/home/user/documents/file.txt 相对路径 (Relative Path)： 相对于当前目录的路径 不从 / 开始 依赖当前所在位置 符号 含义 . 当前目录 .. 上级目录 ~ 当前用户的主目录 ~username 指定用户的主目录 - 上一次所在的目录 相对路径示例： # 当前目录：/home/user./file.txt # 当前目录下的 file.txt → /home/user/file.txt../etc/passwd # 上级目录的 etc/passwd → /home/etc/passwd （错误）../../etc/passwd # 上两级目录的 etc/passwd → /etc/passwd~/documents # 主目录下的 documents → /home/user/documents~alice/public # alice 主目录下的 public 路径切换命令cd - 切换目录 cd /path/to/directory # 切换到绝对路径cd relative/path # 切换到相对路径cd ~ # 切换到主目录cd # 同上cd ~username # 切换到指定用户的主目录cd .. # 切换到上级目录cd ../.. # 切换到上上级目录cd - # 切换到上次所在的目录pwd # 显示当前路径 pwd - 显示当前路径 pwd # 显示逻辑路径（可能包含符号链接）pwd -P # 显示物理路径（解析所有符号链接） 目录操作命令mkdir - 创建目录 mkdir dirname # 创建单个目录mkdir dir1 dir2 dir3 # 创建多个目录mkdir -p parent/child/grandchild # 递归创建多级目录mkdir -m 755 mydir # 创建时指定权限mkdir -v dirname # 显示创建过程 rmdir - 删除空目录 rmdir dirname # 删除空目录rmdir -p parent/child # 递归删除空目录rmdir dir1 dir2 # 删除多个空目录 ⚠️ 注意： rmdir 只能删除空目录。要删除非空目录，使用 rm -r。 rm - 删除文件或目录 rm file.txt # 删除文件rm -r directory # 递归删除目录及其内容rm -rf directory # 强制递归删除（危险！）rm -i file.txt # 删除前询问rm -f file.txt # 强制删除（忽略不存在文件）rm *.log # 删除所有log文件rm -r * # 删除当前目录下所有内容（危险！） ⚠️ 危险命令警告： rm -rf / # 删除整个系统！永远不要执行！rm -rf /* # 同上rm -rf ~ # 删除主目录rm -rf . # 删除当前目录rm -rf .* # 删除所有隐藏文件和上级目录！ 文件与目录的默认权限umaskumask（user file-creation mode mask）决定了新创建文件和目录的默认权限。 查看 umask： umask # 显示umask值（四位八进制数）umask -S # 以符号模式显示 默认权限计算： 文件：666 - umask 目录：777 - umask 常见 umask 值： umask 文件权限 目录权限 说明 002 664 (rw-rw-r–) 775 (rwxrwxr-x) 用户和组可写 022 644 (rw-r–r–) 755 (rwxr-xr-x) 仅用户可写（常见） 077 600 (rw——-) 700 (rwx——) 仅用户可访问（安全） 设置 umask： umask 022 # 设置umask为022umask 027 # 更严格：组可读，其他人无权限 永久设置 umask：编辑 ~/.bashrc 或 ~/.profile： echo umask 022 ~/.bashrc 特殊权限的实践应用1. SUID 应用：passwd 命令ls -l /usr/bin/passwd# -rwsr-xr-x 1 root root ... /usr/bin/passwd 为什么需要 SUID？ 普通用户需要修改自己的密码 密码存储在 /etc/shadow，只有 root 可写 通过 SUID，passwd 以 root 身份运行，可以修改 shadow 文件 2. SGID 应用：共享目录# 创建共享目录sudo mkdir /sharedsudo chown :developers /sharedsudo chmod 2775 /sharedls -ld /shared# drwxrwsr-x 2 root developers ... /shared 效果： 任何人在此目录创建的文件，群组都是 developers 实现组内文件共享 3. 粘滞位应用：tmp 目录ls -ld /tmp# drwxrwxrwt 10 root root ... /tmp 效果： 所有人都可以在 tmp 读写文件 但只能删除自己创建的文件 保护了用户的临时文件不被他人删除 权限管理最佳实践1. 最小权限原则 只授予必要的权限 不要滥用 root 权限 使用 sudo 而不是直接登录 root 2. 敏感文件权限# 密码文件chmod 600 /etc/shadowchmod 644 /etc/passwd# SSH 密钥chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pubchmod 644 ~/.ssh/authorized_keyschmod 644 ~/.ssh/known_hosts# 配置文件chmod 644 /etc/hostschmod 755 /etc/init.d/* 3. 目录权限设置# Web 目录chmod 755 /var/www/htmlchmod 644 /var/www/html/*.html# 日志目录chmod 755 /var/logchmod 640 /var/log/*.log# 共享目录（SGID）chmod 2770 /shared 4. 使用 ACL 进行细粒度控制# 允许特定用户访问setfacl -m u:alice:r-x /restricted# 允许特定组读写setfacl -m g:developers:rw- shared_file# 设置默认ACL（新文件继承）setfacl -d -m u:bob:rwx /shared_dir 5. 定期审计权限# 查找SUID/SGID文件find / -perm -4000 -o -perm -2000 2/dev/null# 查找所有人可写的文件find / -type f -perm -002 2/dev/null# 查找没有所有者的文件find / -nouser -o -nogroup 2/dev/null# 检查SSH密钥权限find /home -name id_rsa ! -perm 600 2/dev/null 本章命令总结 命令 功能 ls -l 查看文件权限 chmod 修改权限 chown 修改所有者 chgrp 修改群组 umask 设置默认权限 id 查看用户信息 whoami 显示当前用户 groups 查看所属群组 getfacl setfacl 管理ACL lsattr chattr 管理隐藏属性 find 查找文件（支持按权限查找） 5.4 重点回顾 三种身份：user（所有者）、group（群组）、others（其他人） 三种权限：r（读，4）、w（写，2）、x（执行，1） 权限查看：ls -l 显示10位权限字符串 修改权限：chmod（符号模式或数字模式） 修改所有者：chown（可同时改群组） 修改群组：chgrp（或 chown :group） 默认权限：umask 决定新文件的默认权限 特殊权限：SUID(4)、SGID(2)、粘滞位(1) 隐藏属性：chattr、lsattr ACL：setfacl、getfacl 提供更细粒度的权限控制 FHS标准：Linux 目录结构遵循 FHS 标准 重要目录：etc（配置）、var（可变数据）、home（用户主目录） 5.5 本章练习 解释 -rwxr-xr-- 1 alice developers 1234 Jan 1 10:00 script.sh 中各字段的含义。 如何给文件添加执行权限？如何移除写权限？分别使用符号模式和数字模式。 创建一个目录，使得组内成员可以读写，其他人只能进入但不能列出内容。 解释 SUID、SGID 和粘滞位的作用，并各举一个应用场景。 设置 umask 使得新建文件的权限为 640，新建目录的权限为 750。 使用 ACL 允许特定用户访问你主目录下的某个文件，但不改变文件的基本权限。 解释以下目录的用途：etc、var、usr、opt、proc。 查找系统中所有设置了 SUID 位的文件。 创建一个共享目录，要求： 任何人都可以创建文件 只能删除自己的文件 新文件的群组自动继承目录的群组 检查你主目录下文件的权限，找出可能存在安全隐患的文件（如所有人可写）。 5.6 参考资料与延伸阅读 man 1 chmod man 1 chown man 1 ls man 2 umask man 1 getfacl Filesystem Hierarchy Standard Linux 文件权限详解 鸟哥的 Linux 私房菜 - 文件权限与目录配置","tags":[null,null,null]},{"title":"第七章、Linux 磁盘与文件系统管理","path":"/notes/linux/ch07-filesystem.html","content":"第七章、Linux 磁盘与文件系统管理7.1 认识 Linux 文件系统文件系统的特性什么是文件系统 文件系统是操作系统用于管理磁盘上的文件的方法和数据结构。它定义了文件的存储方式、命名规则、访问权限等。 Linux 支持的文件系统类型： 文件系统 特点 适用场景 ext2 传统 Linux 文件系统，无日志 简单嵌入式系统 ext3 ext2 + 日志功能 过渡使用 ext4 现代标准，高性能，大容量支持 通用场景，推荐 xfs 高性能，大文件支持，并行 IO 大数据，数据库 btrfs 现代特性：快照、压缩、多设备 高级用户 swap 交换分区文件 虚拟内存 vfatfat32 Windows 兼容 UEFI、移动设备 ntfs Windows 文件系统 双系统数据共享 nfs 网络文件系统 文件共享 cifssmb Windows 网络共享 Samba 共享 ext4 文件系统详解ext4 的主要特性： 更大的文件系统和文件 最大文件系统：1EB (Exabyte) 最大文件大小：16TB Extents 存储方式 代替传统的块映射，提高大文件性能 减少碎片 日志校验和 (Journal Checksums) 提高日志可靠性 向后兼容 可以挂载为 ext2ext3 延迟分配 (Delayed Allocation) 提高性能，减少碎片 ext4 关键参数： # 查看 ext4 文件系统信息dumpe2fs /dev/sda1# 调整文件系统参数tune2fs -l /dev/sda1# 启用/禁用日志# ext4 默认启用日志# 调整预留块数（默认5%）tune2fs -m 1 /dev/sda1 # 预留1%给 root XFS 文件系统详解XFS 的主要特性： 高性能 优化的并行 IO 适合大文件和高吞吐量 可扩展性 在线扩展（无需卸载） 最大支持 8EB 文件系统 日志结构 元数据日志 快速恢复 分配组 (Allocation Groups) 提高并行性 独立管理空间 XFS 管理命令： # 创建 XFS 文件系统mkfs.xfs /dev/sdb1# 创建带标签的 XFSmkfs.xfs -L Data /dev/sdb1# 查看 XFS 信息xfs_info /dev/sdb1# 扩展 XFS 文件系统（在线）xfs_growfs /mnt/data# 修复 XFSxfs_repair /dev/sdb1xfs_repair -n /dev/sdb1 # 只检查不修复 XFS vs ext4 选择建议： 场景 推荐文件系统 通用桌面系统 ext4 小型服务器 ext4 大型数据库 XFS 大数据处理 XFS 视频多媒体存储 XFS 虚拟化存储 XFS 容器镜像存储 XFS 7.2 文件系统的简单操作磁盘与目录的容量df 命令 - 查看文件系统磁盘空间： # 基本用法df # 显示所有文件系统df -h # 人类可读格式（推荐）df -H # 使用1000而非1024为基底df -T # 显示文件系统类型df -i # 显示inode使用情况df -l # 仅显示本地文件系统df -x tmpfs # 排除特定类型df /home # 查看特定目录所在分区# 常用组合df -hT # 人类可读 + 文件系统类型df -h | grep -E (Filesystem|/dev/) # 过滤显示 du 命令 - 查看目录文件大小： # 基本用法du # 显示目录及子目录大小du -h # 人类可读格式du -s # 仅显示总计（不显示子目录）du -sh /path # 查看目录总大小（最常用）du -a # 显示文件和目录du --max-depth=1 /path # 只显示一层子目录du --max-depth=2 /path # 只显示两层子目录# 常用组合du -sh /* 2/dev/null | sort -h # 查看根目录下各文件夹大小du -sh /home/* 2/dev/null | sort -hr | head -10 # 查看home下最大的10个用户du -ah /path | sort -hr | head -20 # 找出最大的20个文件/目录du -h --max-depth=1 /var | sort -h # 查看/var下各子目录大小# 排除特定目录du -sh --exclude=*.log /var/logdu -sh --exclude=node_modules /project ln 命令 - 创建链接文件： # 硬链接（Hard Link）ln original.txt hardlink.txt # 同一文件系统的硬链接ln /path/to/file /another/path/link# 软链接/符号链接（Symbolic Link）ln -s original.txt symlink.txt # 最常用的链接ln -s /path/to/file /path/to/linkln -s /path/to/directory /path/to/linkname# 选项-f # 强制，如果目标存在则覆盖-i # 交互，覆盖前询问-v # 详细模式，显示操作过程-n # 将符号链接视为普通文件-s # 创建符号链接# 常用示例ln -s /usr/local/bin/myapp /usr/bin/myapp # 添加到PATHln -s /mnt/data/docs ~/Documents # 链接到数据盘ln -s ~/dotfiles/.bashrc ~/.bashrc # 管理配置文件ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 设置时区# 查看链接ls -l # 显示链接指向readlink symlink.txt # 读取符号链接的目标readlink -f symlink.txt # 递归解析到最终目标 硬链接 vs 软链接： 特性 硬链接 软链接（符号链接） 本质 同一文件的不同名字 指向另一个文件目录的快捷方式 inode 相同 不同 跨文件系统 不支持 支持 链接目录 不支持 支持 原文件删除 数据仍然存在 链接失效（悬空链接） 大小 与源文件相同 很小（路径长度） 用途 文件备份、防止误删 快捷方式、版本管理、系统配置 7.3 磁盘的分区、格式化、检验与挂载分区操作lsblk - 列出块设备： lsblk # 基本列出lsblk -a # 显示空设备lsblk -f # 显示文件系统lsblk -m # 显示权限和所有者lsblk -o NAME,SIZE,FSTYPE,MOUNTPOINT,MODELlsblk -p # 显示完整路径lsblk -t # 显示拓扑lsblk -b # 以字节为单位lsblk --tree # 树形显示lsblk -d # 不显示从设备# 常用组合lsblk -fpm # 完整路径 + 文件系统 + 权限watch -n 1 lsblk # 实时监控 blkid - 查看块设备属性： blkid # 显示所有块设备blkid /dev/sda1 # 查看特定设备blkid -U UUID # 根据UUID查找设备blkid -L LABEL # 根据标签查找设备blkid -t TYPE=ext4 # 根据类型查找blkid -o device -t UUID=xxx # 只输出设备名blkid -o export /dev/sda1 # 导出为环境变量格式# 常用示例blkid | grep ext4 # 查找ext4文件系统blkid -o export | grep UUID # 列出所有UUID 格式化（创建文件系统）mkfs 系列命令： # 通用格式mkfs -t type devicemkfs.type device # 等效命令# ext4 文件系统mkfs.ext4 /dev/sdb1mkfs -t ext4 /dev/sdb1mke2fs -t ext4 /dev/sdb1# 常用选项mkfs.ext4 -L Data /dev/sdb1 # 设置卷标mkfs.ext4 -N 1000000 /dev/sdb1 # 指定inode数量mkfs.ext4 -m 1 /dev/sdb1 # 保留1%空间给rootmkfs.ext4 -E stride=128 /dev/sdb1 # RAID优化mkfs.ext4 -O ^metadata_csum /dev/sdb1 # 禁用元数据校验# xfs 文件系统mkfs.xfs /dev/sdb1mkfs -t xfs /dev/sdb1# 常用选项mkfs.xfs -L Data /dev/sdb1 # 设置卷标mkfs.xfs -f /dev/sdb1 # 强制格式化（覆盖）mkfs.xfs -d agcount=4 /dev/sdb1 # 分配组数量mkfs.xfs -l size=128m /dev/sdb1 # 日志大小mkfs.xfs -n size=64k /dev/sdb1 # 命名空间大小# vfat/fat32（用于 UEFI 启动分区）mkfs.vfat -F 32 /dev/sda1mkfs.fat -F 32 -n EFI /dev/sda1# 其他文件系统mkfs.btrfs /dev/sdb1mkfs.jfs /dev/sdb1mkfs.reiserfs /dev/sdb1# 创建交换分区mkswap /dev/sda3mkswap -L Swap /dev/sda3swapon /dev/sda3 # 启用交换swapoff /dev/sda3 # 关闭交换 检验文件系统fsck - 文件系统检查： # 基本用法（危险：检查前必须先卸载！）# 检查并修复ext4fsck.ext4 /dev/sda1# 或e2fsck /dev/sda1# 检查xfs（注意：xfs使用xfs_repair）xfs_repair /dev/sdb1# 常用选项fsck -t ext4 /dev/sda1 # 指定类型fsck -A # 检查/etc/fstab中的所有fsck -a # 自动修复（不询问）fsck -r # 交互式修复fsck -n # 只检查不修复（模拟运行）fsck -f # 强制检查（即使看起来干净）fsck -v # 详细模式fsck -y # 对所有问题回答是（危险！）# 实际操作示例（必须卸载后检查）# 对于根分区，需要进入救援模式或使用Live CDumount /dev/sda1fsck -f /dev/sda1# 如果检查根分区，使用：shutdown -rF now # 重启并强制检查# 创建包含坏块的列表e2fsck -c /dev/sda1 # 只读扫描e2fsck -cc /dev/sda1 # 非破坏性读写测试（慢）# 检查并修复xfsxfs_repair /dev/sdb1 # 必须卸载xfs_repair -n /dev/sdb1 # 只检查xfs_repair -L /dev/sdb1 # 强制修复（可能丢失数据）xfs_repair -o force_geometry /dev/sdb1# 检查日志xfs_logprint /dev/sdb1 坏块检测与处理： # 检测坏块badblocks -s -v /dev/sda1 # 只读检测badblocks -s -w -v /dev/sda1 # 破坏性读写检测（会擦除数据！）# 保存坏块列表badblocks -s -v -o badblocks.list /dev/sda1# 使用坏块列表创建文件系统mkfs.ext4 -l badblocks.list /dev/sda1# 或使用 e2fsck 标记坏块e2fsck -l badblocks.list /dev/sda1 挂载文件系统基本挂载： # 基本挂载mount /dev/sdb1 /mnt/data# 指定文件系统类型mount -t ext4 /dev/sdb1 /mnt/datamount -t ntfs /dev/sdb2 /mnt/windowsmount -t vfat /dev/sdc1 /mnt/usb# 常用选项-o ro # 只读挂载-o rw # 读写挂载-o noatime # 不更新访问时间-o nodiratime # 不更新目录访问时间-o sync # 同步写入-o async # 异步写入-o auto # 可被 auto 挂载-o noauto # 不可被 auto 挂载-o user # 允许普通用户挂载-o nouser # 只允许 root 挂载-o exec # 允许执行文件-o noexec # 禁止执行文件-o suid # 允许 SUID/SGID-o nosuid # 禁止 SUID/SGID-o remount # 重新挂载-o bind # 绑定挂载# 示例mount -o ro,remount / # 以只读方式重新挂载根分区mount -o noatime /dev/sdb1 /mnt/datamount -o uid=1000,gid=1000 /dev/sdc1 /mnt/usb# 绑定挂载（将一个目录挂载到另一个位置）mount --bind /var/log /mnt/logsmount --rbind /home /chroot/home # 递归绑定# 移动挂载点mount --move /mnt/old /mnt/new 卸载文件系统： # 基本卸载umount /mnt/dataumount /dev/sdb1# 卸载时检查是否在使用中umount -f /mnt/data # 强制卸载（危险）umount -l /mnt/data # 懒卸载（立即生效，实际稍后执行）umount -r /mnt/data # 无法卸载时以只读重新挂载umount -a # 卸载 /etc/fstab 中所有文件系统umount -a -t ext4 # 卸载所有 ext4 文件系统# 处理 device is busy 错误# 1. 查找使用进程lsof /mnt/datafuser -mv /mnt/data# 2. 杀死进程（小心使用）fuser -km /mnt/data# 3. 然后重新卸载umount /mnt/data 自动挂载配置（etcfstab）： # fstab 格式说明# 设备 挂载点 文件系统 选项 dump fsck# 设备可以是：# - 设备路径：/dev/sda1# - UUID：UUID=xxxxx# - 标签：LABEL=Data# - 网络：//server/share# 常用选项：# defaults = rw, suid, dev, exec, auto, nouser, async# noatime - 不更新访问时间# nodiratime - 不更新目录访问时间# ro - 只读# rw - 读写# auto - 可以被自动挂载# noauto - 不会被自动挂载（可以用mount -a挂载）# user - 允许普通用户挂载# nouser - 只允许root挂载# exec - 允许执行文件# noexec - 不允许执行文件# sync - 同步写入# async - 异步写入# dump 字段：# 0 - 不备份# 1 - 每天备份# fsck 字段：# 0 - 不检查# 1 - 首先检查（根分区）# 2 - 随后检查（其他分区）# 示例配置# 根分区UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx / ext4 defaults,noatime 0 1# 启动分区UUID=yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy /boot ext4 defaults,noatime 0 2# 家目录UUID=zzzzzzzz-zzzz-zzzz-zzzz-zzzzzzzzzzzz /home ext4 defaults,noatime 0 2# 数据分区UUID=aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa /data ext4 defaults,noatime,noexec 0 2# 交换分区UUID=bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb none swap sw 0 0# 临时文件系统（内存中）tmpfs /tmp tmpfs defaults,nosuid,nodev,noexec 0 0# 绑定挂载/home/user/data /var/www/data none bind 0 0# NFS 网络文件系统server:/export/share /mnt/share nfs defaults,_netdev 0 0# CIFS/SMB Windows 共享//windows/share /mnt/winshare cifs credentials=/root/.smbcred,iocharset=utf8 0 0 获取 UUID 和标签： # 查看所有设备的 UUIDblkid# 查看特定设备blkid /dev/sda1# 查找 UUID 对应的设备blkid -U xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx# 查找标签对应的设备blkid -L Data# 为设备设置标签# ext2/3/4e2label /dev/sda1 Systemtune2fs -L System /dev/sda1# xfsxfs_admin -L Data /dev/sdb1# vfat/fat32fatlabel /dev/sdc1 USB_DRIVE# 查看标签e2label /dev/sda1xfs_admin -l /dev/sdb1 fstab 管理工具： # 测试 fstab 配置（不实际挂载）mount -fav# 查看 fstab 是否有错误findmnt --verify# 挂载 /etc/fstab 中的所有文件系统mount -a# 挂载特定类型的文件系统mount -a -t ext4mount -a -t nfs# 排除特定类型mount -a -t noext4# 显示当前挂载mount | column -tfindmntfindmnt -D # 显示目录树findmnt -f # 显示 fstab 配置# 显示挂载点信息findmnt /mnt/datafindmnt /dev/sdb1 7.4 设置开机挂载使用 etcfstab如前所述，/etc/fstab 是 Linux 系统中最常用的开机挂载配置方式。 使用 systemd mount 单元对于使用 systemd 的系统，可以使用 mount 单元来管理挂载： # 创建挂载单元文件sudo nano /etc/systemd/system/mnt-data.mount# 内容示例：[Unit]Description=Data partitionAfter=local-fs.target[Mount]What=/dev/disk/by-uuid/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxWhere=/mnt/dataType=ext4Options=defaults,noatime[Install]WantedBy=multi-user.target# 创建自动挂载单元（可选）sudo nano /etc/systemd/system/mnt-data.automount[Unit]Description=Automount Data partition[Automount]Where=/mnt/data[Install]WantedBy=multi-user.target# 启用并启动sudo systemctl daemon-reloadsudo systemctl enable mnt-data.mountsudo systemctl start mnt-data.mount# 查看状态sudo systemctl status mnt-data.mount# 自动挂载sudo systemctl enable mnt-data.automountsudo systemctl start mnt-data.automount 7.5 内存交换空间（swap）的管理什么是 swapSwap（交换空间）是当物理内存不足时，系统用来临时存放数据的空间。可以是： 交换分区：专用的磁盘分区 交换文件：普通文件作为交换空间 查看 swap 状态# 查看 swap 使用情况free -hfree -m# 详细查看swapon -sswapon --showswapon --show=NAME,TYPE,SIZE,USED,PRIOcat /proc/swaps# 查看内存和 swap 实时使用vmstat 1 10watch -n 1 free -h 创建交换分区# 1. 创建分区（使用 fdisk 或 parted）sudo fdisk /dev/sdb# n - p - 回车 - 回车 - +8G - t - 82 - w# 2. 格式化 swapsudo mkswap /dev/sdb1sudo mkswap -L Swap /dev/sdb1 # 带标签# 3. 启用 swapsudo swapon /dev/sdb1# 4. 添加到 fstab 开机启用# 获取 UUIDsudo blkid /dev/sdb1# 添加到 /etc/fstabUUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx none swap sw 0 0# 或/dev/sdb1 none swap sw 0 0# 5. 测试 fstab 配置sudo swapon -a# 6. 设置 swap 优先级（多个 swap 时）sudo swapon -p 10 /dev/sdb1 # 优先级 10（越高越优先）# 在 fstab 中：UUID=xxx none swap sw,pri=10 0 0 创建交换文件# 方法 1：使用 dd（较慢）sudo dd if=/dev/zero of=/swapfile bs=1M count=8192 status=progress# 方法 2：使用 fallocate（更快）sudo fallocate -l 8G /swapfile# 设置权限（重要！）sudo chmod 600 /swapfile# 格式化为 swapsudo mkswap /swapfile# 启用sudo swapon /swapfile# 验证sudo swapon --showfree -h# 添加到 fstabsudo nano /etc/fstab# 添加：/swapfile none swap sw 0 0# 测试sudo swapoff -asudo swapon -a 调整 swappinessvm.swappiness 参数控制系统使用 swap 的倾向： # 查看当前值cat /proc/sys/vm/swappinesssysctl vm.swappiness# 临时修改sudo sysctl vm.swappiness=10# 永久修改sudo nano /etc/sysctl.conf# 添加：vm.swappiness=10# 重新加载配置sudo sysctl -p# 推荐值：# 0-20：服务器，尽可能避免使用 swap# 30-60：桌面系统，平衡使用# 60-100：对响应时间要求不高的系统 删除 swap# 交换分区sudo swapoff /dev/sdb1# 从 /etc/fstab 删除对应行sudo fdisk /dev/sdb # 删除分区# 交换文件sudo swapoff /swapfilesudo rm /swapfile# 从 /etc/fstab 删除对应行 7.6 文件系统的特殊查看与操作磁盘配额（Quota）用于限制用户或组对磁盘空间的使用。 # 安装 quota 工具sudo yum install quota# 1. 启用配额（编辑 /etc/fstab）# 添加 usrquota 和/或 grpquotaUUID=xxx /home ext4 defaults,usrquota,grpquota 0 0# 2. 重新挂载sudo mount -o remount /home# 3. 创建配额数据库sudo quotacheck -cug /home# -c = 创建# -u = 用户配额# -g = 组配额# -m = 不尝试重新挂载为只读# 4. 启用配额sudo quotaon /home# 5. 查看配额状态quota -v usernamerepquota /homerepquota -a# 6. 设置用户配额sudo edquota username# 或者使用命令行setquota -u username 0 0 0 0 /home# 7. 关闭配额sudo quotaoff /home# 常用检查命令quotacheck -avugm # 检查并修复配额repquota -aug # 报告所有用户和组的配额warnquota # 向超过配额的用户发送邮件 磁盘阵列（RAID）使用 mdadm 创建软件 RAID： # 安装 mdadmsudo yum install mdadm# 查看现有 RAIDcat /proc/mdstatmdadm --detail /dev/md0# 创建 RAID 0（条带，性能最高，无冗余）mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdb1 /dev/sdc1# 创建 RAID 1（镜像，冗余，容量减半）mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/sdb1 /dev/sdc1# 创建 RAID 5（分布式奇偶校验，容错1块盘）mdadm --create /dev/md0 --level=5 --raid-devices=3 /dev/sdb1 /dev/sdc1 /dev/sdd1# 创建 RAID 6（双分布式奇偶校验，容错2块盘）mdadm --create /dev/md0 --level=6 --raid-devices=4 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1# 创建 RAID 10（镜像+条带）mdadm --create /dev/md0 --level=10 --raid-devices=4 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1# 创建后格式化mkfs.ext4 /dev/md0# 创建挂载点并挂载mkdir /mnt/raidmount /dev/md0 /mnt/raid# 添加到 fstabecho /dev/md0 /mnt/raid ext4 defaults 0 0 /etc/fstab# 保存 RAID 配置mdadm --detail --scan /etc/mdadm.conf# 或mdadm --detail --scan | sudo tee -a /etc/mdadm.conf# RAID 管理命令mdadm --detail /dev/md0 # 查看详情mdadm --stop /dev/md0 # 停止 RAIDcat /proc/mdstat # 查看状态mdadm --manage /dev/md0 --add /dev/sde1 # 添加热备盘mdadm --manage /dev/md0 --remove /dev/sdb1 --fail /dev/sdb1 # 标记故障并移除 逻辑卷管理（LVM）LVM 提供灵活的磁盘空间管理： # 安装 LVMsudo yum install lvm2# 查看 LVM 信息pvs # 查看物理卷vgs # 查看卷组lvs # 查看逻辑卷pvdisplayvgdisplaylvdisplay# 创建物理卷（PV）pvcreate /dev/sdb1pvcreate /dev/sdc1# 创建卷组（VG）vgcreate vg_data /dev/sdb1 /dev/sdc1# 扩展卷组vgextend vg_data /dev/sdd1# 创建逻辑卷（LV）lvcreate -L 50G -n lv_www vg_data # 指定大小lvcreate -l 100%FREE -n lv_backup vg_data # 使用所有剩余空间lvcreate -l 50%VG -n lv_data vg_data # 使用卷组50%空间lvcreate -s -n lv_snap -L 10G /dev/vg_data/lv_www # 创建快照# 格式化逻辑卷mkfs.ext4 /dev/vg_data/lv_www# 挂载mkdir -p /var/wwwmount /dev/vg_data/lv_www /var/www# 添加到 fstabecho /dev/mapper/vg_data-lv_www /var/www ext4 defaults,noatime 0 0 /etc/fstab# 扩展逻辑卷（在线，无需卸载）lvextend -L +50G /dev/vg_data/lv_www # 增加50Glvextend -L 100G /dev/vg_data/lv_www # 扩展到100Glvextend -l +100%FREE /dev/vg_data/lv_www # 使用所有剩余空间# 扩展文件系统resize2fs /dev/vg_data/lv_www # ext2/3/4xfs_growfs /var/www # xfs（挂载点）# 缩小逻辑卷（ext4，必须先卸载）umount /var/wwwe2fsck -f /dev/vg_data/lv_wwwresize2fs /dev/vg_data/lv_www 50Glvreduce -L 50G /dev/vg_data/lv_wwwmount /dev/vg_data/lv_www /var/www# 删除逻辑卷（先卸载，数据会丢失！）umount /var/wwwlvremove /dev/vg_data/lv_www# 删除卷组（先删除所有逻辑卷）vgchange -an vg_data # 停用卷组vgremove vg_data# 删除物理卷pvremove /dev/sdb1pvremove /dev/sdc1# LVM 快照（备份数据）# 创建快照lvcreate -s -n lv_snap -L 50G /dev/vg_data/lv_www# 挂载快照mkdir /mnt/snapmount /dev/vg_data/lv_snap /mnt/snap# 备份数据tar czf backup.tar.gz -C /mnt/snap .# 卸载并删除快照umount /mnt/snaplvremove /dev/vg_data/lv_snap# 恢复快照（如果原逻辑卷损坏）# 注意：恢复后快照会被删除# umount /var/www# lvconvert --merge /dev/vg_data/lv_snap# mount /dev/vg_data/lv_www /var/www 7.7 重点回顾 文件系统：ext4（通用）、xfs（大容量）、swap（交换分区） 分区工具：fdisk（MBR）、gdisk（GPT）、parted（两者） 格式化：mkfs.ext4、mkfs.xfs、mkswap 文件系统检查：fsck、e2fsck、xfs_repair 挂载：mount、umount、etcfstab 磁盘配额：quota 限制用户组的磁盘使用 RAID：mdadm 创建软件磁盘阵列 LVM：灵活的磁盘空间管理，支持在线扩容 swap：交换分区或交换文件，用于虚拟内存 性能优化：noatime、日志模式、RAID、LVM 等 7.8 本章习题 解释 ext4 和 xfs 文件系统的主要特点，什么情况下应该选择 xfs？ 如何查看当前系统的磁盘分区和使用情况？ 新添加了一块硬盘 devsdb，请描述创建分区、格式化、挂载和配置开机自动挂载的完整步骤。 什么是 LVM？使用 LVM 有什么好处？ 创建 RAID 1 阵列并配置为自动挂载的详细步骤是什么？ 如何检查和修复 ext4 文件系统的错误？ 系统内存不足，如何添加 swap 空间？描述创建 swap 文件的方法。 解释磁盘配额的作用，如何为用户设置磁盘配额限制？ 7.9 参考资料与延伸阅读 man mkfs man fsck man mount man lvm man mdadm man quota 鸟哥的 Linux 私房菜 - 磁盘与文件系统管理 LVM 指南 RAID 技术详解","tags":[null,null,null]},{"title":"第八章、文件与文件系统的压缩、打包与备份","path":"/notes/linux/ch08-compress.html","content":"第八章、文件与文件系统的压缩、打包与备份8.1 压缩文件的用途与技术为什么需要压缩 节省存储空间：压缩后的文件占用更少的磁盘空间 提高传输效率：网络传输时减少时间和带宽消耗 归档备份：将多个文件打包成单一文件便于管理 压缩的原理压缩通过消除数据中的冗余信息来减小文件大小： 无损压缩：可以完全恢复原始数据（gzip、bzip2、xz） 有损压缩：牺牲部分质量换取更高压缩率（jpeg、mp3） 8.2 Linux 系统常见的压缩指令常见压缩工具对比 工具 扩展名 压缩率 速度 特点 gzip .gz 中等 快 最常用，兼容性好 bzip2 .bz2 高 慢 压缩率优于 gzip xz .xz 最高 最慢 现代压缩标准 zip .zip 中等 快 Windows 兼容 compress .Z 低 快 已过时，很少使用 gzip 和 zcatgzip - 最流行的压缩工具： # 压缩文件（原始文件会被删除）gzip filename # 生成 filename.gz# 压缩时保留原始文件gzip -c filename filename.gz # 使用管道保留原文件gzip -k filename # 某些版本支持 -k (keep)# 解压缩gunzip filename.gz # 或 gzip -d filename.gz# 常用选项-1 ... -9 # 压缩级别，1最快/压缩率最低，9最慢/压缩率最高（默认6）-c # 输出到标准输出，不删除原文件-d # 解压缩-f # 强制，覆盖现有文件-h # 帮助-k # 保留原文件（非所有版本支持）-l # 列出压缩文件信息-L # 显示许可证-n # 不保存/恢复原始文件名和时间戳-N # 保存/恢复原始文件名和时间戳（默认）-q # 安静模式-r # 递归处理目录（压缩目录下所有文件）-t # 测试压缩文件的完整性-v # 详细模式-V # 显示版本# 示例gzip -9 -k largefile.txt # 最高压缩级别，保留原文件gzip -r /path/to/directory/ # 递归压缩目录下所有文件gzip -l file.gz # 查看压缩信息gzip -t file.gz # 测试文件完整性 zcatzmorezless - 不解压查看压缩文件： # 查看压缩文件内容（不解压）zcat file.gz # 等同于 cat，直接输出到屏幕zmore file.gz # 等同于 more，分页显示zless file.gz # 等同于 less，更好的分页zgrep pattern file.gz # 在压缩文件中搜索# zcat 也可以查看 .Z 文件（compress 格式）# 将 zcat 输出重定向gzcat file.gz output.txt # 解压到文件zcat file.gz | grep pattern # 管道处理 bzip2 和 bzcatbzip2 - 更高压缩率： # 压缩（默认删除原文件）bzip2 filename # 生成 filename.bz2# 保留原文件bzip2 -k filenamebzip2 -c filename filename.bz2# 解压缩bunzip2 filename.bz2 # 或 bzip2 -d filename.bz2# 常用选项-1 ... -9 # 压缩级别（默认9，压缩率最高但最慢）-c # 输出到标准输出-d # 解压缩-f # 强制-k # 保留原文件-s # 减少内存使用（较慢）-t # 测试完整性-v # 详细模式-z # 压缩（默认）# 示例bzip2 -9 -k largefile.txt # 最高压缩级别，保留原文件bzip2 -t file.bz2 # 测试文件完整性 bzcatbzmorebzlessbzgrep： # 不解压查看bzcat file.bz2 # 直接输出bzmore file.bz2 # 分页bzless file.bz2 # 更好的分页# 搜索bzgrep pattern file.bz2bzgrep pattern *.bz2 # 搜索多个文件 xz 和 xzcatxz - 最高压缩率（现代标准）： # 压缩（默认删除原文件）xz filename # 生成 filename.xz# 保留原文件xz -k filenamexz -c filename filename.xz# 解压缩unxz filename.xz # 或 xz -d filename.xz# 常用选项-0 ... -9 # 压缩级别（默认6，9是最佳但最慢）-e # 极致压缩（比-9更慢更好）-c # 输出到标准输出-d # 解压缩-f # 强制-k # 保留原文件-l # 列出压缩文件信息-t # 测试完整性-v # 详细模式-T NUM # 使用NUM个线程（多核加速）# 示例xz -9 -k largefile.txt # 最高压缩级别，保留原文件xz -T4 largefile.txt # 使用4个线程加速xz -e file.txt # 极致压缩xz -l file.xz # 查看压缩信息 xzcatxzmorexzlessxzgrep： # 不解压查看xzcat file.xz # 直接输出xzmore file.xz # 分页xzless file.xz # 更好的分页# 搜索xzgrep pattern file.xzxzgrep pattern *.xz 压缩工具对比示例# 创建测试文件dd if=/dev/zero of=test.file bs=1M count=100# 对比不同工具的压缩率和速度time gzip -k test.filetime bzip2 -k test.filetime xz -k test.file# 查看结果ls -lh test.file*# 压缩率对比（示例结果）：# 原始文件： 100M# gzip (.gz)： ~70M（最快）# bzip2 (.bz2)：~65M（较慢）# xz (.xz)： ~60M（最慢但压缩率最高） 8.3 打包指令：tartar 命令概述tar（Tape Archive）是 LinuxUnix 系统中最常用的归档工具，将多个文件或目录打包成单一文件（称为 tar 归档或 tarball），常与压缩工具结合使用。 tar 的特点： 保留文件的权限、所有者、时间戳等信息 支持多种压缩格式 可以增量备份 支持远程备份 tar 基本语法tar [选项] [归档文件] [文件或目录...] 常用选项操作模式（必须选其一）： 选项 功能 -c 创建新的归档文件 (create) -x 从归档中提取文件 (extract) -t 列出归档内容 (list) -r 追加文件到归档末尾 (append) -u 仅追加比归档中更新的文件 (update) -A 将另一个 tar 归档追加到当前归档 -d 比较归档和文件系统的差异 (diff) --delete 从归档中删除文件 常用通用选项： 选项 功能 -v 详细模式，显示处理过程 (verbose) -f 指定归档文件名，必须后跟文件名 -p 保留原始文件权限和属性 (preserve) -P 使用绝对路径（小心使用） -C 切换到指定目录再执行操作 -z 使用 gzip 压缩解压缩 (.gz) -j 使用 bzip2 压缩解压缩 (.bz2) -J 使用 xz 压缩解压缩 (.xz) --exclude 排除特定文件或目录 --exclude-from 从文件中读取排除列表 --files-from 从文件中读取要处理的文件列表 -h 显示帮助信息 --version 显示版本信息 tar 实战示例1. 创建归档： # 创建 tar 归档（不压缩）tar -cvf archive.tar /path/to/directory# 创建 tar.gz 归档（gzip 压缩，最常用）tar -czvf archive.tar.gz /path/to/directorytar -czvf backup-$(date +%Y%m%d).tar.gz ~/Documents# 创建 tar.bz2 归档（bzip2 压缩，压缩率更高）tar -cjvf archive.tar.bz2 /path/to/directory# 创建 tar.xz 归档（xz 压缩，压缩率最高）tar -cJvf archive.tar.xz /path/to/directory# 创建归档并排除特定文件或目录tar -czvf backup.tar.gz /home/user --exclude=*.log --exclude=*.tmp --exclude=cache# 从文件中读取排除列表tar -czvf backup.tar.gz /home/user --exclude-from=exclude.list# 只包含特定文件类型tar -czvf scripts.tar.gz /home/user --include=*.sh --include=*.py# 压缩多个目录或文件tar -czvf backup.tar.gz /etc/nginx /var/www /home/user/config# 保留权限和属性创建归档tar -czvpf backup.tar.gz --same-owner /important/data# 创建带时间戳的备份tar -czvf backup-$(date +%Y%m%d_%H%M%S).tar.gz /data# 只备份比某个时间更新的文件tar -czN 2024-01-01 -f recent.tar.gz /data# 创建压缩归档到远程服务器（使用管道和 SSH）tar -czf - /local/data | ssh user@remote cat /backup/data.tar.gz 2. 查看归档内容： # 列出 tar 归档内容tar -tvf archive.tar# 列出 tar.gz 归档内容tar -tzvf archive.tar.gz# 列出 tar.bz2 归档内容tar -tjvf archive.tar.bz2# 搜索归档中的特定文件tar -tzf archive.tar.gz | grep pattern# 查看归档中特定文件的详细信息tar -tvf archive.tar path/to/file# 递归列出目录内容tar -tvf archive.tar --wildcards *.txt 3. 解压归档： # 解压 tar 归档到当前目录tar -xvf archive.tar# 解压 tar.gz 归档到当前目录（最常用）tar -xzvf archive.tar.gztar -xzf archive.tar.gz # 不显示详细过程# 解压 tar.bz2 归档tar -xjvf archive.tar.bz2# 解压 tar.xz 归档tar -xJvf archive.tar.xz# 解压到指定目录tar -xzvf archive.tar.gz -C /path/to/destination# 解压特定文件tar -xzvf archive.tar.gz path/to/specific/file# 解压特定类型的文件tar -xzvf archive.tar.gz --wildcards *.txt# 解压并保留权限tar -xzvpf archive.tar.gz# 解压并恢复原始所有者（需要 root）sudo tar -xzvpf archive.tar.gz --same-owner# 解压时显示进度条tar -xvf archive.tar --checkpoint=1000 --checkpoint-action=echo=Extracted %u files# 解压到远程服务器cat archive.tar.gz | ssh user@remote tar -xzvf - -C /destination 4. 追加和更新归档： # 追加文件到现有 tar 归档（仅适用于未压缩的 tar）tar -rvf archive.tar newfile.txttar -rvf archive.tar /path/to/new/directory/# 更新归档中已存在的文件（只添加更新的文件）tar -uvf archive.tar updatedfile.txt# 追加归档到另一个归档（合并归档）tar -Af archive1.tar archive2.tar# 注意：不能直接追加到压缩归档（.gz/.bz2/.xz）# 需要先解压，追加，再压缩# 或使用管道（复杂，不推荐）# 示例：安全地追加到压缩归档gunzip archive.tar.gz # 解压tar -rvf archive.tar newfile # 追加gzip archive.tar # 重新压缩 5. 删除归档中的文件： # 从 tar 归档中删除文件（仅适用于未压缩的 tar）tar --delete -f archive.tar file_to_delete.txttar --delete -f archive.tar *.log# 删除多个文件tar --delete -f archive.tar file1 file2 file3# 注意：不能直接删除压缩归档中的文件# 需要先解压，删除，再压缩# 示例：从压缩归档中删除文件tar -xzvf archive.tar.gz # 解压到当前目录rm file_to_delete.txt # 删除文件tar -czvf new_archive.tar.gz * # 重新打包压缩 6. 从归档中提取特定文件： # 提取单个文件tar -xzvf archive.tar.gz path/to/file.txt# 提取多个文件tar -xzvf archive.tar.gz file1.txt file2.txt# 使用通配符提取tar -xzvf archive.tar.gz --wildcards *.txttar -xzvf archive.tar.gz --wildcards data/*.csv# 提取到特定目录tar -xzvf archive.tar.gz -C /destination/directory file.txt 7. 特殊用法： # 通过管道使用 tar# 备份到远程服务器# 方式1：tar + sshtar -czf - /local/dir | ssh user@remote cat /backup/backup.tar.gz# 方式2：使用 rsync（更推荐）rsync -avz /local/dir/ user@remote:/backup/# 从远程服务器恢复cat backup.tar.gz | ssh user@remote cat - | tar -xzf -# 使用 tar 进行增量备份# 创建快照文件tar -czf backup-full.tar.gz --listed-incremental=snapshot.file /data# 创建增量备份（只备份变化的文件）tar -czf backup-incr.tar.gz --listed-incremental=snapshot.file /data# 合并多个归档cat archive1.tar archive2.tar combined.tar# 分割大归档tar -czvf - /large/directory | split -b 1G - backup.tar.gz.# 会产生 backup.tar.gz.aa, backup.tar.gz.ab, ...# 合并分割的归档cat backup.tar.gz.* | tar -xzvf -# 创建带有绝对路径的归档（小心使用）tar -czPvf backup.tar.gz /etc /var/log# 排除特定文件或目录tar -czvf backup.tar.gz /home --exclude=*.mp4 --exclude=cache --exclude-vcs 压缩工具详解gzip 详解# 压缩级别测试# 准备测试文件dd if=/dev/urandom of=testfile bs=1M count=100# 不同压缩级别for level in 1 6 9; do time gzip -$level -c testfile testfile.gz.$level ls -lh testfile.gz.$leveldone# 查看压缩文件信息gzip -l testfile.gz# 输出：# compressed uncompressed ratio uncompressed_name# 102400 1048576 90.2% testfile# 递归压缩目录中的所有文件（保留目录结构，但不打包）find /path/to/dir -type f -exec gzip \\;# 或者find /path/to/dir -type f | xargs gzip bzip2 详解# bzip2 通常比 gzip 压缩率更高但速度更慢# 对比测试for tool in gzip bzip2; do echo Testing $tool... time $tool -k testfile ls -lh testfile.* $tool -d testfile.*done# bzip2 的恢复功能（用于损坏的文件）bzip2recover corrupted.bz2# bzip2 使用块压缩，可以并行处理（使用 pbzip2）pbzip2 -p4 file # 使用4个线程 xz 详解# xz 提供最高的压缩率，但速度最慢# 压缩级别对比（0-9，默认6）for level in 0 6 9; do echo Testing xz -$level... time xz -$level -k -c testfile testfile.xz.$level ls -lh testfile.xz.$leveldone# xz 多线程压缩（更快）xz -T4 file # 使用4个线程pxz -9 file # 使用全部核心# xz 格式信息xz -l file.xz # 列出压缩信息xz -t file.xz # 测试完整性# 不同的压缩预设xz --lzma2=preset=9,dict=64MiB file # 使用大字典获得更好压缩率 现代压缩工具zstd - 快速压缩# 安装sudo yum install zstd # CentOS/RHELsudo apt install zstd # Debian/Ubuntu# zstd 提供极快的压缩和解压速度# 不同压缩级别（1-19，默认3，超高质量22）zstd -1 file # 快速压缩zstd -9 file # 高质量压缩zstd -19 file # 极致压缩zstd --ultra -22 file # 超高质量# 多线程zstd -T4 file # 4线程zstd -T0 file # 自动使用所有核心# 解压zstd -d file.zstunzstd file.zst# 其他工具zstdcat file.zst # 不解压查看zstdgrep pattern file.zstzstdless file.zst# 对比测试for level in 1 3 9; do time zstd -$level -k -c testfile testfile.zst.$level ls -lh testfile.zst.$leveldone pigz - 并行 gzip# 安装sudo yum install pigz# pigz 是 gzip 的并行实现，使用多核加速压缩pigz file # 压缩（使用所有核心）pigz -p 4 file # 使用4个进程unpigz file.gz # 解压# 保持与 gzip 兼容的选项 pbzip2 - 并行 bzip2# 安装sudo yum install pbzip2# pbzip2 是 bzip2 的并行实现pbzip2 file # 压缩（使用所有核心）pbzip2 -p4 file # 使用4个进程pbzip2 -d file.bz2 # 解压 压缩性能对比测试脚本#!/bin/bash# compression_benchmark.shTEST_FILE=benchmark_test_fileFILE_SIZE=100M# 创建测试文件echo Creating test file ($FILE_SIZE)...dd if=/dev/urandom of=$TEST_FILE bs=1M count=100 status=progressecho echo ==========================================echo Compression Benchmarkecho ==========================================echo Original file size: $(ls -lh $TEST_FILE | awk print $5)echo # 测试 gzip（级别 1, 6, 9）echo --- gzip ---for level in 1 6 9; do echo -n Level $level: time (gzip -$level -k -c $TEST_FILE $TEST_FILE.gz.$level) ls -lh $TEST_FILE.gz.$level | awk print Size:, $5 rm -f $TEST_FILE.gz.$leveldoneecho # 测试 pigz（并行 gzip）if command -v pigz /dev/null; then echo --- pigz (parallel gzip) --- echo -n Default (all cores): time (pigz -k -c $TEST_FILE $TEST_FILE.pigz) ls -lh $TEST_FILE.pigz | awk print Size:, $5 rm -f $TEST_FILE.pigz echo fi# 测试 bzip2if command -v bzip2 /dev/null; then echo --- bzip2 --- echo -n Default: time (bzip2 -k -c $TEST_FILE $TEST_FILE.bz2) ls -lh $TEST_FILE.bz2 | awk print Size:, $5 rm -f $TEST_FILE.bz2 echo fi# 测试 pbzip2（并行 bzip2）if command -v pbzip2 /dev/null; then echo --- pbzip2 (parallel bzip2) --- echo -n Default: time (pbzip2 -k -c $TEST_FILE $TEST_FILE.pbz2) ls -lh $TEST_FILE.pbz2 | awk print Size:, $5 rm -f $TEST_FILE.pbz2 echo fi# 测试 xzif command -v xz /dev/null; then echo --- xz --- for level in 0 6 9; do echo -n Level $level: time (xz -$level -k -c $TEST_FILE $TEST_FILE.xz.$level) ls -lh $TEST_FILE.xz.$level | awk print Size:, $5 rm -f $TEST_FILE.xz.$level done echo fi# 测试 zstdif command -v zstd /dev/null; then echo --- zstd --- for level in 1 3 9 19; do echo -n Level $level: time (zstd -$level -k -c $TEST_FILE $TEST_FILE.zst.$level) ls -lh $TEST_FILE.zst.$level | awk print Size:, $5 rm -f $TEST_FILE.zst.$level done echo fi# 清理echo ==========================================echo Cleaning up...rm -f $TEST_FILE $TEST_FILE.*echo Done! 使用 tar 进行完整系统备份#!/bin/bash# full_system_backup.sh# 设置变量BACKUP_DIR=/backupDATE=$(date +%Y%m%d_%H%M%S)HOSTNAME=$(hostname)BACKUP_FILE=$BACKUP_DIR/$HOSTNAME_full_backup_$DATE.tar.gz# 排除列表（不备份的内容）EXCLUDE_LIST=( $BACKUP_DIR # 不备份备份目录本身 /proc # 虚拟文件系统 /sys # 虚拟文件系统 /dev # 设备文件（udev 会自动创建） /run # 运行时文件 /mnt # 挂载点 /media # 挂载点 /tmp # 临时文件 /var/tmp # 临时文件 /var/cache # 缓存 /var/log # 日志（可选，建议单独备份） *.swap # swap 文件 */lost+found # 文件系统恢复目录)# 构建排除参数EXCLUDE_ARGS=for item in $EXCLUDE_LIST[@]; do EXCLUDE_ARGS+=--exclude=$item done# 确保备份目录存在mkdir -p $BACKUP_DIR# 开始备份echo ========================================echo Starting Full System Backupecho Backup file: $BACKUP_FILEecho Started at: $(date)echo ========================================# 执行备份tar -czvpf $BACKUP_FILE \\ $EXCLUDE_ARGS \\ --one-file-system \\ / 2$BACKUP_FILE.log# 检查备份结果if [ $? -eq 0 ]; then echo ======================================== echo Backup completed successfully! echo Backup file: $BACKUP_FILE echo Backup size: $(du -h $BACKUP_FILE | cut -f1) echo Completed at: $(date) echo ======================================== # 可选：删除旧备份（保留最近5个） cd $BACKUP_DIR || exit ls -t $HOSTNAME_full_backup_*.tar.gz | tail -n +6 | xargs -r rm -f # 可选：将备份同步到远程服务器 # rsync -avz --progress $BACKUP_FILE user@remote:/backups/ exit 0else echo ======================================== echo Backup failed! echo Check log file: $BACKUP_FILE.log echo Failed at: $(date) echo ======================================== exit 1fi 使用 tar 进行增量备份#!/bin/bash# incremental_backup.shSOURCE_DIR=/dataBACKUP_DIR=/backup/incrementalDATE=$(date +%Y%m%d_%H%M%S)SNAPSHOT_FILE=$BACKUP_DIR/.snapshot# 确保备份目录存在mkdir -p $BACKUP_DIR# 执行增量备份tar -czvpf $BACKUP_DIR/incr_$DATE.tar.gz \\ --listed-incremental=$SNAPSHOT_FILE \\ $SOURCE_DIR# 清理旧备份（保留最近7天）find $BACKUP_DIR -name incr_*.tar.gz -mtime +7 -deleteecho Incremental backup completed: $BACKUP_DIR/incr_$DATE.tar.gz 恢复备份# 完整恢复tar -xzvpf backup.tar.gz -C /# 恢复到指定目录（不覆盖根目录）tar -xzvpf backup.tar.gz -C /restore# 只恢复特定文件或目录tar -xzvpf backup.tar.gz path/to/specific/filetar -xzvpf backup.tar.gz --wildcards etc/nginx/*# 恢复时保留权限（需要 root）sudo tar -xzvpf backup.tar.gz -C / --same-owner# 恢复增量备份# 先恢复完整备份tar -xzvpf full_backup.tar.gz -C /# 然后按顺序恢复增量备份for backup in incr_*.tar.gz; do tar -xzvpf $backup -C /done# 恢复后检查文件系统完整性checksum_file=checksum.listif [ -f $checksum_file ]; then md5sum -c $checksum_filefi 8.4 重点回顾 压缩工具： gzip：速度快，兼容性好，压缩率中等 bzip2：压缩率更高，速度较慢 xz：压缩率最高，速度最慢 zstd：速度极快，现代压缩标准 tar 命令： -c 创建，-x 解压，-t 查看，-v 详细，-f 指定文件 -z gzip，-j bzip2，-J xz 压缩 --exclude 排除文件，--wildcards 通配符 备份策略： 完整备份：备份所有数据 增量备份：只备份变化的文件 差异备份：备份自上次完整备份后变化的文件 实用技巧： 管道和 SSH 实现远程备份 使用 find 和 tar 实现精细控制 定期清理旧备份 定期测试备份的可恢复性 8.5 本章习题 对比 gzip、bzip2、xz 三种压缩工具的压缩率和速度。 如何使用 tar 命令创建一个包含 etc 目录的压缩归档，排除所有 .log 文件？ 如何不解压查看 tar.gz 文件的内容？ 编写一个脚本，每天自动备份 home 目录，保留最近7天的备份。 如何使用 tar 和 ssh 将本地目录备份到远程服务器？ 解释 tar 的增量备份功能，如何创建和恢复增量备份？ 比较 zip 和 tar.gz 的异同，什么时候应该使用 zip？ 有一个损坏的 tar.gz 文件，如何尝试恢复其中的数据？ 8.6 参考资料与延伸阅读 man tar man gzip man bzip2 man xz man zstd GNU Tar Manual 鸟哥的 Linux 私房菜 - 文件压缩与打包 Linux Backup and Recovery","tags":[null,null,null,null]},{"title":"第九章、vim 程序编辑器","path":"/notes/linux/ch09-vim.html","content":"第九章、vim 程序编辑器9.1 vi 与 vimvi 编辑器简介vi（Visual Editor）是 UnixLinux 系统中最经典的文本编辑器，由 Bill Joy 于 1976 年开发。 vi 的特点： 所有 UnixLinux 系统都预装 轻量级，启动快速 不需要图形界面，适合远程编辑 功能强大，效率高（掌握后） vi 的缺点： 学习曲线陡峭 没有语法高亮（原始版本） 操作不够直观 vim 编辑器简介vim（Vi IMproved）是 Bram Moolenaar 于 1991 年开发的 vi 改进版本。 vim 相比 vi 的改进： 特性 说明 语法高亮 支持数百种编程语言的语法高亮 多窗口 支持水平、垂直分割窗口 多标签 支持标签页编辑 折叠 代码折叠功能 自动缩进 智能缩进和对齐 代码补全 单词、行、文件名补全 宏录制 录制和回放键盘操作 插件系统 强大的插件扩展机制 图形界面 gvim 提供 GUI 版本 跨平台 支持 Linux、Windows、macOS 检查 vim 安装# 检查是否安装 vimwhich vimvim --version# 如果没有安装（CentOS/RHEL）sudo yum install vim# 或安装完整版sudo yum install vim-enhanced# 如果没有安装（Debian/Ubuntu）sudo apt-get install vim# 安装图形界面版本sudo yum install gvim # CentOSsudo apt-get install vim-gtk # Debian/Ubuntu# 查看 vim 版本和功能vim --version | head -20 vivim 的三种模式vim 有三种基本工作模式： ┌─────────────────┐│ 正常模式 │ ←── 默认模式，用于移动光标、删除、复制等│ (Normal Mode) │└────────┬────────┘ │ ┌────┴────┐ │ │ ↓ ↓┌─────────┐ ┌─────────┐│ 插入模式 │ │ 命令行模式││(Insert │ │(Command ││ Mode) │ │ Mode) │└─────────┘ └─────────┘ i,a,o :,/,? 1. 正常模式（Normal Mode） 默认进入的模式 用于浏览、移动光标、删除、复制、粘贴等 按 i、a、o 等进入插入模式 按 : 进入命令行模式 2. 插入模式（Insert Mode） 用于输入和编辑文本 左下角显示 “– INSERT –” 按 Esc 返回正常模式 3. 命令行模式（Command Mode Ex Mode） 用于执行保存、退出、搜索、替换等命令 左下角显示 : 或 / 或 ? 按 Esc 或 Enter 执行后返回正常模式 9.2 vi 的使用启动和退出 vim启动 vim： # 打开新文件vimvim newfile.txt# 打开现有文件vim existingfile.txt# 打开多个文件vim file1.txt file2.txt file3.txt# 从指定行开始vim +10 file.txt # 打开后光标在第10行vim + file.txt # 打开后光标在最后一行# 从指定匹配位置开始vim +/pattern file.txt # 打开后光标在第一个匹配位置# 以只读模式打开vim -R file.txtview file.txt # 等同于 vim -R# 恢复异常退出的交换文件vim -r file.txtvim -r # 列出所有可恢复的交换文件 退出 vim： # 在命令行模式下（按 : 进入）:w # 保存（写入）:w filename # 另存为 filename:q # 退出（前提是没有修改）:q! # 强制退出，不保存修改:wq # 保存并退出:x # 保存并退出（与 :wq 类似，但有细微差别）ZZ # 正常模式下，保存并退出（不需要 :）ZQ # 正常模式下，不保存退出:wqa # 保存所有打开的文件并退出:qa! # 放弃所有修改并退出 正常模式基本操作移动光标： # 基本移动h # 左j # 下k # 上l # 右# 快速移动w # 下一个单词的开头b # 上一个单词的开头e # 当前单词/下一个单词的结尾ge # 上一个单词的结尾W # 下一个 WORD 的开头（以空格分隔）B # 上一个 WORD 的开头E # WORD 的结尾# 行内移动0 # 行首^ # 第一个非空白字符$ # 行尾g_ # 最后一个非空白字符| # 第 N 列（例如 10| 跳到第10列）# 行间移动gg # 文件第一行G # 文件最后一行10G # 第 10 行:10 # 第 10 行（命令行模式）% # 跳转到匹配的括号 ()[]# 屏幕移动H # 屏幕顶部（High）M # 屏幕中间（Middle）L # 屏幕底部（Low）Ctrl+f # 向下翻一页（Page Down）Ctrl+b # 向上翻一页（Page Up）Ctrl+d # 向下翻半页Ctrl+u # 向上翻半页zz # 将当前行移到屏幕中央e zt # 将当前行移到屏幕顶部zb # 将当前行移到屏幕底部# 搜索移动/pattern # 向下搜索 pattern?pattern # 向上搜索 patternn # 下一个匹配N # 上一个匹配* # 向下搜索当前单词# # 向上搜索当前单词# 标记移动ma # 在当前位置设置标记 a`a # 跳转到标记 a 的位置（精确位置）a # 跳转到标记 a 所在行的行首``. # 跳转到上次编辑的位置 # 跳转到上次跳转的位置开头:marks # 列出所有标记 编辑操作： # 删除操作（实际是剪切，可以粘贴）x # 删除光标下的字符X # 删除光标前的字符dd # 删除当前行5dd # 删除5行dw # 删除到单词结尾d$ # 删除到行尾d0 # 删除到行首dgg # 删除到文件开头dG # 删除到文件结尾di # 删除引号内的内容（包括引号内的所有内容）di( # 删除括号内的内容di # 删除大括号内的内容dit # 删除 HTML/XML 标签内的内容# 复制（yank）yy # 复制当前行5yy # 复制5行yw # 复制到单词结尾y$ # 复制到行尾y0 # 复制到行首ggVG # 选择全部并复制（gg=到开头，V=行选择，G=到结尾）# 粘贴p # 在光标后/下方粘贴P # 在光标前/上方粘贴]p # 粘贴并调整缩进（适合代码）[p # 在上方粘贴并调整缩进# 修改（删除并进入插入模式）cc # 修改当前行（删除并进入插入模式）cw # 修改到单词结尾c$ # 修改到行尾c0 # 修改到行首ct # 修改到引号（不包括引号）# 替换r # 替换光标下的单个字符，然后返回正常模式R # 进入替换模式（类似插入模式，但会覆盖原有内容）~ # 切换光标下字符的大小写# 撤销和重做u # 撤销上一步操作U # 撤销对当前行的所有修改Ctrl+r # 重做（撤销的反向操作）# 重复操作. # 重复上一个修改操作（非常强大的功能） 进入插入模式： i # 在光标前插入I # 在行首插入a # 在光标后插入A # 在行尾插入o # 在下方插入新行O # 在上方插入新行s # 删除光标下的字符并插入S # 删除当前行并插入C # 删除到行尾并插入cw # 删除单词并插入# 退出插入模式Esc # 返回正常模式Ctrl+[ # 等同于 EscCtrl+c # 等同于 Esc（某些环境下） 可视模式（Visual Mode）# 进入可视模式v # 字符可视模式（选择单个字符）V # 行可视模式（选择整行）Ctrl+v # 块可视模式（选择矩形区域，列选择）# 可视模式下的操作h/j/k/l # 扩展选择范围w/b/e # 按单词扩展$/0/^ # 到行首/尾gg/G # 到文件开头/结尾o # 切换选择的锚点（从另一端扩展）O # 块可视模式下，切换到另一个角落# 对选中内容执行操作d # 删除y # 复制 # 增加缩进（代码） # 减少缩进（代码）= # 自动缩进~ # 切换大小写u # 转为小写U # 转为大写J # 合并行gq # 格式化文本（自动换行）r # 替换为指定字符I # 在所有选中行前插入A # 在所有选中行后追加Esc # 退出可视模式 命令行模式（Command ModeEx Mode）# 进入命令行模式（按 : 进入）# 文件操作:w # 保存:w filename # 另存为:q # 退出:q! # 强制退出，不保存:wq # 保存并退出:x # 保存并退出（与 :wq 类似）ZZ # 保存并退出（正常模式下，不需要 :）:saveas filename # 另存为并切换到新文件# 编辑操作:e filename # 编辑另一个文件:e! # 放弃修改，重新加载文件:enew # 新建文件# 缓冲区操作:ls # 列出所有缓冲区:buffers # 同上:files # 同上:b 2 # 切换到缓冲区 2:bnext # 下一个缓冲区:bprevious # 上一个缓冲区:bfirst # 第一个缓冲区:blast # 最后一个缓冲区:bdelete 2 # 删除缓冲区 2:bwipeout 2 # 彻底删除缓冲区 2# 窗口操作:split # 水平分割窗口:split filename # 水平分割并打开文件:vsplit # 垂直分割窗口:vsplit filename # 垂直分割并打开文件:new # 水平分割新窗口:vnew # 垂直分割新窗口:close # 关闭当前窗口:only # 只保留当前窗口，关闭其他:qa # 关闭所有窗口并退出:qa! # 强制关闭所有窗口并退出:windo cmd # 对所有窗口执行命令# 标签页操作:tabnew # 新建标签页:tabnew filename # 新建标签页并打开文件:tabs # 列出所有标签页:tabnext # 下一个标签页（gt）:tabprevious # 上一个标签页（gT）:tabfirst # 第一个标签页:tablast # 最后一个标签页:tabmove 2 # 移动标签页到位置 2:tabmove +1 # 向右移动一个位置:tabmove -1 # 向左移动一个位置:tabclose # 关闭当前标签页:tabonly # 只保留当前标签页:tabdo cmd # 对所有标签页执行命令# 搜索和替换/pattern # 向下搜索 pattern（后按 Enter）?pattern # 向上搜索 patternn # 下一个匹配N # 上一个匹配* # 搜索当前单词（向下）# # 搜索当前单词（向上）:%s/old/new/ # 替换当前行第一个匹配:%s/old/new/g # 替换当前行所有匹配:%s/old/new/gc # 替换所有匹配，每次确认:1,10s/old/new/g # 替换 1-10 行:%s/old/new/gi # 忽略大小写替换:%s//new/g # 使用上次搜索模式替换# 设置选项:set number # 显示行号（:set nu）:set nonumber # 隐藏行号（:set nonu）:set relativenumber # 显示相对行号:set norelativenumber # 隐藏相对行号:set cursorline # 高亮当前行:set nocursorline # 取消高亮当前行:set cursorcolumn # 高亮当前列:set wrap # 自动换行:set nowrap # 不换行:set ignorecase # 搜索忽略大小写（:set ic）:set smartcase # 智能大小写（有大写时区分）:set hlsearch # 高亮搜索结果（:set hls）:set nohlsearch # 取消高亮（:noh 临时取消）:set incsearch # 增量搜索（实时显示）:set tabstop=4 # Tab 宽度为 4:set shiftwidth=4 # 自动缩进宽度为 4:set expandtab # Tab 转换为空格:set autoindent # 自动缩进:set smartindent # 智能缩进:set cindent # C 风格缩进:set fileformat=unix # 文件格式为 Unix:set fileencoding=utf-8 # 文件编码为 UTF-8:set backup # 创建备份文件:set nobackup # 不创建备份:set swapfile # 创建交换文件:set noswapfile # 不创建交换文件:set history=1000 # 命令历史记录数:set undolevels=1000 # 撤销级别数:set laststatus=2 # 总是显示状态栏:set ruler # 显示光标位置:set showcmd # 显示部分命令:set showmatch # 显示匹配的括号:set wildmenu # 命令行补全菜单:set paste # 粘贴模式（防止格式错乱）:set nopaste # 取消粘贴模式# 查看当前设置:set all # 显示所有选项:set number? # 查看 number 选项的值:set # 显示修改过的选项# 保存设置到配置文件:mkvimrc ~/.myvimrc # 保存当前设置到文件 vim 高级技巧1. 寄存器使用： # 命名寄存器（a-z）ayy # 复制当前行到寄存器 aap # 粘贴寄存器 a 的内容byw # 复制单词到寄存器 bb3p # 粘贴 3 次# 特殊寄存器 # 默认寄存器0 # 上次复制的内容（y 命令）1-9 # 删除历史（d 命令）- # 小删除（少于一行）+ # 系统剪贴板（可能需要 +clipboard 特性）* # 主剪贴板（X11）% # 当前文件名# # 备用文件名= # 表达式寄存器_ # 黑洞寄存器（删除不保存）/ # 上次搜索模式: # 上次命令行命令. # 上次插入的文本# 使用系统剪贴板（跨应用复制粘贴）+yy # 复制到系统剪贴板+p # 从系统剪贴板粘贴# 表达式寄存器=5*5p # 计算 5*5 并粘贴结果=strftime(%Y-%m-%d)p # 插入当前日期 2. 宏录制： # 录制宏到寄存器 q（可以是任意字母）qq # 开始录制到寄存器 q... # 执行一系列操作q # 停止录制# 播放宏@q # 播放寄存器 q 的宏@@ # 再次播放上次使用的宏5@q # 播放宏 5 次# 应用到多行# 方法1：在行上使用宏10@q # 在当前行及下面9行上应用宏# 方法2：配合可视模式Vjjjj # 选择多行:,normal @q # 对每一行应用宏# 编辑宏qp # 将宏粘贴出来# 编辑内容qyy # 重新保存到寄存器 q# 追加到宏qQ # 追加录制到寄存器 q... # 执行额外操作q # 停止# 保存宏到文件qyy # 复制宏内容:new ~/.vim/macros.vimp # 粘贴:w # 保存# 从文件加载宏:r ~/.vim/macros.vimqyy # 保存到寄存器 q 3. 多窗口操作： # 创建分割窗口Ctrl+w s # 水平分割当前窗口（split）Ctrl+w v # 垂直分割当前窗口（vsplit）:sp filename # 水平分割并打开文件:vsp filename # 垂直分割并打开文件:new # 水平分割新窗口:vnew # 垂直分割新窗口# 在窗口间移动Ctrl+w w # 在窗口间循环移动Ctrl+w h # 移到左边窗口Ctrl+w j # 移到下边窗口Ctrl+w k # 移到上边窗口Ctrl+w l # 移到右边窗口Ctrl+w t # 移到顶部窗口Ctrl+w b # 移到底部窗口Ctrl+w p # 移到上一个窗口# 移动窗口位置Ctrl+w r # 向下/向右旋转窗口Ctrl+w R # 向上/向左旋转窗口Ctrl+w x # 与下一个窗口交换Ctrl+w K # 将窗口移到最上（大写K）Ctrl+w J # 将窗口移到最下（大写J）Ctrl+w H # 将窗口移到最左（大写H）Ctrl+w L # 将窗口移到最右（大写L）Ctrl+w T # 将窗口移到新的标签页# 调整窗口大小Ctrl+w = # 所有窗口等宽等高Ctrl+w _ # 最大化当前窗口高度Ctrl+w | # 最大化当前窗口宽度Ctrl+w + # 增加窗口高度Ctrl+w - # 减少窗口高度Ctrl+w # 增加窗口宽度Ctrl+w # 减少窗口宽度Ctrl+w n+ # 增加 n 行高度（例如：Ctrl+w 5+）:resize 20 # 设置当前窗口高度为20:resize +5 # 增加5行:vertical resize 80 # 设置宽度为80# 关闭窗口Ctrl+w c # 关闭当前窗口（close）Ctrl+w q # 关闭当前窗口并退出（quit）:q # 关闭当前窗口:q! # 强制关闭:on # 只保留当前窗口，关闭其他（only）:only # 同上# 打开新窗口Ctrl+w n # 水平分割新窗口Ctrl+w ^ # 水平分割并打开文件（与#相同）Ctrl+w f # 水平分割并打开光标下的文件Ctrl+w i # 水平分割并跳转到光标下单词的定义Ctrl+w d # 水平分割并跳转到光标下单词的定义（查找）# 多窗口编辑技巧# 1. 对比两个文件vim -d file1 file2 # 启动时进入 diff 模式vim file1:vertical diffsplit file2# 2. 同时查看文件的不同部分Ctrl+w s # 分割窗口Ctrl+w w # 在窗口间切换:G # 一个窗口到文件末尾，另一个在开头# 3. 编辑同一文件的不同位置Ctrl+w v # 垂直分割Ctrl+w l # 移到右窗口100G # 跳到第100行Ctrl+w h # 移回左窗口50G # 跳到第50行# 现在可以同时看到文件的两个不同位置# 4. 参考模式# 在一个窗口查看参考代码，在另一个窗口编写代码Ctrl+w vCtrl+w l:e reference.txtCtrl+w h# 现在左边是工作文件，右边是参考文件 4. 多标签页操作： # 创建标签页:tabnew # 新建标签页:tabnew filename # 新建标签页并打开文件:tabe filename # 同上（tabedit）:tabf filename # 查找文件并在新标签打开:tabs # 列出所有标签页# 在标签页间切换gt # 下一个标签页（正常模式）gT # 上一个标签页（正常模式）:tabnext # 下一个标签页:tabprevious # 上一个标签页:tabn # 简写:tabp # 简写:tabfirst # 第一个标签页:tablast # 最后一个标签页:tabm 0 # 移到第一个位置:tabm # 移到最后:tabm 2 # 移到位置 2# 关闭标签页:tabc # 关闭当前标签页（tabclose）:tabo # 只保留当前标签页（tabonly）:tabs # 显示所有标签页# 标签页快捷键配置（可添加到 .vimrc） 使用 Alt+数字 切换标签页map A-1 1gtmap A-2 2gtmap A-3 3gtmap A-4 4gtmap A-5 5gtmap A-6 6gtmap A-7 7gtmap A-8 8gtmap A-9 9gtmap A-0 :tablastCR 使用 Ctrl+t 新建标签页nnoremap C-t :tabnewCR 使用 Ctrl+w 关闭标签页nnoremap C-w :tabcloseCR# 实用标签页技巧# 1. 在标签页间复制内容# 在标签页1复制：yy# 切换到标签页2：gt# 粘贴：p# 2. 对比不同版本的文件vim file.txt:vsplit file.txt.backup# 或者在两个标签页中打开:tabe file.txt:tabe file.txt.backup# 3. 工作流程示例vim main.c:tabnew utils.c # 创建新标签编辑工具函数:tabnew header.h # 创建新标签编辑头文件# 现在可以用 gt/gT 在三个文件间快速切换# 4. 保存所有标签页的会话:mksession ~/.vim/session/work.vim# 下次恢复vim -S ~/.vim/session/work.vim 5. 搜索和替换： # 基础搜索/pattern # 向下搜索 pattern?pattern # 向上搜索 patternn # 下一个匹配N # 上一个匹配# 搜索设置:set ignorecase # 忽略大小写:set smartcase # 智能大小写（有大写字母时区分）:set noignorecase # 区分大小写:set hlsearch # 高亮搜索结果:set nohlsearch # 取消高亮:noh # 临时取消高亮（下次搜索恢复）:set incsearch # 增量搜索（实时显示）# 特殊搜索/pattern\\c # 临时忽略大小写/pattern\\C # 临时区分大小写/^pattern # 匹配行首/pattern$ # 匹配行尾/\\word\\ # 匹配整个单词/pattern1.*pattern2 # 匹配两个模式之间# 替换命令:s/old/new/ # 替换当前行第一个匹配:s/old/new/g # 替换当前行所有匹配:5s/old/new/g # 替换第5行所有匹配:1,10s/old/new/g # 替换1-10行所有匹配:%s/old/new/g # 替换整个文件所有匹配:%s/old/new/gc # 替换所有匹配，每次确认:%s/old/new/gi # 忽略大小写替换所有:%s/old/new/gI # 区分大小写替换所有# 高级替换:%s/\\s\\+$//g # 删除行尾空白:%s/^\\s\\+//g # 删除行首空白:%s/^ \\+//g # 删除空行:%s/old//g # 删除所有匹配而不替换:%s/old/\\U/g # 替换为大写:%s/old/\\L/g # 替换为小写:%s/old/\\u/g # 替换为首字母大写:%s/\\(.*\\)/\\1\\1/g # 复制整行# 使用上次搜索模式:%s//new/g # 使用上次的搜索模式# 使用正则表达式捕获组:%s/\\(foo\\)\\(bar\\)/\\2\\1/g # 交换 foo 和 bar:%s/\\d\\+/\\=submatch(0)+1/g # 将数字加1# 确认替换选项y # 替换当前n # 跳过当前a # 替换所有剩余q # 退出替换l # 替换当前并退出Ctrl+e # 向下滚动Ctrl+y # 向上滚动 6. 书签和标记： # 设置标记（a-z 局部标记，A-Z 全局标记）ma # 在当前位置设置标记 amb # 在当前位置设置标记 bmA # 设置全局标记 A（跨文件）# 跳转到标记`a # 跳转到标记 a 的精确位置（光标位置）a # 跳转到标记 a 所在行的行首# 特殊标记``. # 跳转到上次编辑的位置`. # 跳转到上次修改的位置`^ # 跳转到上次插入模式的位置`[ # 跳转到上次修改的开始位置`] # 跳转到上次修改的结束位置` # 跳转到上次可视选择的开始` # 跳转到上次可视选择的结束# 列出标记:marks # 列出所有标记:marks aAbBcC # 列出指定标记# 删除标记:delmarks a # 删除标记 a:delmarks a-d # 删除标记 a 到 d:delmarks! # 删除所有小写标记（a-z）# 实用技巧# 在代码中设置标记快速导航ma # 在函数开始处设置标记 a# ... 编辑其他部分 ...a # 快速跳回函数开始# 使用全局标记跨文件导航# 在文件1中：mA# 在文件2中：mB# 随时可以用 `A 和 `B 在文件间跳转# 结合使用ma # 设置临时标记# 进行一系列编辑...`a # 快速回到标记位置 7. 折叠代码： # 设置折叠方法:set foldmethod=syntax # 基于语法折叠:set foldmethod=indent # 基于缩进折叠:set foldmethod=marker # 基于标记折叠:set foldmethod=expr # 基于表达式折叠:set foldmethod=manual # 手动折叠（默认）# 标记折叠# 在代码中添加标记：# 开始折叠# 要折叠的代码# 结束折叠# 折叠操作（在 normal 模式下）zo # 打开当前折叠（open）zc # 关闭当前折叠（close）za # 切换当前折叠（toggle）zO # 递归打开所有嵌套折叠zC # 递归关闭所有嵌套折叠zA # 递归切换所有嵌套折叠zv # 展开足够的折叠使光标行可见zx # 更新折叠（撤销手动打开/关闭）zX # 完全更新折叠zm # 增加 foldlevel（关闭更多折叠）zM # 关闭所有折叠（foldlevel=0）zr # 减少 foldlevel（打开更多折叠）zR # 打开所有折叠（foldlevel=最大）zn # 禁用折叠（foldenable=0）zN # 启用折叠（foldenable=1）zi # 切换 foldenable# 显示折叠信息:set foldcolumn=4 # 显示折叠列（显示折叠层次）:set foldlevel=2 # 设置初始折叠级别:set foldminlines=3 # 设置最小折叠行数:set foldnestmax=3 # 设置最大折叠嵌套深度# 查看折叠信息[Count]zk # 移动到上一个折叠开始[Count]zj # 移动到下一个折叠开始[Count]zk # 移动到当前折叠开始（如果在折叠内）# 示例配置（添加到 .vimrc）set foldmethod=syntaxset foldlevel=99 默认打开所有折叠set foldcolumn=3 显示折叠列set foldopen=all 自动打开折叠（当跳转时） 使用空格键切换折叠nnoremap space za 使用大括号导航折叠map [[ zcmap ]] zo 8. vim 配置文件（.vimrc）： ~/.vimrc - vim 配置文件 ====================== 基本设置set nocompatible 不与 Vi 兼容（使用 vim 的扩展功能）set encoding=utf-8 使用 UTF-8 编码set fileencoding=utf-8 文件使用 UTF-8 编码set termencoding=utf-8 终端使用 UTF-8 显示设置set number 显示行号set relativenumber 显示相对行号（可选）set cursorline 高亮当前行set colorcolumn=80 在 80 列处显示标记线set laststatus=2 总是显示状态栏set showcmd 显示部分命令set showmode 显示当前模式set ruler 显示光标位置 搜索设置set hlsearch 高亮搜索结果set incsearch 增量搜索set ignorecase 忽略大小写set smartcase 智能大小写（有大写字母时区分）set wrapscan 搜索到文件末尾后从头开始 缩进和制表符set autoindent 自动缩进set smartindent 智能缩进set cindent C 风格缩进set expandtab Tab 转换为空格set tabstop=4 Tab 宽度为 4set shiftwidth=4 自动缩进宽度为 4set softtabstop=4 软 Tab 宽度为 4 折叠设置set foldenable 启用折叠set foldmethod=syntax 基于语法折叠set foldlevel=99 默认打开所有折叠set foldcolumn=3 显示折叠列 备份和交换文件set backup 启用备份set backupdir=~/.vim/backup// 备份文件目录set backupext=.bak 备份文件扩展名set swapfile 启用交换文件set directory=~/.vim/swap// 交换文件目录set undofile 启用持久撤销set undodir=~/.vim/undo// 撤销文件目录 性能优化set lazyredraw 减少重绘set ttyfast 快速终端连接set updatetime=300 更新时间间隔set timeoutlen=500 键序列超时时间 自动命令if has(autocmd) 文件类型检测 filetype on filetype plugin on filetype indent on 针对文件类型的设置 autocmd FileType python setlocal et sta sw=4 sts=4 autocmd FileType c,cpp setlocal cindent autocmd FileType html,xhtml,css,xml setlocal sw=2 sts=2 autocmd FileType javascript setlocal sw=2 sts=2 自动移除行尾空格 autocmd BufWritePre * :%s/\\s\\+$//e 记住光标位置 autocmd BufReadPost * \\ if line(\\) 1 line(\\) = line($) | \\ exe normal! g`\\ | \\ endifendif 配色方案try colorscheme desert 使用 desert 配色 colorscheme molokai 或其他配色方案 colorscheme solarizedcatch colorscheme defaultendtryset background=dark 使用深色背景 快捷键映射let mapleader = , 设置 leader 键为逗号 快速保存nmap leaderw :w!CRnmap leaderq :q!CRnmap leaderx :x!CR 快速切换窗口nnoremap C-h C-whnnoremap C-j C-wjnnoremap C-k C-wknnoremap C-l C-wl 使用空格键切换折叠nnoremap space za 快速编辑 .vimrcnnoremap leaderv :e $MYVIMRCCRnnoremap leaders :source $MYVIMRCCR 在当前行上下插入空行（不进入插入模式）nnoremap Leadero oEscnnoremap LeaderO OEsc 快速移动nnoremap H ^nnoremap L $nnoremap J 5jnnoremap K 5k 视觉模式下保持缩进vnoremap gvvnoremap gv 系统剪贴板nnoremap leadery +yvnoremap leadery +ynnoremap leaderY +Ynnoremap leaderp +pnnoremap leaderP +P 插件管理（vim-plug）示例 先安装 vim-plug: curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimcall plug#begin(~/.vim/plugged) 常用插件示例Plug tpope/vim-sensible 合理的默认设置Plug tpope/vim-surround 快速操作包围符号Plug tpope/vim-commentary 快速注释Plug tpope/vim-fugitive Git 集成Plug preservim/nerdtree 文件浏览器Plug vim-airline/vim-airline 状态栏增强Plug vim-airline/vim-airline-themesPlug sheerun/vim-polyglot 语法高亮包Plug junegunn/fzf, do: - fzf#install() Plug junegunn/fzf.vim 模糊查找call plug#end() 安装插件: :PlugInstall 更新插件: :PlugUpdate 清理插件: :PlugClean 这是一个非常全面的 .vimrc 配置文件，涵盖了 vim 的各个方面。以下是使用这个配置的方法： 安装 vim-plug（如果你需要使用插件部分）： curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 创建配置文件： cp ~/.vimrc ~/.vimrc.backup # 备份原有配置（如果有）vim ~/.vimrc# 粘贴上面的配置内容 创建必要的目录： mkdir -p ~/.vim/backup ~/.vim/swap ~/.vim/undo ~/.vim/plugged 安装插件（如果使用插件部分）： vim:PlugInstall 这个配置包含了以下主要功能： 基本设置（编码、行号、搜索等） 缩进和制表符设置 折叠和语法高亮 备份和撤销文件管理 自动命令（文件类型检测、自动格式化等） 配色方案 键盘映射和快捷键 插件管理（vim-plug） 完整的插件配置示例 你可以根据自己的需要启用或禁用某些功能，或者修改某些设置以适应你的工作环境。这个文件中的注释非常详细，可以帮助你了解每个设置的作用。好的，我将继续完成这个全面的 .vimrc 配置文件。我已经添加了插件管理部分，现在让我继续添加更多实用功能和插件配置。好的，我来继续完成这个 vim 配置文件。接下来需要添加更多实用的插件配置和自定义功能。我会重点完善以下几个部分：1. 添加 NERDTree 文件浏览器的配置；2. 配置代码补全和语法检查；3. 添加更多快捷键映射；4. 完善状态栏和主题设置。这些配置将让 vim 更加强大易用。好的，让我继续完成这个 vim 配置文件：|tool_calls_section_begin||tool_call_begin|functions.Read:55|tool_call_argument_begin|{","tags":[null,null,null]},{"title":"Linux 学习笔记目录","path":"/notes/linux/index.html","content":"Linux 学习笔记本笔记基于《鸟哥的 Linux 私房菜：基础学习篇 第四版》整理。 笔记目录基础概念篇 第零章、计算机概论 第一章、Linux是什么与如何学习 第二章、主机规划与磁盘分区 安装与入门篇 第三章、安装 CentOS7.x 第四章、首次登陆与线上求助 文件与权限篇 第五章、Linux 的文件权限与目录配置 第六章、Linux 文件与目录管理 第七章、Linux 磁盘与文件系统管理 第八章、文件与文件系统的压缩,打包与备份 编辑器与Shell篇 第九章、vim 程序编辑器 第十章、认识与学习BASH 第十一章、正则表达式与文件格式化处理 第十二章、学习 Shell Scripts 系统管理篇 第十三章、Linux 帐号管理与 ACL 权限设置 第十四章、磁盘配额（Quota）与进阶文件系统管理 第十五章、例行性工作调度（crontab） 第十六章、程序管理与 SELinux 初探 第十七章、认识系统服务 （daemons） 第十八章、认识与分析登录文件 系统进阶篇 第十九章、开机流程、模块管理与 Loader 第二十章、基础系统设置与备份策略 第二十一章、软件安装：源代码与 Tarball 第二十二章、软件安装 RPM, SRPM 与 YUM 第二十三章、X Window 设置介绍 第二十四章、Linux 核心编译与管理 学习资源 原书：《鸟哥的 Linux 私房菜：基础学习篇 第四版》 在线资源：Linux 中国","tags":[null,null,null]},{"title":"第十章、认识与学习BASH","path":"/notes/linux/ch10-bash.html","content":"第十章、认识与学习BASH10.1 认识 BASH 这个 Shell什么是 ShellShell 是一个命令行解释器，它是用户与操作系统内核之间的接口。 主要功能： 命令执行：解释用户输入的命令并执行 程序启动：启动和管理程序 输入输出重定向：控制数据流向 管道：将一个命令的输出作为另一个命令的输入 变量和环境：管理环境变量 脚本编程：支持流程控制和函数 Shell 的种类Linux 系统中有多种 Shell，常见的有： Shell 说明 特点 Bash Bourne-Again SHell Linux 默认 Shell，功能强大，兼容 sh sh Bourne Shell 最经典的 Unix Shell，简洁快速 csh C Shell 语法类似 C 语言 tcsh Turbo C Shell csh 的增强版 ksh Korn Shell 商业 Unix 常用，功能强大 zsh Z Shell 功能最丰富，可定制性强，推荐 fish Friendly Interactive SHell 用户友好，有自动补全和语法高亮 查看和切换 Shell查看当前使用的 Shell： echo $SHELL # 显示当前用户的默认Shellecho $0 # 显示当前Shellps -p $$ # 显示当前进程信息 查看系统安装的所有 Shell： cat /etc/shells # 列出系统可用的Shell 临时切换 Shell： /bin/sh # 切换到sh/bin/bash # 切换到bash/bin/zsh # 切换到zshexit # 退出当前Shell，返回上一层 永久修改默认 Shell： chsh # 交互式修改chsh -s /bin/zsh # 直接指定Shellchsh -s $(which zsh) # 使用which获取路径 ⚠️ 注意： 修改后需要重新登录才能生效。 Bash 的特性Bash (Bourne-Again SHell) 是 Linux 系统默认的 Shell，具有以下特性： 1. 命令历史（History）history # 显示命令历史history | tail -20 # 显示最近的20条history -c # 清除历史!n # 执行第n条命令!! # 执行上一条命令!-n # 执行倒数第n条命令!string # 执行最近以string开头的命令!?string # 执行最近包含string的命令^old^new # 替换后执行上一条命令 2. 命令补全（Tab Completion） 按一次 Tab：自动补全命令或文件名 按两次 Tab：显示所有可能的补全选项 Alt+?：显示所有可能的补全 Alt+*：插入所有可能的补全 3. 命令别名（Alias）alias # 显示所有别名alias ll # 显示特定别名alias ll=ls -alF # 创建别名alias rm=rm -i # 创建别名（安全）unalias ll # 删除别名 4. 输入输出重定向# 输出重定向 file # 覆盖输出到文件 file # 追加输出到文件2 file # 错误输出到文件2 file # 错误追加到文件 file # 所有输出到文件（标准+错误） file 21 # 同上（旧语法） /dev/null # 丢弃输出# 输入重定向 file # 从文件输入command EOF # Here Documentcommand string # Here String 5. 管道（Pipe）command1 | command2 # command1的输出作为command2的输入command1 | command2 | command3 # 多级管道cat file | grep pattern | sort | uniq | wc -l 6. 变量和环境变量# 定义变量var=value # 定义局部变量export var=value # 定义环境变量export var # 将局部变量导出为环境变量# 使用变量echo $var # 输出变量值echo $var # 使用花括号明确变量边界echo $var:-default # 变量不存在时使用默认值echo $var:=default # 变量不存在时设置默认值# 特殊变量$0 # 脚本名$1, $2, ... # 位置参数$# # 参数个数$@ # 所有参数（数组形式）$* # 所有参数（字符串形式）$? # 上条命令的退出状态$$ # 当前进程ID$! # 最近后台进程的ID$_ # 上条命令的最后一个参数 7. 引号的使用# 双引号 - 弱引用，允许变量扩展和命令替换echo Hello $USERecho Today is $(date +%Y-%m-%d)# 单引号 - 强引用，原样输出echo Hello $USER # 输出: Hello $USERecho Today is $(date) # 输出: Today is $(date)# 反引号 - 命令替换（旧语法，推荐用 $()）echo Today is `date +%Y-%m-%d`# 转义字符\\$ # 转义美元符号\\\\ # 转义反斜杠\\ # 转义双引号（在双引号内） # 换行\\t # 制表符 8. 通配符（Globbing）# * - 匹配任意数量的任意字符ls *.txt # 所有txt文件ls file* # 以file开头的文件ls *backup* # 包含backup的文件# ? - 匹配单个任意字符ls file?.txt # file0.txt, fileA.txt 等ls ???.txt # 三个字符的txt文件# [] - 匹配括号内的任意一个字符ls file[0-9].txt # file0.txt 到 file9.txtls file[abc].txt # filea.txt, fileb.txt, filec.txtls [A-Z]* # 以大写字母开头的文件ls file[!0-9].txt # 不以数字结尾的file# - 花括号扩展（不是通配符，是Shell扩展）cp file,.bak # cp file file.bakmkdir -p project/src,test,docstouch file1..10.txt # file1.txt 到 file10.txtecho a,b,c1,2 # a1 a2 b1 b2 c1 c2# 特殊通配符（需要启用）shopt -s extglob # 启用扩展通配符ls !(*.txt) # 非txt文件ls @(file1|file2).txt # file1.txt 或 file2.txtls +(file).txt # 一个或多个file.txtls ?(file).txt # 零个或一个file.txtls *(file).txt # 零个或多个file.txtshopt -s globstar # 启用 ** 递归匹配ls **/*.txt # 递归查找所有txt文件 9. 进程控制# 前台运行command# 后台运行command # 暂停（挂起）当前进程Ctrl+Z# 查看作业jobsjobs -l # 显示进程ID# 将作业放到后台运行bg %1 # 作业号1放到后台bg # 最近挂起的作业放到后台# 将作业放到前台运行fg %1 # 作业号1放到前台fg # 最近的作业放到前台# 等待进程结束wait PID # 等待指定进程wait # 等待所有子进程# 杀掉进程kill PID # 终止进程kill -9 PID # 强制终止kill %1 # 终止作业killall process_name # 按名称终止pkill pattern # 按模式终止# 脱离终端运行nohup command # 不受终端关闭影响disown %1 # 从当前shell移除作业 10. 命令组合与控制# 顺序执行command1; command2; command3# 逻辑与（前一个成功才执行后一个）command1 command2mkdir test cd test touch file.txt# 逻辑或（前一个失败才执行后一个）command1 || command2test -f file.txt || echo File not found# 组合使用command1 command2 || command3# 成功执行2，失败执行3# 管道组合cat file | grep pattern | sort | uniq | wc -l# 子shell(cd /tmp; ls) # 在子shell中执行，不影响当前目录(command1; command2)# 命令分组 command1; command2; # 在当前shell中执行 cd /tmp; ls; # 会影响当前目录# 区别# (cmd) - 子shell，变量修改不影响父shell# cmd; - 当前shell，变量修改会影响# 后台执行command (command1; command2) command1; command2; Bash 配置文件配置文件加载顺序登录 Shell 的加载顺序： 登录 │ ├─ /etc/profile │ │ │ ├─ /etc/profile.d/*.sh │ │ │ └─ (~/.bash_profile | ~/.bash_login | ~/.profile) 按顺序第一个存在的 │ │ │ └─ ~/.bashrc │ │ │ └─ /etc/bash.bashrc (某些系统) │ └─ 登录完成 非登录交互式 Shell： ~/.bashrc │ └─ /etc/bash.bashrc (某些系统) 非交互式 Shell（执行脚本）： $BASH_ENV 指定的文件（如果存在） 主要配置文件说明/etc/profile 系统全局配置文件，对所有用户生效 只在登录时加载一次 设置全局环境变量和启动程序 通常包含对 /etc/profile.d/ 的引用 ~/.bash_profile, ~/.bash_login, ~/.profile 用户个人配置文件，按顺序加载第一个存在的 只在登录时加载 设置用户特定的环境变量 通常调用 ~/.bashrc ~/.bashrc 每次打开新的交互式 shell 时加载 设置命令别名、函数、提示符等 设置用户特定的环境变量 /etc/bash.bashrc 或 /etc/bashrc 系统级的 bashrc，对所有用户生效 在某些发行版中存在 /etc/profile.d/ 目录，包含多个脚本文件 被 /etc/profile 调用 方便软件包添加自己的环境设置 配置文件示例/etc/profile 示例： # /etc/profile# 系统范围的环境变量export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binexport EDITOR=vimexport PAGER=less# 设置 umaskumask 022# 加载 /etc/profile.d/ 下的所有脚本if [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi# 显示系统信息if [ -x /usr/bin/figlet ]; then figlet Welcomefi ~/.bash_profile 示例： # ~/.bash_profile# 获取 .bashrc 中的设置if [ -f ~/.bashrc ]; then source ~/.bashrcfi# 用户特定的环境变量export PATH=$PATH:$HOME/bin:$HOME/.local/binexport EDITOR=vimexport VISUAL=vimexport PAGER=less# 语言设置export LANG=en_US.UTF-8export LC_ALL=en_US.UTF-8# 启动 SSH agentif [ -z $SSH_AUTH_SOCK ]; then eval $(ssh-agent -s) ssh-add ~/.ssh/id_rsafi ~/.bashrc 示例： # ~/.bashrc# 如果不是交互式shell，则不继续[ -z $PS1 ] return# ===== 历史记录设置 =====export HISTSIZE=10000 # 内存中保存的命令数export HISTFILESIZE=20000 # 历史文件中保存的命令数export HISTCONTROL=ignoreboth:erasedups # 忽略空格开头和重复的命令export HISTTIMEFORMAT=%Y-%m-%d %H:%M:%S # 显示时间戳shopt -s histappend # 追加而不是覆盖历史文件shopt -s cmdhist # 多行命令作为一条记录# ===== 别名 =====alias ..=cd ..alias ...=cd ../..alias ....=cd ../../..alias ll=ls -alFalias la=ls -Aalias l=ls -CFalias grep=grep --color=autoalias fgrep=fgrep --color=autoalias egrep=egrep --color=autoalias rm=rm -ialias cp=cp -ialias mv=mv -ialias mkdir=mkdir -pvalias df=df -halias du=du -halias free=free -halias ps=ps auxfalias top=htopalias vim=nvimalias upgrade=sudo apt update sudo apt upgrade -y# ===== 函数 =====# 解压任意压缩文件extract() if [ -f $1 ]; then case $1 in *.tar.bz2) tar xjf $1 ;; *.tar.gz) tar xzf $1 ;; *.tar.xz) tar xJf $1 ;; *.bz2) bunzip2 $1 ;; *.rar) unrar x $1 ;; *.gz) gunzip $1 ;; *.tar) tar xf $1 ;; *.tbz2) tar xjf $1 ;; *.tgz) tar xzf $1 ;; *.zip) unzip $1 ;; *.Z) uncompress $1 ;; *.7z) 7z x $1 ;; *) echo Unknown format: $1 ;; esac else echo \\$1 is not a valid file fi# 创建目录并进入mkcd() mkdir -p $1 cd $1# 返回上级目录并列出内容up() cd .. ls# ===== 提示符设置 =====# 设置彩色提示符if [ -x /usr/bin/tput ] tput setaf 1 /dev/null; then # 支持颜色 PS1=\\[\\e[01;32m\\]\\u@\\h\\[\\e[00m\\]:\\[\\e[01;34m\\]\\w\\[\\e[00m\\]\\$ else PS1=\\u@\\h:\\w\\$ fi# ===== 其他设置 =====# 启用扩展通配符shopt -s extglobshopt -s globstar# 自动修正cd拼写错误shopt -s cdspell# 检查窗口大小变化shopt -s checkwinsize# 启用**递归匹配shopt -s globstar 2/dev/null# 加载本地配置（如果存在）if [ -f ~/.bash_local ]; then source ~/.bash_localfi# ===== 欢迎信息 =====echo Welcome, $USER!echo Today is $(date +%A, %B %d, %Y)echo System: $(uname -sr)echo Uptime: $(uptime -p 2/dev/null || uptime) 配置文件的加载顺序总结登录 Shell: /etc/profile └── /etc/profile.d/*.sh ~/.bash_profile | ~/.bash_login | ~/.profile (第一个存在的) └── ~/.bashrc └── /etc/bash.bashrc (某些系统)非登录交互式 Shell: ~/.bashrc └── /etc/bash.bashrc (某些系统)非交互式 Shell (执行脚本): $BASH_ENV 指定的文件 最佳实践： 系统级环境变量 → /etc/profile 用户环境变量 → ~/.bash_profile 或 ~/.profile 交互式设置（别名、函数、提示符） → ~/.bashrc 在 ~/.bash_profile 中调用 ~/.bashrc 确保登录时也加载交互式设置 10.2 Shell 的变量功能什么是变量变量是用于存储数据的命名内存空间。在 Shell 中，变量可以存储字符串、数字、命令输出等。 变量的分类 类型 说明 示例 局部变量 只在当前 Shell 中有效 var=value 环境变量 子进程也能访问 export var=value 位置参数 命令行参数 $1, $2, $@ 特殊变量 Shell 内置的特殊变量 $?, $$, $# 只读变量 不能被修改 readonly var=value 变量的定义和使用定义变量： # 基本语法：变量名=值（等号两边不能有空格！）name=John Doeage=25pi=3.14159# 错误的定义方式name = John # 错误：等号两边有空格$name=John # 错误：变量名不能用$开头 使用变量： # 使用$符号引用变量echo $nameecho $ageecho $pi# 使用花括号明确变量边界（推荐）echo My name is $nameecho PI = $pi# 花括号的必要性test_var=Helloecho $test_varworld # 错误：找不到变量test_varworldecho $test_varworld # 正确：输出 Helloworld 环境变量查看环境变量： env # 显示所有环境变量printenv # 同上printenv PATH # 显示特定环境变量echo $PATH # 同上 设置环境变量： # 临时设置（当前Shell）export PATH=$PATH:/new/pathexport MY_VAR=my value# 永久设置（添加到配置文件）echo export PATH=$PATH:/usr/local/go/bin ~/.bashrcsource ~/.bashrc # 立即生效 常用环境变量： 变量名 说明 示例 PATH 可执行文件的搜索路径 /usr/bin:/bin:/usr/sbin HOME 当前用户的主目录 /home/username USER 当前用户名 john SHELL 当前使用的 Shell /bin/bash LANG 系统语言设置 en_US.UTF-8 PWD 当前工作目录 /home/user/documents OLDPWD 上一次所在的目录 /home/user PS1 命令提示符 \\u@\\h:\\w\\$ PS2 续行提示符 EDITOR 默认编辑器 vim PAGER 默认分页器 less TERM 终端类型 xterm-256color DISPLAY X11 显示 :0 SSH_CLIENT SSH 客户端信息 192.168.1.100 12345 22 SSH_TTY SSH 分配的 TTY /dev/pts/0 特殊变量 变量 说明 示例 $0 脚本名称或 Shell 名称 myscript.sh $1 - $9 第1到第9个位置参数 arg1, arg2 $10 - $n 第10个及以后的位置参数 $10, $100 $* 所有位置参数（作为单个字符串） $1 $2 $3 $@ 所有位置参数（作为多个字符串） $1 $2 $3 $# 位置参数的数量 3 $? 上一个命令的退出状态码 0 表示成功 $$ 当前 Shell 的进程ID 12345 $! 最近一个后台进程的PID 12346 $_ 上一个命令的最后一个参数 或上一条命令本身 $- 当前 Shell 的标志位 himBH 位置参数示例： #!/bin/bash# test_args.shecho Script name: $0echo First argument: $1echo Second argument: $2echo Tenth argument: $10echo All arguments (\\$*): $*echo All arguments (\\$@): $@echo Number of arguments: $# 运行： ./test_args.sh arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 $* 和 $@ 的区别： #!/bin/bash# difference.shecho Using $*:for arg in $*; do echo [$arg]doneecho Using $@:for arg in $@; do echo [$arg]done 运行： ./difference.sh hello world foo bar# 输出：# Using $*:# [hello world foo bar]# Using $@:# [hello world]# [foo]# [bar] 变量的操作删除变量： unset var # 删除变量unset -v var # 同上（明确指定变量）unset -f function_name # 删除函数 只读变量： readonly var=value # 定义只读变量readonly var # 将已有变量设为只读readonly -p # 显示所有只读变量# 只读变量不能修改和删除 本地变量： local var=value # 在函数中定义局部变量local var # 声明局部变量，不赋值 默认值： $var:-default # 如果var未定义或为空，返回default，var不变$var:=default # 如果var未定义或为空，将var设为default并返回$var:?message # 如果var未定义或为空，显示错误信息并退出$var:+replacement # 如果var已定义且非空，返回replacement，否则返回空 示例： #!/bin/bash# :- 提供默认值name=$1:-Worldecho Hello, $name!# 运行: ./script.sh Alice # 输出: Hello, Alice!# 运行: ./script.sh # 输出: Hello, World!# := 设置默认值config_file=$CONFIG_FILE:=/etc/default.confecho Config: $config_file# 如果CONFIG_FILE未设置，将其设为默认值# :? 错误检查target_dir=$TARGET_DIR:?Error: TARGET_DIR is not set# 如果TARGET_DIR未设置，显示错误并退出# :+ 条件值debug_mode=$DEBUG:+--debug# 如果DEBUG已设置且非空，debug_mode=--debug，否则为空 字符串操作： # 获取字符串长度$#var# 提取子串（从0开始计数）$var:position # 从position到末尾$var:position:length # 从position开始，取length个字符# 删除匹配（最短匹配）$var#pattern # 删除开头匹配的pattern（最短）$var%pattern # 删除结尾匹配的pattern（最短）# 删除匹配（最长匹配）$var##pattern # 删除开头匹配的pattern（最长）$var%%pattern # 删除结尾匹配的pattern（最长）# 替换$var/pattern/replacement # 替换第一个匹配$var//pattern/replacement # 替换所有匹配$var/#pattern/replacement # 替换开头的匹配$var/%pattern/replacement # 替换结尾的匹配# 大小写转换（Bash 4.0+）$var^^ # 转大写$var,, # 转小写$var^ # 首字母大写$var, # 首字母小写$var^^pattern # 匹配pattern的字符转大写$var,,pattern # 匹配pattern的字符转小写 示例： #!/bin/bashpath=/home/user/documents/file.txt# 获取长度echo Length: $#path # 输出: 32# 提取子串echo $path:5 # 输出: user/documents/file.txtecho $path:5:4 # 输出: userecho $path: -8 # 输出: file.txt (从右边数8个)# 删除匹配（获取目录名和文件名）echo $path%/* # 输出: /home/user/documents (删除最后/及之后)echo $path##*/ # 输出: file.txt (删除最后/及之前)# 替换echo $path/file/document # 输出: /home/user/documents/document.txtecho $path//n/N # 输出: /home/user/documeNts/file.txt (所有n替换为N)# 大小写转换str=Hello Worldecho $str^^ # 输出: HELLO WORLDecho $str,, # 输出: hello worldecho $str^ # 输出: Hello world (只有首字母大写) 数组定义数组： # 方式1：空格分隔的值arr=(value1 value2 value3)# 方式2：使用索引arr[0]=value1arr[1]=value2arr[2]=value3# 方式3：混合方式arr=(value1 [3]=value4 value5)# 方式4：命令输出作为数组arr=($(ls *.txt))arr=($(cat file.txt))# 方式5：read命令read -a arr a b c 访问数组元素： arr=(apple banana cherry date)echo $arr[0] # 第一个元素: appleecho $arr[1] # 第二个元素: bananaecho $arr[-1] # 最后一个元素: dateecho $arr[-2] # 倒数第二个: cherryecho $arr[@] # 所有元素（数组形式）echo $arr[*] # 所有元素（字符串形式）echo $#arr[@] # 数组长度 数组操作： arr=(a b c d e)# 切片（获取子数组）echo $arr[@]:1 # 从索引1开始到末尾: b c d eecho $arr[@]:1:3 # 从索引1开始，取3个: b c decho $arr[@]: -2 # 最后2个: d e# 添加元素arr+=(f g) # 追加到末尾arr=(x $arr[@]) # 插入到开头arr=($arr[@]:0:2 new $arr[@]:2) # 插入到中间# 删除元素unset arr[1] # 删除索引1的元素arr=($arr[@]/b/) # 删除值为b的元素（重新创建数组）# 替换元素arr=($arr[@]/old/new) # 将所有old替换为new# 遍历数组for item in $arr[@]; do echo $itemdone# 带索引的遍历for i in $!arr[@]; do echo $i: $arr[$i]done# while遍历i=0while [ $i -lt $#arr[@] ]; do echo $arr[$i] ((i++))done 关联数组（Bash 4.0+）： # 声明关联数组declare -A assoc# 赋值assoc[name]=Johnassoc[age]=30assoc[city]=New York# 访问echo $assoc[name] # Johnecho $assoc[age] # 30# 获取所有键echo $!assoc[@] # name age city# 获取所有值echo $assoc[@] # John 30 New York# 长度echo $#assoc[@] # 3# 遍历for key in $!assoc[@]; do echo $key: $assoc[$key]done# 检查键是否存在if [ -v assoc[name] ]; then echo Key existsfi# 删除元素unset assoc[age] 10.3 数据流重定向什么是数据流重定向在 Linux 中，程序运行时会产生三种数据流： 数据流 文件描述符 默认指向 说明 标准输入 (stdin) 0 键盘 程序读取输入的地方 标准输出 (stdout) 1 屏幕 程序正常输出的地方 标准错误 (stderr) 2 屏幕 程序报错的地方 数据流重定向就是改变这些数据的默认流向。 输出重定向覆盖输出到文件： command file # 标准输出重定向到文件（覆盖）command 1 file # 同上（显式指定文件描述符1）command file # 标准输出追加到文件command 1 file # 同上 错误输出重定向： command 2 file # 标准错误重定向到文件（覆盖）command 2 file # 标准错误追加到文件 同时重定向标准输出和标准错误： # 方法1：分别重定向command stdout.log 2 stderr.log# 方法2：合并输出到同一个文件（旧语法）command file 21# 方法3：合并输出到同一个文件（新语法，推荐）command file 21command file # Bash 4.0+command file # 追加模式# 方法4：丢弃输出command /dev/null # 丢弃标准输出command 2 /dev/null # 丢弃错误输出command /dev/null 21 # 丢弃所有输出command /dev/null # Bash 4.0+ 输入重定向从文件输入： command file # 从文件读取输入cat file.txt # 从文件读取并显示sort input.txt # 从文件读取并排序 Here Document（多行输入）： command EOFline 1line 2line 3EOF# 示例cat ENDThis is a multi-line text.It will be displayed as is.Variables like $HOME will be expanded.END# 忽略变量扩展（用引号包围标记）cat EOF$HOME will NOT be expanded.It is displayed literally: $HOMEEOF# 去除前导制表符（用-）cat - EOF\tThis line has a tab.\tThis line also has a tab.\tThe tabs will be removed.EOF Here String（单行输入）： command string# 示例bc 1 + 2 # 计算 1 + 2grep pattern text to searchawk print $1 one two three 管道管道 | 将一个命令的标准输出连接到另一个命令的标准输入。 基本用法： command1 | command2 # command1的输出作为command2的输入command1 | command2 | command3 # 多级管道 常用组合： # 查找并排序ls -la | sort# 查找并计数ls | wc -l# 过滤日志cat /var/log/syslog | grep errorcat /var/log/syslog | grep error | head -20# 查找进程ps aux | grep nginx# 去重并计数cat file.txt | sort | uniqcat file.txt | sort | uniq -c | sort -nr# 复杂查询ps aux | grep [n]ginx | awk print $2 | xargs kill -9 管道与重定向结合： # 将管道的输出保存到文件ls -la | sort sorted.txt# 将错误也通过管道command 21 | next_command# 同时输出到文件和屏幕（使用tee）command | tee output.txt # 覆盖文件command | tee -a output.txt # 追加到文件command | tee file1.txt file2.txt # 输出到多个文件# tee与管道结合cat input.txt | tee /dev/tty | wc -l 高级重定向进程替换： # 将命令的输出作为文件command (list)# 示例：比较两个命令的输出diff (ls dir1) (ls dir2)# 将多个命令的输出合并cat (echo Header) (main_content.txt) (echo Footer)# 进程替换写入comm -12 (sort file1) (sort file2) 文件描述符操作： # 打开文件描述符exec 3 output.txt # 打开文件描述符3用于写入exec 4 input.txt # 打开文件描述符4用于读取exec 5 log.txt # 打开文件描述符5用于追加# 使用文件描述符echo Hello 3read line 4echo Log entry 5# 关闭文件描述符exec 3-exec 4-# 复制文件描述符exec 31 # 将stdout复制到3exec 1 output.txt # 重定向stdout# 恢复stdoutexec 13exec 3-# 复杂重定向示例# 同时记录stdout和stderr到不同文件，同时显示在屏幕exec 31 42 # 备份stdout和stderrexec 1 (stdbuf -oL tee stdout.log) # 重定向stdout到teeexec 2 (stdbuf -eL tee stderr.log) # 重定向stderr到tee# 恢复exec 13 24exec 3- 4- 本章重点总结 Shell 是用户与内核的接口，Bash 是 Linux 默认 Shell 变量分为局部变量、环境变量、位置参数、特殊变量 环境变量 PATH 决定命令搜索路径 数据流：stdin(0)、stdout(1)、stderr(2) 重定向： 覆盖、 追加、2 错误重定向、21 合并 管道 | 连接多个命令 Here Document 用于多行输入 配置文件：/etc/profile、~/.bash_profile、~/.bashrc 特殊变量：$? 退出状态、$$ 进程ID、$# 参数个数 引号：双引号允许变量扩展，单引号原样输出 10.4 命令执行的判断依据顺序执行与逻辑控制在 Shell 中，多个命令可以通过特定符号组合执行，实现流程控制。 分号 ; - 顺序执行command1; command2; command3 特点： 无论前一个命令是否成功，都执行后一个命令 命令按顺序依次执行 退出状态是最后一个命令的退出状态 示例： # 顺序执行多个命令echo Step 1; echo Step 2; echo Step 3# 编译并安装软件./configure; make; sudo make install# 备份操作cd /data; tar -czf backup.tar.gz important_files; mv backup.tar.gz /backup/# 无论成功与否都执行清理process_data; cleanup_temp_files - 逻辑与command1 command2 command3 特点： 前一个命令成功（退出状态为0）时，才执行后一个命令 如果某个命令失败，后续的命令不会执行 常用于条件判断 示例： # 确保目录存在后才进入mkdir -p /tmp/test cd /tmp/test# 先测试连接再传输ping -c 1 server.com scp file.txt server.com:/backup/# 编译链./configure make sudo make install# 检查文件存在才处理[ -f data.txt ] process_data.sh# 多条命令的条件执行command1 echo Command 1 succeeded command2 command3# 实际应用：安全删除check_important file.txt rm file.txt# 数据库操作connect_db run_migrations restart_server || - 逻辑或command1 || command2 || command3 特点： 前一个命令失败（退出状态非0）时，才执行后一个命令 如果某个命令成功，后续的命令不会执行 常用于提供备选方案或错误处理 示例： # 如果目录不存在则创建[ -d /tmp/test ] || mkdir /tmp/test# 如果本地没有则从网络获取[ -f package.tar.gz ] || wget http://example.com/package.tar.gz# 尝试多个镜像download_from_mirror1 || download_from_mirror2 || download_from_mirror3# 错误处理process_data || echo Error: Failed to process data 2 exit 1# 默认值username=$1:-$(whoami) || username=anonymous# 检查命令是否存在which git || echo Please install git# 实际应用：智能启动start_service || restart_service || notify_admin# 多级回退# 优先使用本地配置load_local_config || load_global_config || load_default_config# 错误处理和日志backup_database || logger -t backup Database backup failed send_alert_email exit 1 组合使用# 常见模式：如果成功则A，否则Bcommand success_action || failure_action# 注意：这种模式有陷阱！# 如果 success_action 失败，会执行 failure_action！# 应该使用 if 语句或分组# 安全的写法if command; then success_actionelse failure_actionfi# 或使用分组codecommand success_action; true; || failure_action; # 复杂条件# 多个条件同时满足command1 command2 command3 final_action# 任一条件满足command1 || command2 || command3 || final_action# 混合条件(command1 command2) || (command3 command4) || fallback# 实际应用# 智能编译[ -f Makefile ] make || [ -f CMakeLists.txt ] cmake .# 多级配置加载load_config_from ~/.app/config \\ || load_config_from /etc/app/config \\ || load_default_config# 条件部署run_tests build_package deploy_to_staging \\ || notify_deployment_failure# 安全删除[ -w $file ] [ ! -d $file ] rm $file \\ || echo Cannot remove $file 2# 智能服务管理pgrep mysqld mysqladmin ping || systemctl restart mysql 退出状态码每个命令执行后都会返回一个退出状态码（exit status），可以用 $? 获取： 状态码 含义 0 成功 1 通用错误 2 误用命令（Bash内置命令） 126 命令不可执行 127 命令未找到 128 无效退出参数 128+N 致命信号 N（如 130 Ctrl+C） 130 脚本被Ctrl+C终止 255 退出状态码超出范围 查看退出状态： ls /existing/direcho $? # 输出: 0ls /nonexistentecho $? # 输出: 2command_not_foundecho $? # 输出: 127 在脚本中使用退出状态： #!/bin/bash# 检查命令是否成功if ping -c 1 google.com /dev/null 21; then echo Network is up exit 0else echo Network is down exit 1fi 自定义退出状态： #!/bin/bash# 定义退出码readonly SUCCESS=0readonly ERROR_GENERAL=1readonly ERROR_INVALID_ARGS=2readonly ERROR_FILE_NOT_FOUND=3readonly ERROR_PERMISSION=4# 检查参数if [ $# -eq 0 ]; then echo Usage: $0 file 2 exit $ERROR_INVALID_ARGSfi# 检查文件if [ ! -f $1 ]; then echo Error: File $1 not found 2 exit $ERROR_FILE_NOT_FOUNDfi# 检查权限if [ ! -r $1 ]; then echo Error: Cannot read $1 2 exit $ERROR_PERMISSIONfi# 处理文件process_file $1exit $SUCCESS 本章总结 Shell 是命令解释器，Bash 是 Linux 默认 Shell 变量：局部变量、环境变量、位置参数、特殊变量 引号：双引号允许变量扩展，单引号原样输出，反引号执行命令 重定向： 覆盖、 追加、2 错误、21 合并 管道 | 连接多个命令，实现数据流传递 命令分隔符：; 顺序执行、 逻辑与、|| 逻辑或 退出状态码：0 表示成功，非 0 表示失败，存储在 $? 中 数组：支持索引数组和关联数组（Bash 4.0+） 配置文件：/etc/profile、~/.bash_profile、~/.bashrc 等的加载顺序 字符串操作：提取子串、删除匹配、替换、大小写转换等 10.5 管道命令管道命令| 是 Linux Shell 中非常强大的功能，它允许将一个命令的输出直接作为另一个命令的输入，实现数据的流水线处理。 管道的工作原理命令1 | 命令2 | 命令3 | ... | 命令N ↓ ↓ ↓ ↓ 输出1 输入2 输出2 最终输出 输入3 关键点： 管道连接的是标准输出到标准输入 管道中的每个命令在子shell中执行 管道可以包含任意数量的命令 常用管道命令1. cut - 切割提取从每行中提取指定部分： # 按字符位置cut -c 1-5 file.txt # 提取第1-5个字符cut -c 1,3,5 file.txt # 提取第1、3、5个字符cut -c 5- file.txt # 从第5个字符到末尾# 按字段（默认制表符分隔）cut -f 1 file.txt # 提取第1个字段cut -f 1,3 file.txt # 提取第1和第3个字段cut -f 2-4 file.txt # 提取第2-4个字段# 指定分隔符cut -d : -f 1 /etc/passwd # 使用:作为分隔符cut -d , -f 2 data.csv # 使用,作为分隔符# 排除字段cut --complement -f 1 file.txt # 提取除第1字段外的所有字段 管道示例： # 提取用户名grep bin/bash /etc/passwd | cut -d : -f 1# 提取IP地址ifconfig eth0 | grep inet | cut -d -f 10# 提取进程PIDps aux | grep nginx | grep -v grep | cut -c 10-15# 提取CSV的特定列cat data.csv | cut -d , -f 1,3,5 | sort 2. grep - 文本过滤使用正则表达式搜索文本： # 基本用法grep pattern file.txt # 在文件中搜索grep pattern dir/*.txt # 在多个文件中搜索cat file.txt | grep pattern # 管道使用# 选项-i # 忽略大小写-v # 反向匹配（显示不匹配的行）-n # 显示行号-c # 统计匹配行数-l # 只显示包含匹配的文件名-L # 只显示不包含匹配的文件名-r # 递归搜索目录-w # 匹配整个单词-x # 匹配整行-A 3 # 显示匹配行及后3行-B 3 # 显示匹配行及前3行-C 3 # 显示匹配行及前后3行-E # 使用扩展正则表达式-F # 按字面意思搜索（不使用正则）-o # 只显示匹配的部分-q # 静默模式（不输出，用于判断）--color=auto # 高亮显示匹配# 正则表达式示例grep ^start file # 以start开头grep end$ file # 以end结尾grep a.b file # a和b之间有任意一个字符grep a*b file # 0个或多个a后跟bgrep a\\+b file # 1个或多个a后跟b（需要-E）grep a\\?b file # 0或1个a后跟b（需要-E）grep [abc] file # a或b或cgrep [^abc] file # 不是a、b、c的字符grep \\3\\ file # 正好3个（需要转义）grep -E a2,4 file # 2到4个a 管道示例： # 查找并过滤ps aux | grep nginx | grep -v grep# 统计进程数ps aux | grep [h]ttpd | wc -l# 查找错误日志cat /var/log/syslog | grep -i error | tail -20# 复杂过滤ps aux | awk print $2, $11 | grep chrome | grep -v grep | awk print $1# 查找大文件du -ah /home | grep -E ^[0-9]+M|^[0-9]+G | sort -hr | head -10# 查找IP地址ifconfig | grep inet | grep -v 127.0.0.1 | awk print $2# 统计单词频率cat file.txt | tr | sort | uniq -c | sort -nr | head -20 3. sort - 文本排序对文本行进行排序： # 基本用法sort file.txt # 按字母顺序排序cat file.txt | sort # 管道使用# 常用选项-r # 逆序（降序）-n # 按数字排序-k 2 # 按第2列排序-k 2,3 # 按第2到3列排序-t : # 指定分隔符-f # 忽略大小写-u # 去重（相当于sort | uniq）-c # 检查是否已排序-C # 检查是否已排序（静默）-m # 合并已排序的文件-s # 稳定排序-b # 忽略前导空白-h # 人类可读大小排序（如2K,1M）--version-sort # 版本号排序# 数字排序示例echo -e 10 2 1 20 | sort -n# 输出：1, 2, 10, 20# 按特定列排序cat data.txt | sort -k 3 -n # 按第3列数字排序# 复杂排序ps aux | sort -k 3 -nr | head -5 # 按CPU使用率排序 管道示例： # 排序并去重cat file.txt | sort -u# 按大小排序du -sh /home/* | sort -h# 按内存使用排序ps aux | sort -k 4 -nr | head -10# 复杂查询ps aux | grep -E (nginx|php) | sort -k 3 -nr | awk print $2, $11 4. uniq - 去重过滤或报告重复的行（需要先排序）： # 基本用法（需要去重前的行是排序的）sort file.txt | uniq # 去重# 常用选项-c # 统计每行出现的次数-d # 只显示重复的行-u # 只显示不重复的行（唯一）-i # 忽略大小写-f N # 跳过前N个字段-s N # 跳过前N个字符-w N # 只比较前N个字符--all-repeated=METHOD # 显示所有重复行（prepend/separate/both）# 统计出现次数sort file.txt | uniq -c | sort -nr # 按频率排序# 找出重复项sort file.txt | uniq -d# 找出唯一项sort file.txt | uniq -u 管道示例： # 统计IP访问频率awk print $1 access.log | sort | uniq -c | sort -nr | head -20# 统计单词频率cat file.txt | tr | sort | uniq -c | sort -nr | head -20# 找出重复的文件（按MD5）find /path -type f -exec md5sum \\; | sort | uniq -d -w32# 统计进程名ps aux | awk print $11 | sort | uniq -c | sort -nr 5. wc - 统计统计行数、单词数、字节数： wc file.txt # 显示行数、单词数、字节数wc -l file.txt # 只显示行数wc -w file.txt # 只显示单词数wc -c file.txt # 只显示字节数wc -m file.txt # 只显示字符数wc -L file.txt # 显示最长行的长度# 统计多个文件wc file1.txt file2.txt# 管道使用ls | wc -l # 统计文件数grep pattern file | wc -l # 统计匹配行数 管道示例： # 统计代码行数find . -name *.py | xargs wc -l# 统计进程数ps aux | wc -l# 统计用户登录数who | wc -l# 统计唯一IP数awk print $1 access.log | sort | uniq | wc -l 6. tee - 双向输出同时将输出显示在屏幕并保存到文件： command | tee file.txt # 覆盖文件command | tee -a file.txt # 追加到文件command | tee -i file.txt # 忽略中断信号# 输出到多个文件command | tee file1.txt file2.txt file3.txt# 与sudo结合使用（将权限提升应用于重定向）echo content | sudo tee /etc/config.conf# 既显示又保存，同时传递给下一个命令cat file.txt | tee /dev/tty | wc -l 7. tr - 字符转换转换或删除字符： # 基本转换echo hello | tr a-z A-Z # 转大写echo HELLO | tr A-Z a-z # 转小写# 删除字符tr -d a file.txt # 删除所有atr -d 0-9 file.txt # 删除所有数字# 压缩重复字符tr -s file.txt # 将多个空格压缩为单个# 替换特定字符echo hello world | tr _# 删除非字母字符tr -cd a-zA-Z file.txt# 转换换行为空格cat file.txt | tr # ROT13编码/解码echo hello | tr A-Za-z N-ZA-Mn-za-mecho uryyb | tr A-Za-z N-ZA-Mn-za-m 8. split - 文件分割将大文件分割成多个小文件： # 按行数分割split -l 1000 large.txt part_ # 每1000行一个文件，前缀为part_# 按大小分割split -b 10M large.bin part_ # 每个文件10MBsplit -b 1G large.iso part_ # 每个文件1GB# 指定输出文件名split -l 100 large.txt output_# 使用数字后缀（默认）split -l 100 -d large.txt part_# 指定后缀长度split -l 100 -d -a 4 large.txt part_# 合并分割的文件cat part_* original_file# 使用tar分割打包文件tar czf - large_dir | split -b 100M - large_dir.tar.gz.part_# 合并并解压cat large_dir.tar.gz.part_* | tar xzf - 管道命令总结 命令 功能 常用选项 cut 按列提取 -d, -f, -c grep 文本过滤 -i, -v, -n, -r sort 文本排序 -n, -r, -k, -t uniq 去重 -c, -d, -u wc 统计 -l, -w, -c tee 双向输出 -a, -i tr 字符转换 -d, -s split 文件分割 -l, -b 管道实战示例# 1. 分析网站访问日志，找出访问最多的IPcat access.log | awk print $1 | sort | uniq -c | sort -rn | head -10# 2. 查找大文件并排序du -ah /home | grep -E ^[0-9]+(\\.[0-9]+)?G | sort -hr | head -10# 3. 统计代码行数find . -name *.py -o -name *.js -o -name *.java | xargs wc -l | tail -1# 4. 批量重命名（去除特定后缀）ls *.bak | while read f; do mv $f $f%.bak; done# 5. 查找并杀死进程ps aux | grep [n]ginx | awk print $2 | xargs kill -9# 6. 日志分析：统计每小时的错误数awk print $4 error.log | cut -d: -f1 | sort | uniq -c# 7. 合并多个文件并去重cat file1.txt file2.txt file3.txt | sort | uniq merged.txt# 8. 提取邮件地址grep -oE [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]2, file.txt | sort -u# 9. 比较两个文件的不同comm (sort file1.txt) (sort file2.txt)diff file1.txt file2.txt# 10. 实时监控日志tail -f access.log | grep --line-buffered 500 | tee errors.txt 10.6 重点回顾 Shell 是命令解释器，Bash 是 Linux 默认 Shell 变量：定义 var=value，使用 $var 或 $var 环境变量：export var=value，子进程可继承 特殊变量：$? 退出状态、$$ 进程ID、$# 参数个数、$@ 所有参数 数据流：stdin(0)、stdout(1)、stderr(2) 重定向： 覆盖、 追加、2 错误重定向、21 合并到stdout 管道 | 将一个命令的输出作为另一个命令的输入 命令组合：; 顺序执行、 逻辑与、|| 逻辑或 引号：双引号允许变量扩展，单引号原样输出 配置文件加载顺序：/etc/profile → ~/.bash_profile → ~/.bashrc 常用管道命令：cut、grep、sort、uniq、wc、tee、tr 数组：索引数组 arr=(a b c)，关联数组 declare -A assoc 字符串操作：长度 $#var、提取 $var:pos:len、替换 $var/old/new 10.7 本章习题 什么是 Shell？Shell 和 Bash 有什么关系？ 定义一个变量 myvar=Hello，然后输出它的值。请用三种不同的方式引用这个变量。 解释 $?、$$、$#、$@、$* 的含义和区别。 编写一个脚本，接受两个参数，输出它们的和。如果没有提供参数，使用默认值 0。 解释以下命令的区别： echo $HOME echo $HOME echo $HOME echo \\$HOME 如何将一个命令的输出保存到文件？如何追加到文件？如何将错误信息也保存到文件？ 解释 command1 command2 || command3 的执行逻辑。这种写法有什么潜在问题？ 使用管道组合命令，找出当前目录下占用空间最大的5个文件。 编写一个脚本，从 /etc/passwd 中提取用户名、UID 和 Shell，按 UID 排序后显示。 解释以下配置文件的作用和加载顺序：/etc/profile、~/.bash_profile、~/.bashrc、/etc/bash.bashrc。 10.8 参考资料与延伸阅读 man bash man 1 read man 1 test Bash Reference Manual Advanced Bash-Scripting Guide Bash Hackers Wiki ShellCheck - Shell 脚本静态分析工具","tags":[null,null,null,null]},{"title":"Linux 基础入门","path":"/wiki/Linux/linux-basics.html","content":"Linux 基础入门计算机概论计算机的组成 输入单元：键盘、鼠标、扫描仪等 输出单元：显示器、打印机等 控制单元：协调各组件工作 算术逻辑单元 (ALU)：进行数学和逻辑运算 记忆单元：内存和存储设备 CPU 架构 架构类型 代表厂商 特点 CISC Intel, AMD 复杂指令集，性能强，功耗高 RISC ARM, Apple Silicon 精简指令集，低功耗，高效能 Linux 简介什么是 Linux？Linux 是一种类 Unix 操作系统内核，由 Linus Torvalds 于 1991 年首次发布。 Linux 的组成┌─────────────────────────────────────┐│ 应用程序层 │ ← Shell、编辑器、浏览器等├─────────────────────────────────────┤│ Shell 层 │ ← Bash、Zsh、Fish 等├─────────────────────────────────────┤│ 内核层 (Kernel) │ ← 进程管理、内存管理、文件系统等├─────────────────────────────────────┤│ 硬件层 │ ← CPU、内存、硬盘、外设等└─────────────────────────────────────┘ 流行的 Linux 发行版 服务器领域Red Hat Enterprise Linux - 企业级支持CentOS - 社区企业版 (现已转向 Stream)Ubuntu Server - 易用，社区活跃Debian - 稳定，适合服务器SUSE - 欧洲企业首选 桌面领域Ubuntu - 最受欢迎的桌面版Fedora - 新技术试验田Linux Mint - 适合新手Manjaro - 基于 Arch，易用Pop!_OS - 适合开发者 特殊用途Kali Linux - 安全渗透测试Alpine - 轻量级容器基础Arch Linux - 滚动更新，高度定制Gentoo - 源码编译，极致优化 学习路径建议graph LR A[基础入门] --> B[命令行操作] B --> C[文件系统] C --> D[权限管理] D --> E[Shell脚本] E --> F[系统管理] F --> G[网络配置] G --> H[服务部署] style A fill:#4CAF50 style H fill:#FF5722 千里之行，始于足下"},{"title":"文件系统与目录结构","path":"/wiki/Linux/linux-filesystem.html","content":"文件系统与目录结构Linux 目录结构概览Linux 采用单根目录树结构，所有文件和目录都从根目录 / 开始组织。 / (根目录)│├── /bin # 基本用户命令（二进制文件）├── /boot # 启动加载器文件├── /dev # 设备文件├── /etc # 系统配置文件├── /home # 用户主目录│ ├── /home/alice│ ├── /home/bob│ └── ...├── /lib # 共享库文件├── /media # 可移动媒体挂载点├── /mnt # 临时挂载点├── /opt # 可选应用软件├── /proc # 进程信息虚拟文件系统├── /root # root 用户主目录├── /run # 运行时变量数据├── /sbin # 系统管理命令├── /srv # 服务数据├── /sys # 系统信息虚拟文件系统├── /tmp # 临时文件├── /usr # 用户程序和数据│ ├── /usr/bin # 用户命令│ ├── /usr/lib # 库文件│ ├── /usr/local # 本地安装软件│ └── /usr/share # 共享数据└── /var # 可变数据文件 ├── /var/log # 日志文件 ├── /var/spool # 任务队列 └── /var/tmp # 持久临时文件 重要目录详解 bin 和 sbin/bin - Essential user binaries单用户模式下也需要的命令例如：ls, cp, mv, cat, mkdir/sbin - System binaries系统管理命令例如：fdisk, fsck, reboot, iptables etc系统配置文件重要配置文件：/etc/passwd - 用户账户信息/etc/shadow - 用户密码（加密）/etc/group - 群组信息/etc/hosts - 主机名解析/etc/fstab - 文件系统表/etc/resolv.conf - DNS 配置/etc/crontab - 定时任务/etc/ssh/sshd_config - SSH 配置 home 和 root/home - 普通用户主目录/home/├── alice/ ← 用户 alice 的家├── bob/ ← 用户 bob 的家└── charlie/ ← 用户 charlie 的家/root - root 用户主目录root 是超级管理员与普通用户分离，提高安全性 var可变数据文件/var/log - 系统日志/var/log/syslog 或 /var/log/messages/var/log/auth.log 或 /var/log/secure/var/log/kern.log/var/spool - 任务队列/var/spool/cron - 定时任务/var/spool/mail - 用户邮件/var/cache - 应用缓存/var/lib - 应用状态数据/var/lib/mysql - MySQL 数据/var/lib/dpkg - 包管理状态 文件系统类型常见 Linux 文件系统 文件系统 特点 适用场景 EXT4 稳定、成熟、 journaling 通用，推荐大多数场景 XFS 高性能大文件、并行IO 大数据、媒体存储 Btrfs 快照、压缩、校验和 高级功能需求 ZFS 企业级特性、数据完整性 企业存储、NAS F2FS 针对闪存优化 SSD、嵌入式设备 文件系统层次标准 (FHS)Filesystem Hierarchy Standard (FHS) FHS 定义了类 Unix 系统中目录结构和目录内容的标准，确保软件能在不同的 Linux 发行版间兼容。 查看当前系统 FHS 合规性： # 检查关键目录是否存在ls -la / | grep -E bin|boot|dev|etc|home|lib|media|mnt|opt|proc|root|run|sbin|srv|sys|tmp|usr|var# 查看文件系统挂载情况df -hT# 查看当前挂载的文件系统cat /proc/mounts 实用命令速查目录操作文件操作文件系统管理查找与定位# 显示当前目录pwd# 切换目录cd /path/to/dir # 绝对路径cd ../parent # 相对路径cd ~ # 回到用户主目录cd - # 回到上次目录# 列出目录内容ls # 基本列表ls -la # 显示所有文件（包括隐藏）ls -lh # 人类可读格式ls -lt # 按时间排序ls -ltr # 按时间倒序# 创建目录mkdir dirname # 创建单个目录mkdir -p path/to/nested/dir # 创建嵌套目录# 删除目录rmdir dirname # 删除空目录rm -r dirname # 递归删除目录rm -rf dirname # 强制递归删除（谨慎使用！）# 复制目录cp -r source dest # 递归复制# 移动/重命名目录mv oldname newname # 重命名mv source /path/to/dest # 移动# 创建文件touch filename # 创建空文件 filename # 创建空文件（重定向）# 查看文件内容cat filename # 显示全部内容cat -n filename # 显示行号less filename # 分页查看（支持上下滚动）more filename # 分页查看（只能向下）head filename # 显示前10行head -n 20 filename # 显示前20行tail filename # 显示后10行tail -n 20 filename # 显示后20行tail -f filename # 实时追踪文件更新（常用于日志）# 编辑文件nano filename # 简单编辑器vim filename # 强大编辑器vi filename # 兼容模式# 搜索文件内容grep pattern filename # 基本搜索grep -i pattern filename # 忽略大小写grep -n pattern filename # 显示行号grep -r pattern /path/ # 递归搜索目录grep -v pattern filename # 反向匹配（排除）# 文件比较diff file1 file2 # 比较两个文件差异cmp file1 file2 # 逐字节比较# 文件统计wc filename # 统计行数、单词数、字节数wc -l filename # 只统计行数wc -w filename # 只统计单词数# 查看磁盘空间df -h # 人类可读格式df -hT # 显示文件系统类型df -i # 查看 inode 使用情况# 查看目录/文件大小du -sh /path # 查看目录总大小du -h --max-depth=1 /path # 查看子目录大小du -ah /path | sort -rh | head -20 # 找出最大的20个文件# 文件系统检查（需要卸载或使用 live CD）fsck /dev/sda1 # 检查并修复文件系统e2fsck /dev/sda1 # ext 文件系统专用# 挂载与卸载mount /dev/sdb1 /mnt/usb # 挂载设备mount -o loop iso.iso /mnt/iso # 挂载 ISO 文件umount /mnt/usb # 卸载mount | grep /dev/sda # 查看挂载状态# 创建文件系统mkfs.ext4 /dev/sdb1 # 创建 ext4 文件系统mkfs.xfs /dev/sdb1 # 创建 xfs 文件系统mkswap /dev/sdb2 # 创建 swap 分区# LVM 基本操作pvcreate /dev/sdb # 创建物理卷vgcreate vg0 /dev/sdb # 创建卷组lvcreate -L 10G -n lv0 vg0 # 创建逻辑卷# find 命令（功能最强大）find /path -name *.txt # 按名称查找find /path -iname *.txt # 忽略大小写find /path -type f -name *.log # 只找文件find /path -type d -name backup # 只找目录find /path -size +100M # 大于100MB的文件find /path -size -1k # 小于1KB的文件find /path -mtime -7 # 7天内修改过的文件find /path -user username # 属于某用户的文件find /path -perm 644 # 特定权限的文件find /path -name *.tmp -delete # 查找并删除find /path -name *.log -exec gzip \\; # 查找并压缩find /path -name *.txt | xargs grep pattern # 结合 xargs 使用# locate 命令（基于数据库，速度更快）updatedb # 更新 locate 数据库locate filename # 快速查找文件locate -i filename # 忽略大小写locate *.conf # 支持通配符locate -n 10 *.log # 限制结果数量# which 和 whereiswhich command # 查找命令的可执行文件位置which -a command # 显示所有匹配的路径whereis command # 查找命令的二进制、源码和 man 手册whereis -b command # 只找二进制文件# type 命令type command # 显示命令类型（别名、内置命令、外部命令）type -a command # 显示所有匹配项 延伸阅读 Linux 文件系统层次标准 (FHS) 鸟哥的 Linux 私房菜 - 目录配置 理解目录结构是掌握 Linux 的第一步"},{"title":"文件权限管理","path":"/wiki/Linux/linux-permissions.html","content":"文件权限管理权限基础概念Linux 使用三种权限控制文件访问：读取(r)、写入(w)、执行(x)。这三种权限分别应用于三类用户：文件所有者(u)、所属群组(g)、其他用户(o)。 权限类型详解 读取权限 (r)文件：可读取文件内容目录：可列出目录内容（ls） 写入权限 (w)文件：可修改文件内容目录：可在目录中创建、删除、重命名文件 执行权限 (x)文件：可作为程序执行目录：可进入目录（cd） 查看文件权限使用 ls -l 命令ls -l filenamels -la /path/to/directory 输出示例解析： $ ls -l test.txt-rw-r--r-- 1 alice developers 1234 Jan 15 10:30 test.txt│└┬┘└┬┘└┬┘│ │ │ │ ││ │ │ │ │ │ │ │ └── 文件名│ │ │ │ │ │ │ └──────────── 修改时间│ │ │ │ │ │ └─────────────────── 所属群组│ │ │ │ │ └────────────────────────── 文件所有者│ │ │ │ └─────────────────────────────── 硬链接数│ │ │ └───────────────────────────────── 其他用户权限│ │ └───────────────────────────────────── 群组权限│ └───────────────────────────────────────── 所有者权限└─────────────────────────────────────────── 文件类型 文件类型标识 标识 类型 说明 - 普通文件 文本、数据、可执行文件等 d 目录 包含文件和其他目录 l 符号链接 指向其他文件的引用 c 字符设备 按字符流访问的设备（如终端） b 块设备 按块访问的设备（如硬盘） s 套接字 进程间通信端点 p 命名管道 进程间通信 修改文件权限chmod 命令详解符号模式数字模式参考速查表chmod [who][operator][permission] file... 参数说明： 类别 选项 含义 Who u 用户（所有者） g 群组 o 其他用户 a 所有用户（等同于 ugo） Operator + 添加权限 - 移除权限 = 设置精确权限 Permission r 读取权限 w 写入权限 x 执行权限 X 仅当文件是目录或已有执行权限时添加执行权限 s 设置 SUID 或 SGID t 设置粘滞位 示例： # 添加执行权限chmod +x script.sh # 给所有用户添加执行权限chmod u+x program # 仅给所有者添加执行权限# 移除权限chmod o-w file.txt # 移除其他用户的写入权限chmod go-rwx secret.txt # 移除群组和其他用户的所有权限# 设置精确权限chmod u=rwx,g=rx,o=r file # 所有者读写执行，群组读执行，其他只读# 递归修改目录chmod -R 755 /path/to/dir # 递归修改目录及其内容chmod [mode] file... 权限数字对应表： 权限 二进制 数字 --- 000 0 --x 001 1 -w- 010 2 -wx 011 3 r-- 100 4 r-x 101 5 rw- 110 6 rwx 111 7 常用权限组合： Mode 权限 用途 777 rwxrwxrwx 完全开放（不推荐） 755 rwxr-xr-x 标准可执行文件目录 750 rwxr-x— 私有可执行文件目录 700 rwx—— 完全私有 644 rw-r–r– 标准普通文件 640 rw-r—– 群组可读 600 rw——- 私有文件 示例： chmod 755 script.sh # 可执行脚本chmod 644 document.txt # 普通文档chmod 600 ~/.ssh/id_rsa # 私钥文件chmod 700 ~/private_dir # 私有目录chmod -R 755 ~/bin # 递归设置常用文件权限设置： # Web 服务器目录find /var/www -type d -exec chmod 755 \\;find /var/www -type f -exec chmod 644 \\;# SSH 密钥chmod 700 ~/.sshchmod 600 ~/.ssh/id_rsachmod 644 ~/.ssh/id_rsa.pubchmod 644 ~/.ssh/authorized_keyschmod 644 ~/.ssh/known_hosts# 脚本文件chmod +x script.sh # 添加执行权限chmod u+s program # 设置 SUID 修改文件所有者和群组chown 命令chown [选项] [所有者][:群组] 文件... 常用选项： -R : 递归修改目录及其内容 -c : 只在发生改变时报告 -v : 显示详细处理过程 --reference=RFILE : 使用参考文件的属主 示例： # 修改所有者chown alice file.txt# 修改群组chown :developers file.txtchgrp developers file.txt # 等效命令# 同时修改所有者和群组chown alice:developers file.txt# 递归修改目录chown -R alice:alice /home/alice/project# 使用参考文件chown --reference=template.txt newfile.txt# 仅修改符号链接本身（而非目标）chown -h alice symlink chgrp 命令专门用于修改群组： chgrp [选项] 群组 文件... 示例： chgrp developers project/chgrp -R www-data /var/www 特殊权限SUID (Set User ID)当可执行文件设置了 SUID 位，用户执行该文件时，进程的有效用户ID会变成文件所有者的ID，而不是执行者的ID。 应用场景：passwd 命令 $ ls -l /usr/bin/passwd-rwsr-xr-x 1 root root 68208 Jul 15 2021 /usr/bin/passwd ↑ SUID 位（所有者的 x 位置） 普通用户可以通过 passwd 修改自己的密码（需要写入 etcshadow），就是因为 passwd 有 SUID 位，执行时临时获得了 root 权限。 设置 SUID： chmod u+s /path/to/program # 符号模式chmod 4755 /path/to/program # 数字模式（4 表示 SUID） 注意： 大写 S 表示没有执行权限但设置了 SUID SUID 对目录无效（在某些 BSD 系统上有特殊用途） 不当使用 SUID 可能带来安全风险 SGID (Set Group ID)对可执行文件类似于 SUID，但继承的是文件所属群组的权限。 $ ls -l /usr/bin/wall-rwxr-sr-x 1 root tty 30800 Feb 28 2022 /usr/bin/wall ↑ SGID 位（群组的 x 位置） 对目录在设置了 SGID 的目录中创建的新文件，其所属群组会自动继承目录的群组，而不是创建者的主群组。 应用场景：共享项目目录 # 创建项目目录mkdir /srv/projectchgrp developers /srv/projectchmod 2770 /srv/project # 设置 SGID# 现在任何在此目录创建的文件都属于 developers 群组 设置 SGID： chmod g+s /path/to/directory # 符号模式chmod 2775 /path/to/directory # 数字模式（2 表示 SGID） 注意：大写 S 表示没有执行权限但设置了 SGID。 Sticky Bit (粘滞位)粘滞位只对目录有效。设置了粘滞位的目录，只有文件所有者、目录所有者或 root 才能删除或重命名该目录中的文件，即使其他用户有写权限也不行。 典型应用：/tmp 目录 $ ls -ld /tmpdrwxrwxrwt 15 root root 4096 Jan 15 10:30 /tmp ↑ 粘滞位（其他人的 x 位置） 所有用户都可以在 /tmp 创建文件，但只能删除自己的文件，防止恶意删除他人的临时文件。 设置粘滞位： chmod +t /path/to/directory # 符号模式chmod 1777 /path/to/directory # 数字模式（1 表示粘滞位） 注意：大写 T 表示没有执行权限但设置了粘滞位。 特殊权限速查表┌─────────────────────────────────────────────────────┐│ 权限位布局 │├─────────────────────────────────────────────────────┤│ SUID │ SGID │ Sticky │ User │ Group │ Other ││ (4) │ (2) │ (1) │ (rwx) │ (rwx) │ (rwx) │└─────────────────────────────────────────────────────┘常用组合：├── 4755 (rwsr-xr-x) = SUID + 755├── 2755 (rwxr-sr-x) = SGID + 755├── 1777 (rwxrwxrwt) = Sticky + 777 (如 /tmp)└── 6755 (rwsr-sr-x) = SUID + SGID + 755符号模式：├── u+s = 设置 SUID├── g+s = 设置 SGID├── o+t = 设置粘滞位└── a = 所有用户 (u+g+o) 实践练习练习：设置共享开发目录 场景：团队共享的项目目录 /srv/webapp # 1. 创建目录并设置正确的群组sudo mkdir -p /srv/webappsudo groupadd webdevsudo chown root:webdev /srv/webapp# 2. 设置 SGID，使新文件继承目录群组sudo chmod 2770 /srv/webapp# 3. 设置目录权限# 2 = SGID, 7 = rwx (所有者), 7 = rwx (群组), 0 = --- (其他)sudo chmod 2770 /srv/webapp# 4. 将开发用户添加到群组sudo usermod -aG webdev alicesudo usermod -aG webdev bob# 5. 验证设置ls -ld /srv/webapp# 预期输出：drwxrws--- 2 root webdev ...# 6. 测试（切换到开发用户）su - alicetouch /srv/webapp/test.txtls -l /srv/webapp/test.txt# 预期：文件群组应该是 webdev，而不是 alice 的主群组 练习：SUID 安全分析 任务：分析系统中的 SUID 文件 # 1. 查找所有 SUID 文件find / -perm -4000 -type f 2/dev/null# 2. 查找所有 SGID 文件find / -perm -2000 -type f 2/dev/null# 3. 详细查看 SUID 文件find /usr/bin -perm -4000 -ls 2/dev/null# 4. 检查可疑的自定义 SUID 程序# 正常的 SUID 程序通常在标准位置# /usr/bin/passwd# /usr/bin/sudo# /usr/bin/su# /usr/bin/mount# /usr/bin/umount# /usr/bin/ping# ...# 5. 安全审计脚本echo === SUID 文件安全审计 ===echo 系统 SUID 文件数量：find / -perm -4000 -type f 2/dev/null | wc -lecho echo 非标准位置的 SUID 文件：find / -perm -4000 -type f 2/dev/null | grep -v -E ^/(usr/|bin/|sbin/|usr/sbin/)echo echo 最近修改的 SUID 文件：find / -perm -4000 -type f -mtime -7 2/dev/null 常见问题 FAQ为什么无法访问文件，即使我是 root？ 可能原因：文件位于挂载为 noexec、nodev 或 nosuid 的文件系统上。 # 查看挂载选项mount | grep /path/to/mount# 示例输出：# /dev/sda1 on /home type ext4 (rw,nosuid,nodev,noexec,relatime)# 解决方案：重新挂载（临时）sudo mount -o remount,exec,suid /home# 或编辑 /etc/fstab 永久修改 如何恢复误删的权限？ 场景：不小心执行了 chmod -R 777 / # 1. 立即停止系统写入（避免更多损坏）# 2. 使用 Live CD/USB 启动# 3. 挂载根分区sudo mount /dev/sda1 /mnt# 4. 使用包管理器恢复默认权限（推荐）# Debian/Ubuntu:sudo dpkg --root=/mnt --configure -a# CentOS/RHEL/Fedora:# 使用 rpm 恢复或重新安装关键包# 5. 手动修复关键目录sudo chmod 755 /mnt/bin /mnt/lib /mnt/lib64 /mnt/sbin /mnt/usrsudo chmod 555 /mnt/bootsudo chmod 1777 /mnt/tmpsudo chmod 755 /mnt/var# 6. 验证并重启 预防措施： 使用 chmod --reference 代替手动设置 重要操作前使用 getfacl -R /path permissions_backup.acl 备份权限 ACL 与基本权限的区别？ 基本权限的局限： 只能设置一个所有者 只能设置一个群组 其他人的权限是统一的 ACL (Access Control List) 的优势： 可以为多个用户设置不同权限 可以为多个群组设置不同权限 支持默认 ACL（新文件自动继承） # 检查文件系统是否支持 ACLmount | grep acl# 安装 ACL 工具sudo apt-get install acl # Debian/Ubuntusudo yum install acl # CentOS/RHEL# 查看 ACLgetfacl filename# 设置 ACLsetfacl -m u:alice:rwx filename # 给用户 alice 设置 rwxsetfacl -m g:developers:rw filename # 给群组 developers 设置 rwsetfacl -x u:alice filename # 移除 alice 的 ACLsetfacl -b filename # 移除所有 ACL# 设置默认 ACL（目录）setfacl -d -m u:alice:rwx /shared/dirsetfacl -R -m u:alice:rwx /shared/dir # 递归设置 延伸阅读 Linux 文件权限完全指南 Understanding Linux File Permissions ACL - Arch Wiki 权限管理是 Linux 安全的基石"},{"title":"进程管理","path":"/wiki/Linux/linux-process.html","content":"进程管理进程基础概念进程 (Process) 是程序的一次执行实例，是系统进行资源分配和调度的基本单位。每个进程都有独立的内存空间和系统资源。 进程与程序的区别 概念 定义 特点 程序 (Program) 存储在磁盘上的可执行文件 静态的、永久的 进程 (Process) 程序的运行实例 动态的、临时的 比喻： 程序 菜谱 进程 按照菜谱做菜的过程 进程的类型 按交互方式分类前台进程 (Foreground)与用户直接交互占据终端可以接收键盘输入后台进程 (Background)在后台运行不占据终端适合长时间运行的任务 按启动方式分类交互式进程由用户从终端启动如：bash、vim、firefox批处理进程与终端无关，提交到作业队列如：at、batch 启动的任务守护进程 (Daemon)系统启动时自动运行一直在后台运行通常以 ‘d’ 结尾命名如：sshd、httpd、crond 按进程关系分类父进程 (Parent Process)创建其他进程的进程子进程 (Child Process)被创建的进程继承父进程的许多属性孤儿进程 (Orphan Process)父进程提前退出被 initsystemd 收养僵尸进程 (Zombie Process)已终止但未被父进程回收占用少量资源 进程标识每个进程都有唯一的标识符： 标识符 说明 获取方式 PID (Process ID) 进程唯一标识 echo $$ PPID (Parent PID) 父进程 ID echo $PPID PGID (Process Group ID) 进程组 ID ps -o pgid= -p pid SID (Session ID) 会话 ID ps -o sid= -p pid UID (User ID) 进程所有者 ID ps -o uid= -p pid EUID (Effective UID) 有效用户 ID ps -o euid= -p pid # 查看当前 Shell 的 PIDecho $$# 查看当前 Shell 的 PPIDecho $PPID# 查看指定进程的信息ps -f -p $$ # 详细格式ps -o pid,ppid,cmd -p $$# 查看所有进程树pstreepstree -p # 显示 PIDpstree -u # 显示用户名 查看进程ps 命令ps (Process Status) 是最基础的进程查看命令。 基本用法输出字段解释进程状态 (STAT)高级用法# 查看当前终端的进程ps# 显示所有进程（BSD 风格）ps aux# 显示所有进程（System V 风格）ps -ef# 显示完整格式ps auxf # 树状格式ps -ejH # 进程树BSD 风格 (ps aux)： 字段 含义 说明 USER 进程所有者 启动进程的用户 PID 进程 ID 唯一标识符 %CPU CPU 使用率 进程占用的 CPU 百分比 %MEM 内存使用率 进程占用的物理内存百分比 VSZ 虚拟内存大小 Virtual Memory Size (KB) RSS 常驻内存大小 Resident Set Size (KB) TTY 控制终端 进程关联的终端 STAT 进程状态 见下方详细说明 START 启动时间 进程开始运行的时间 TIME CPU 时间 进程累计使用的 CPU 时间 COMMAND 命令 启动进程的命令及参数 System V 风格 (ps -ef)： 字段 含义 UID 用户 ID PID 进程 ID PPID 父进程 ID C CPU 使用率 STIME 开始时间 TTY 终端 TIME CPU 时间 CMD 命令 状态码 含义 说明 R Running Runnable 正在运行或在运行队列中等待 S Interruptible Sleep 可中断睡眠，等待某个条件 D Uninterruptible Sleep 不可中断睡眠，通常在进行 IO T Stopped 被信号停止（如 Ctrl+Z） t Tracing Stop 被调试器跟踪停止 Z Zombie 僵尸进程，已终止但未被回收 X Dead 死亡进程（不应该看到） 附加状态标志： 标志 含义 高优先级 N 低优先级 L 有锁定页面（用于实时） s 会话领导者 l 多线程 + 前台进程组 # 自定义输出格式ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%cpu | head# 查找特定用户的进程ps -u usernameps aux | grep ^username# 按内存使用排序ps aux --sort=-%mem | head -10# 按 CPU 使用排序ps aux --sort=-%cpu | head -10# 显示进程树ps axjfps -eo pid,ppid,cmd | sort -n | head# 显示线程ps -eLfps aux -L# 结合其他命令ps aux | grep nginx | grep -v grepps aux | awk print $11 | sort | uniq -c | sort -rn top 命令top 提供动态的进程监控视图。 top 命令详解 # 基本使用top# 指定刷新间隔（秒）top -d 1# 显示特定用户的进程top -u username# 显示指定进程top -p PID1,PID2,PID3# 批处理模式（用于脚本）top -b -n 1 交互命令（在 top 运行时按）： 按键 功能 ? h 帮助 q 退出 Space 立即刷新 k 终止进程（输入 PID） r 修改进程优先级（renice） c 切换显示完整命令 M 按内存使用排序 P 按 CPU 使用排序 T 按运行时间排序 N 按 PID 排序 u 过滤特定用户 n 设置显示进程数 i 切换显示空闲进程 V 树状显示 t 切换 CPU 状态显示 m 切换内存状态显示 1 显示每个 CPU 核心 W 保存配置到 ~.toprc 输出字段说明： top - 14:30:25 up 3 days, 2:15, 2 users, load average: 0.52, 0.58, 0.59Tasks: 235 total, 1 running, 234 sleeping, 0 stopped, 0 zombie%Cpu(s): 5.2 us, 2.1 sy, 0.0 ni, 92.3 id, 0.2 wa, 0.0 hi, 0.2 si, 0.0 stKiB Mem : 8167844 total, 1234567 free, 3456789 used, 3476488 buff/cacheKiB Swap: 2097148 total, 2097148 free, 0 used. 4321098 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1234 alice 20 0 123456 78901 12345 S 5.2 1.0 2:34.56 firefox ... 行字段 说明 第1行 系统时间和运行时间 14:30:25 当前时间 up 3 days, 2:15 系统已运行时间 2 users 当前登录用户数 load average 1515分钟平均负载 第2行 任务统计 235 total 总进程数 1 running 运行中 234 sleeping 睡眠中 0 stopped 已停止 0 zombie 僵尸进程 第3行 CPU 使用率 us 用户空间 sy 系统空间 ni nice 调整后的用户空间 id 空闲 wa IO 等待 hi 硬中断 si 软中断 st 被虚拟机偷走的时间 第4-5行 内存和交换空间 进程列表 各进程详情 进程控制前台与后台进程后台运行作业控制nohup 和 disown# 在命令末尾加 ，在后台运行long_running_command # 示例sleep 60 ./backup_script.sh output.log 21 # 查看后台作业jobs# 输出示例：[1] + running sleep 60[2] - suspended vim file.txt# 将前台作业挂起（暂停）Ctrl + Z# 查看作业列表jobsjobs -l # 显示 PIDjobs -p # 只显示 PID# 将后台作业切换到前台fg %1 # 作业号 1fg %vim # 以 vim 开头的作业fg %% # 当前作业（+）fg %+ # 当前作业fg %- # 上一个作业# 将作业在后台继续运行bg %1bg %2# 杀死作业kill %1# 等待作业完成wait %1echo $? # 获取作业退出状态# nohup - 忽略挂起信号，退出终端后继续运行nohup command nohup ./script.sh output.log 21 # nohup 会自动将输出重定向到 nohup.out（如果没有指定）nohup python3 server.py # 输出到 nohup.out# disown - 从当前 shell 的作业表中移除作业# 这样退出 shell 时不会向作业发送 SIGHUP# 在后台运行long_running_task # 从作业表中移除disown# 或指定作业disown %1# 或者一开始就 disown(long_running_task ) 信号 (Signals)信号是进程间通信的一种机制，用于通知进程发生了某个事件。 常用信号 信号 数值 名称 默认动作 说明 1 SIGHUP Hangup 终止 终端挂起或控制进程结束 2 SIGINT Interrupt 终止 来自键盘的中断（Ctrl+C） 3 SIGQUIT Quit 核心转储 来自键盘的退出（Ctrl+\\） 6 SIGABRT Abort 核心转储 调用 abort() 产生 9 SIGKILL Kill 终止 强制终止，不可捕获或忽略 15 SIGTERM Terminate 终止 正常终止信号（默认） 18 SIGCONT Continue 继续 继续执行暂停的进程 19 SIGSTOP Stop 暂停 暂停进程执行（Ctrl+Z） 20 SIGTSTP TTY Stop 暂停 终端停止信号 关键信号详解： # SIGHUP (1) - 终端断开信号# 传统上，终端断开时向进程组发送 SIGHUP# nohup 命令就是用来忽略这个信号的# SIGINT (2) - 中断信号# Ctrl+C 发送# 进程可以捕获并优雅地退出# SIGKILL (9) - 强制终止# 不能被捕获、阻塞或忽略# 进程无法清理资源，可能留下临时文件# 最后手段，不是首选# SIGTERM (15) - 终止信号# kill 命令默认发送# 可以被捕获，进程可以优雅地清理和退出# 首选的正常终止方式# SIGSTOP (19) / SIGCONT (18)# 暂停和继续执行# SIGSTOP 不能被捕获或忽略 发送信号的方式： # kill 命令kill PID # 发送 SIGTERM (15)kill -9 PID # 发送 SIGKILL (9)kill -SIGKILL PIDkill -KILL PID# 向多个进程发送信号kill PID1 PID2 PID3# 根据进程名杀死killall process_namekillall -9 process_namekillall -u username process_name# pkill - 根据模式匹配pkill process_namepkill -f full command linepkill -u username# 键盘快捷键Ctrl + C # 发送 SIGINT (2)Ctrl + Z # 发送 SIGTSTP (20)Ctrl + \\ # 发送 SIGQUIT (3) 捕获信号示例： #!/bin/bash# 定义清理函数cleanup() echo 收到终止信号，正在清理... # 清理临时文件 rm -f /tmp/my_script_temp_$$ # 关闭资源 echo 清理完成，退出 exit 0# 捕获信号trap cleanup SIGTERM SIGINT SIGHUP# 主程序echo 程序运行中... (PID: $$)echo 临时文件: /tmp/my_script_temp_$$touch /tmp/my_script_temp_$$# 模拟长时间运行的任务while true; do echo 工作中... $(date) sleep 5done 系统监控工具htop - 交互式进程查看器# 安装sudo apt-get install htop # Debian/Ubuntusudo yum install htop # CentOS/RHEL# 启动htop 交互按键： 按键 功能 F1 ? 帮助 F2 S 设置 F3 / 搜索进程 F4 \\\\ 过滤器 F5 t 树状显示 F6 选择排序字段 F7 [ 降低进程优先级 (nice +) F8 ] 提高进程优先级 (nice -) F9 k 杀死进程 F10 q 退出 u 按用户过滤 M 按内存排序 P 按 CPU 排序 T 按时间排序 I 反转排序 l 显示隐藏线程 vmstat - 虚拟内存统计# 基本用法vmstat # 显示一次vmstat 1 # 每秒更新vmstat 1 10 # 每秒更新，共10次vmstat -s # 显示事件计数器vmstat -a # 显示活跃/非活跃内存vmstat -d # 显示磁盘统计vmstat -D # 显示磁盘活动摘要vmstat -p /dev/sda1 # 显示特定分区统计vmstat -f # 显示 fork 统计# 输出解释procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 2 0 0 123456 78901 456789 0 0 10 20 100 200 5 2 93 0 0procs: r: 运行队列中的进程数 b: 等待 I/O 的进程数memory: swpd: 使用的虚拟内存 (KB) free: 空闲内存 (KB) buff: 用作缓冲区的内存 (KB) cache: 用作缓存的内存 (KB)swap: si: 从磁盘交换入内存 (KB/s) so: 从内存交换出到磁盘 (KB/s)io: bi: 从块设备读取 (blocks/s) bo: 写入块设备 (blocks/s)system: in: 中断数 (/s) cs: 上下文切换数 (/s)cpu: us: 用户空间时间 (%) sy: 系统空间时间 (%) id: 空闲时间 (%) wa: I/O 等待时间 (%) st: 被虚拟机偷走的时间 (%) iostat - IO 统计# 安装sudo apt-get install sysstat# 基本用法iostat # 显示 CPU 和磁盘统计iostat 1 # 每秒更新iostat 1 10 # 每秒更新，共10次iostat -c # 只显示 CPU 统计iostat -d # 只显示磁盘统计iostat -x # 显示扩展统计iostat -m # 以 MB/s 显示iostat -k # 以 KB/s 显示iostat -p sda # 显示特定设备iostat -p ALL # 显示所有设备和分区# 输出解释Linux 5.4.0-65-generic (hostname) 01/15/2024 _x86_64_ (4 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 5.23 0.01 2.15 0.50 0.00 92.11Device tps kB_read/s kB_wrtn/s kB_dscd/s kB_read kB_wrtn kB_dscdsda 12.34 45.67 89.01 0.00 1234567 2345678 0sdb 0.12 1.23 0.45 0.00 12345 4567 0# 扩展统计 (iostat -x)Device r/s w/s rkB/s wkB/s rrqm/s wrqm/s %rrqm %wrqm r_await w_await aqu-sz rareq-sz wareq-sz svctm %utilsda 2.34 10.00 45.67 89.01 0.12 3.45 4.89 25.67 3.45 8.90 0.12 19.52 8.90 0.80 0.98# 字段说明avg-cpu: %user - 用户空间程序使用的 CPU 百分比 %nice - 带有 nice 优先级的用户程序 %system - 内核空间使用的 CPU 百分比 %iowait - 等待 I/O 完成的时间百分比 %steal - 虚拟机管理程序占用的时间 %idle - CPU 空闲时间百分比Device: tps - 每秒传输次数 (I/O 请求数) kB_read/s - 每秒读取的数据量 (KB) kB_wrtn/s - 每秒写入的数据量 (KB) kB_dscd/s - 每秒丢弃的数据量 (KB)扩展统计: r/s - 每秒读取请求数 w/s - 每秒写入请求数 rkB/s - 每秒读取 KB 数 wkB/s - 每秒写入 KB 数 rrqm/s - 每秒合并的读取请求 wrqm/s - 每秒合并的写入请求 %rrqm - 读取请求合并百分比 %wrqm - 写入请求合并百分比 r_await - 读取请求平均等待时间 (ms) w_await - 写入请求平均等待时间 (ms) aqu-sz - 平均队列长度 rareq-sz - 平均读取请求大小 (KB) wareq-sz - 平均写入请求大小 (KB) svctm - 平均服务时间 (ms) %util - 设备带宽利用率 其他监控工具# dstat - 全能系统监控工具sudo apt-get install dstatdstat # 默认显示 CPU、磁盘、网络、系统负载dstat -y # 带单位显示dstat --full # 完整统计dstat -cdngy 1 # 显示 CPU、磁盘、网络、分页，每秒刷新dstat --output report.csv 1 60 # 输出到 CSV 文件# sar - 系统活动报告sudo apt-get install sysstatsar -u 1 10 # CPU 使用率，每秒，共 10 次sar -r 1 10 # 内存使用率sar -d 1 10 # 块设备活动sar -n DEV 1 10 # 网络设备统计sar -q 1 10 # 队列长度和负载sar -A # 所有统计# 查看历史数据sar -f /var/log/sysstat/sa15 # 查看 15 号的数据# nethogs - 按进程显示网络带宽sudo apt-get install nethogssudo nethogs # 显示每个进程的网络使用sudo nethogs eth0 # 监控特定接口# iotop - I/O 监控sudo apt-get install iotopsudo iotop # 显示 I/O 使用情况sudo iotop -o # 只显示有 I/O 的进程sudo iotop -b -n 5 # 批处理模式，采集 5 次# pidstat - 进程统计sudo apt-get install sysstatpidstat # CPU 统计pidstat -r # 内存统计pidstat -d # I/O 统计pidstat -w # 任务切换统计pidstat -u 1 5 # CPU，每秒，5 次pidstat -t -p PID # 显示指定进程的线程# slabtop - 内核 slab 缓存监控time slabtop# vmstat - 虚拟内存统计（前面已介绍）# perf - 性能分析工具sudo apt-get install linux-tools-common linux-tools-genericsudo perf top # 实时性能分析sudo perf stat -a sleep 5 # 5 秒系统级统计sudo perf record -a -g -- sleep 30 # 记录 30 秒sudo perf report # 查看报告 进程优先级nice 和 renice# nice - 以指定优先级启动进程# 取值范围：-20（最高优先级）到 19（最低优先级）# 默认：0# 普通用户只能设置正 nice 值# 以低优先级运行nice -n 10 long_running_tasknice --10 command # 注意：--10 表示 -10# renice - 修改运行中进程的优先级renice -n 5 -p PID # 修改指定进程renice -n 5 -u username # 修改某用户的所有进程renice -n 5 -g groupname # 修改某群组的所有进程# 查看进程优先级ps -eo pid,ni,cmd | grep firefoxpidstat -u -p PID # PR 列显示优先级# chrt - 实时调度策略chrt -f -p 99 PID # 设置 SCHED_FIFO，优先级 99chrt -r -p 50 PID # 设置 SCHED_RR，优先级 50chrt -o -p 0 PID # 设置 SCHED_OTHER（普通）chrt -p PID # 查看调度策略 实践练习练习：找出最耗资源的进程 #!/bin/bash# find_heavy_processes.shecho === CPU 使用率最高的 10 个进程 ===ps aux --sort=-%cpu | head -11 | tail -10 | awk printf %-10s %6s %5s %5s %s , $1, $2, $3, $4, $11echo echo === 内存使用率最高的 10 个进程 ===ps aux --sort=-%mem | head -11 | tail -10 | awk printf %-10s %6s %5s %5s %s , $1, $2, $3, $4, $11echo echo === 运行时间最长的 10 个进程 ===ps -eo user,pid,etime,cmd --sort=etime | tail -10echo echo === 当前用户的进程统计 ===echo 进程总数: $(ps -u $USER -o pid= | wc -l)echo CPU 使用: $(ps aux | awk -v user=$USER $1==user sum+=$3 END print sum %)echo 内存使用: $(ps aux | awk -v user=$USER $1==user sum+=$4 END print sum %) 练习：监控系统并自动处理高负载 #!/bin/bash# monitor_and_act.shLOG_FILE=/var/log/system_monitor.logCPU_THRESHOLD=80 # CPU 使用率阈值MEM_THRESHOLD=90 # 内存使用率阈值LOAD_THRESHOLD=$(nproc) # 负载阈值（核心数）log_message() echo [$(date +%Y-%m-%d %H:%M:%S)] $1 | tee -a $LOG_FILE# 获取系统信息get_system_info() CPU_USAGE=$(top -bn1 | grep Cpu(s) | awk print $2 | cut -d% -f1) MEM_USAGE=$(free | grep Mem | awk printf %.1f, $3/$2 * 100.0) LOAD_AVG=$(uptime | awk -Fload average: print $2 | awk print $1 | tr -d ,) DISK_USAGE=$(df -h / | tail -1 | awk print $5 | tr -d %)# 杀死最耗 CPU 的用户进程kill_heavy_processes() log_message WARNING: High CPU usage detected ($CPU_USAGE%). Taking action... # 获取最耗 CPU 的用户进程（排除 root 和系统进程） HEAVY_PIDS=$(ps aux --sort=-%cpu | grep -v ^root\\|^USER | head -5 | awk print $2) for PID in $HEAVY_PIDS; do PROCESS_INFO=$(ps -p $PID -o pid,ppid,cmd,%cpu --no-headers 2/dev/null) if [ -n $PROCESS_INFO ]; then log_message Killing process: $PROCESS_INFO kill -TERM $PID 2/dev/null sleep 2 # 检查是否仍在运行 if kill -0 $PID 2/dev/null; then log_message Process $PID still running, using SIGKILL kill -KILL $PID 2/dev/null fi fi done# 清理内存缓存clean_memory() log_message WARNING: High memory usage detected ($MEM_USAGE%). Cleaning caches... # 需要 root 权限 if [ $(id -u) -eq 0 ]; then sync echo 3 /proc/sys/vm/drop_caches log_message Memory caches cleaned else log_message WARNING: Root privileges required to clean memory caches fi# 主监控循环main() log_message System monitor started (PID: $$) log_message Thresholds - CPU: $CPU_THRESHOLD%, Memory: $MEM_THRESHOLD%, Load: $LOAD_THRESHOLD while true; do get_system_info log_message Status - CPU: $CPU_USAGE%, Memory: $MEM_USAGE%, Load: $LOAD_AVG, Disk: $DISK_USAGE% # 检查阈值 if (( $(echo $CPU_USAGE $CPU_THRESHOLD | bc -l) )); then kill_heavy_processes fi if (( $(echo $MEM_USAGE $MEM_THRESHOLD | bc -l) )); then clean_memory fi # 等待下次检查 sleep 60 done# 处理退出信号trap log_message Monitor stopped; exit 0 SIGTERM SIGINT# 运行main 延伸阅读 Linux Process Management Understanding Linux proc Signal Handling in Linux 理解进程管理是系统管理的核心技能"},{"title":"Shell 基础","path":"/wiki/Linux/linux-shell.html","content":"Shell 基础什么是 Shell？Shell 是用户与 Linux 内核之间的命令解释器。它接收用户输入的命令，解释后传递给内核执行，并将结果返回给用户。 用户 ←→ Shell ←→ Linux 内核 ←→ 硬件 常见 Shell 类型 Bourne 系列sh - Bourne Shell，最早的 Unix Shellbash - Bourne Again Shell，Linux 默认dash - Debian Almquist Shell，轻量版zsh - Z Shell，功能强大ksh - Korn Shell，商业 Unix 常用 C 系列csh - C Shell，语法类似 C 语言tcsh - TENEX C Shell，csh 增强版其他fish - Friendly Interactive Shell，用户友好 查看和切换 Shell# 查看当前 Shellecho $SHELL# 查看可用的 Shellchsh -lcat /etc/shells# 临时切换 Shellbashzshfish# 永久切换默认 Shellchsh -s /bin/zsh# 需要重新登录生效 Bash 基础命令基本格式command [options] [arguments]命令 [选项] [参数] 示例： ls -la /home/user│ ││ ││ ││ └── 参数：操作的目标│ │└────── 选项：-l 长格式，-a 显示所有文件│ └──────── 短选项可以合并└──────────── 命令：列出目录内容 命令行快捷键光标移动文本编辑命令控制 快捷键 功能 Ctrl + A 移到行首 Ctrl + E 移到行尾 Ctrl + F 向前移动一个字符（同 →） Ctrl + B 向后移动一个字符（同 ←） Alt + F 向前移动一个单词 Alt + B 向后移动一个单词 快捷键 功能 Ctrl + D 删除当前字符 Ctrl + H 删除前一个字符（同 Backspace） Ctrl + W 删除前一个单词 Alt + D 删除后一个单词 Ctrl + K 删除从光标到行尾的内容 Ctrl + U 删除从行首到光标的内容 Ctrl + Y 粘贴最近删除的内容 快捷键 功能 Ctrl + C 终止当前命令 Ctrl + Z 挂起当前命令（放入后台） Ctrl + L 清屏（同 clear 命令） Ctrl + S 暂停屏幕输出 Ctrl + Q 恢复屏幕输出 Ctrl + R 搜索命令历史 Ctrl + G 取消搜索 Tab 自动补全命令路径 Tab Tab 显示所有可能的补全 历史命令# 查看历史命令historyhistory | tail -20 # 最近20条history | grep apt # 搜索包含 apt 的历史命令# 执行历史命令!! # 执行上一条命令!n # 执行第 n 条历史命令!-n # 执行倒数第 n 条!string # 执行以 string 开头的最近命令!?string # 执行包含 string 的最近命令!$:p # 显示上一条命令的最后一个参数# 历史命令展开示例$ echo Hello WorldHello World$ echo !! # 执行 echo echo Hello Worldecho Hello World$ echo one two three$ echo !^ # 第一个参数: one$ echo !$ # 最后一个参数: three$ echo !* # 所有参数: one two three# 修改并执行上一条命令$ cat file1$ ^cat^ls # 将 cat 替换为 ls，执行 ls file1# 搜索历史命令Ctrl + R # 交互式搜索(reverse-i-search)`apt: sudo apt update # 输入关键词搜索Ctrl + R (again) # 查找上一个匹配Ctrl + S # 向前搜索（如果终端支持）Ctrl + G / Esc # 取消搜索 环境变量常用环境变量 变量 说明 示例 PATH 可执行文件搜索路径 /usr/local/bin:/usr/bin:/bin HOME 当前用户主目录 /home/alice USER LOGNAME 当前用户名 alice SHELL 当前 Shell /bin/bash PWD 当前工作目录 /home/alice/project OLDPWD 上一个工作目录 /home/alice LANG 系统语言区域设置 en_US.UTF-8 TERM 终端类型 xterm-256color EDITOR 默认文本编辑器 vim VISUAL 默认可视化编辑器 vim PS1 主提示符格式 \\u@\\h:\\w\\$ PS2 次提示符 HISTSIZE 历史命令保存数量 1000 HISTFILE 历史命令文件 ~/.bash_history MAIL 用户邮箱 /var/spool/mail/alice SSH_CLIENT SSH 客户端信息 10.0.0.5 12345 22 SSH_TTY SSH 分配的 TTY /dev/pts/0 XDG_SESSION_TYPE 会话类型 x11 或 wayland XDG_CURRENT_DESKTOP 当前桌面环境 GNOME 或 KDE 查看和设置环境变量# 查看单个变量echo $PATHecho $HOMEecho $USER # 使用花括号避免歧义# 查看所有环境变量envprintenvprintenv PATH # 查看特定变量# 设置临时变量（仅当前 shell）MY_VAR=Hello Worldecho $MY_VAR# 导出为环境变量（子进程可用）export MY_VAR=Hello Worldexport PATH=$PATH:/new/path# 删除变量unset MY_VAR# 在命令行临时设置（仅本次命令）LANG=zh_CN.UTF-8 date# 变量操作$VAR:-default # 如果 VAR 未设置，使用 default$VAR:=default # 如果 VAR 未设置，设为 default$VAR:+value # 如果 VAR 已设置，使用 value$VAR:?error # 如果 VAR 未设置，显示 error 并退出$#VAR # 字符串长度$VAR:offset:length # 子字符串$VAR#pattern # 删除最短匹配的前缀$VAR##pattern # 删除最长匹配的前缀$VAR%pattern # 删除最短匹配的后缀$VAR%%pattern # 删除最长匹配的后缀$VAR/pattern/replace # 替换第一个匹配$VAR//pattern/replace # 替换所有匹配$VAR/#pattern/replace # 替换开头匹配$VAR/%pattern/replace # 替换结尾匹配$VAR^ # 首字母大写$VAR^^ # 全部大写$VAR, # 首字母小写$VAR,, # 全部小写 配置环境变量当前用户生效（~/.bashrc 或 ~/.bash_profile）： # 编辑配置文件nano ~/.bashrc# 添加环境变量export PATH=$HOME/bin:$PATHexport EDITOR=vimexport HISTSIZE=10000export HISTTIMEFORMAT=%Y-%m-%d %H:%M:%S # 使配置生效source ~/.bashrc 所有用户生效（/etc/profile 或 /etc/environment）： # 系统级环境变量sudo nano /etc/profile# 添加export PATH=/usr/local/bin:$PATHexport JAVA_HOME=/usr/lib/jvm/java-11# 或者使用 /etc/profile.d/（推荐）sudo nano /etc/profile.d/custom.sh 优先级（由高到低）： 命令行中直接设置 ~/.bashrc ~/.bash_profile ~/.profile /etc/profile /etc/environment 延伸阅读 Bash Reference Manual Advanced Bash-Scripting Guide Explain Shell - 可视化解释命令 熟练掌握 Shell 是成为 Linux 高手的必经之路"},{"title":"C语言32个关键字","path":"/wiki/c/c-keywords.html","content":"C语言32个关键字 ⭐ 高优先级：必须掌握，所有 C 语言程序都由这些关键字组合而成 什么是关键字？关键字（Keywords）是 C 语言中预保留且具有特殊含义的单词，不能用作变量名、函数名或其他用户定义的标识符。C 语言共有 32 个关键字，掌握它们就等于掌握了 C 语言的核心。 关键字按功能大致分为： 数据类型关键字：定义变量和数据的类型 控制语句关键字：控制程序的执行流程 存储类型关键字：指定变量的存储方式和作用域 其他关键字：用于特定功能的特殊关键字 数据类型关键字基本数据类型 关键字 说明 示例 void 声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果 void func(void); char 字符型数据，属于整型数据的一种，通常占 1 字节 char c = A; int 整型数据，通常为编译器指定的机器字长 int age = 25; float 单精度浮点型数据，小数点后保存 6 位有效数字 float pi = 3.14f; double 双精度浮点型数据，小数点后保存 15-16 位有效数字 double e = 2.71828; 类型修饰符 关键字 说明 示例 short 修饰 int，短整型数据，可省略被修饰的 int short s = 100; long 修饰 int，长整型数据，可省略被修饰的 int long l = 100000L; signed 修饰整型数据，有符号数据类型（默认） signed int i = -10; unsigned 修饰整型数据，无符号数据类型，只能表示正数 unsigned int u = 10; 构造类型 关键字 说明 示例 struct 结构体声明，将不同类型的数据组合在一起 struct Student int age; char name[20]; ; union 共用体声明，不同类型数据共享同一内存空间 union Data int i; float f; ; enum 枚举声明，定义一组命名的整数常量 enum Color RED, GREEN, BLUE ; 存储类型关键字 关键字 说明 作用域 生命周期 auto 自动变量，由编译器自动分配及释放，通常在栈上分配 局部 临时 static 静态变量，分配在静态变量区；修饰函数时限定作用域为文件内部 局部全局 永久 register 寄存器变量，建议编译器将变量存储到寄存器中以提高访问速度 局部 临时 extern 外部变量，声明变量或函数在其他文件中定义 全局 永久 typedef 类型别名，为已有类型定义新的名称 - - 提示 auto 是局部变量的默认存储类型，很少显式使用。 static 用于限制变量作用域或延长生命周期。 register 只是建议，编译器可能忽略。 extern 用于跨文件共享变量和函数。 typedef 不创建新类型，只是为现有类型创建别名。 控制语句关键字选择语句 关键字 说明 示例 if 条件判断语句 if (x 0) ... else 与 if 配合使用，条件不满足时执行 else ... switch 多分支选择语句 switch (day) ... case switch 中的分支标签 case 1: ...; default switch 中的默认分支 default: ...; 循环语句 关键字 说明 示例 for for 循环语句 for (int i = 0; i 10; i++) ... while while 循环语句 while (condition) ... do do-while 循环语句，先执行后判断 do ... while (condition); 跳转语句 关键字 说明 示例 break 跳出当前循环或 switch 语句 break; continue 结束本次循环，开始下一次循环 continue; goto 无条件跳转语句（不推荐） goto label; return 从函数返回，可带回返回值 return 0; 运算符关键字 关键字 说明 示例 sizeof 计算特定类型或变量的大小（字节） int size = sizeof(int); 完整关键字列表C 语言 32 个关键字按字母顺序排列： auto break case char const continuedefault do double else enum externfloat for goto if int longregister return short signed sizeof staticstruct switch typedef union unsigned voidvolatile while 💡 C99 新增 _Bool、_Complex、_Imaginary；C11 新增 _Alignas、_Generic 等。传统的 32 个关键字仍是最核心、最常用的一组。 学习建议 分类记忆：按功能分类记忆，理解用途与场景。 多写代码：在实际代码中多次使用关键字，加深理解。 对比学习：对比相似关键字，如 struct vs union、while vs do-while 等。 下一步学习 main 函数详解：理解程序入口点。 第 2 章 C 语言基础：数据类型和表达式。 第 3 章 程序设计基本结构：掌握控制流程。"},{"title":"经典案例与解析","path":"/wiki/c/cases.html","content":"经典案例与解析⭐实战案例 通过实际项目巩固理论知识 案例目录 案例1：学生成绩管理系统（入门版） 案例2：简易计算器 案例3：猜数字游戏 案例4：图书管理系统（进阶版） 案例5：通讯录管理系统 案例6：贪吃蛇游戏 案例1：学生成绩管理系统（入门版）📋 案例说明这是一个基础版的学生成绩管理系统，使用数组和结构体实现，适合初学者掌握基本的输入输出和数组操作。 **涉及知识点：**数组、循环、选择结构、函数、结构体 难度等级：⭐⭐ (初级) 💡 功能需求 添加学生信息（姓名、学号、成绩） 显示所有学生信息 计算平均分 查找最高分学生 按成绩排序 💻 完整代码#include #include #define MAX_STUDENTS 50// 学生结构体struct Student char name[50]; int id; float score;;// 全局变量struct Student students[MAX_STUDENTS];int studentCount = 0;// 函数声明void addStudent();void displayStudents();void calculateAverage();void findTopStudent();void sortByScore();void showMenu();int main() int choice; while (1) showMenu(); printf(请选择操作（1-6）：); scanf(%d, choice); switch (choice) case 1: addStudent(); break; case 2: displayStudents(); break; case 3: calculateAverage(); break; case 4: findTopStudent(); break; case 5: sortByScore(); break; case 6: printf(感谢使用，再见！ ); return 0; default: printf(无效选择，请重新输入！ ); printf( 按回车键继续...); getchar(); getchar(); // 清空输入缓冲区 system(clear); // Linux/Mac 使用 clear // system(cls); // Windows 使用 cls return 0;// 显示菜单void showMenu() printf( ); printf(================================= ); printf( 学生成绩管理系统（入门版） ); printf(================================= ); printf(1. 添加学生 ); printf(2. 显示所有学生 ); printf(3. 计算平均分 ); printf(4. 查找最高分学生 ); printf(5. 按成绩排序 ); printf(6. 退出系统 ); printf(================================= );// 添加学生void addStudent() if (studentCount = MAX_STUDENTS) printf( ⚠️ 学生人数已达上限！ ); return; printf( --- 添加学生 --- ); printf(学号：); scanf(%d, students[studentCount].id); // 检查学号是否重复 for (int i = 0; i studentCount; i++) if (students[i].id == students[studentCount].id) printf(⚠️ 学号已存在！ ); return; printf(姓名：); scanf(%s, students[studentCount].name); printf(成绩：); scanf(%f, students[studentCount].score); studentCount++; printf(✅ 添加成功！ );// 显示所有学生void displayStudents() if (studentCount == 0) printf( ⚠️ 暂无学生信息！ ); return; printf( --- 所有学生信息 --- ); printf(%-10s %-20s %s , 学号, 姓名, 成绩); printf(---------------------------------------- ); for (int i = 0; i studentCount; i++) printf(%-10d %-20s %.2f , students[i].id, students[i].name, students[i].score); printf(共 %d 名学生 , studentCount);// 计算平均分void calculateAverage() if (studentCount == 0) printf( ⚠️ 暂无学生信息！ ); return; float sum = 0; float max = students[0].score; float min = students[0].score; for (int i = 0; i studentCount; i++) sum += students[i].score; if (students[i].score max) max = students[i].score; if (students[i].score min) min = students[i].score; printf( --- 成绩统计 --- ); printf(平均分：%.2f , sum / studentCount); printf(最高分：%.2f , max); printf(最低分：%.2f , min);// 查找最高分学生void findTopStudent() if (studentCount == 0) printf( ⚠️ 暂无学生信息！ ); return; int topIndex = 0; for (int i = 1; i studentCount; i++) if (students[i].score students[topIndex].score) topIndex = i; printf( --- 最高分学生 --- ); printf(学号：%d , students[topIndex].id); printf(姓名：%s , students[topIndex].name); printf(成绩：%.2f , students[topIndex].score);// 按成绩排序（冒泡排序）void sortByScore() if (studentCount == 0) printf( ⚠️ 暂无学生信息！ ); return; // 冒泡排序 for (int i = 0; i studentCount - 1; i++) for (int j = 0; j studentCount - 1 - i; j++) if (students[j].score students[j + 1].score) // 交换 struct Student temp = students[j]; students[j] = students[j + 1]; students[j + 1] = temp; printf( ✅ 排序完成！ ); displayStudents(); 🔍 代码解析1. 数据结构设计struct Student char name[50]; // 姓名：字符数组 int id; // 学号：整型 float score; // 成绩：浮点型; **解析：**使用结构体将学生的不同类型数据组合在一起，便于统一管理。 2. 全局变量的使用struct Student students[MAX_STUDENTS];int studentCount = 0; 解析： students数组：存储所有学生信息 studentCount：记录当前学生数量，避免每次都遍历数组 使用#define MAX_STUDENTS 50定义常量，便于修改最大容量 3. 菜单系统的实现while (1) // 无限循环 showMenu(); scanf(%d, choice); switch (choice) case 1: addStudent(); break; // ... case 6: return 0; // 退出程序 解析： while(1)实现无限循环，直到用户选择退出 switch语句根据用户选择调用不同函数 return 0直接退出程序，结束main函数 4. 冒泡排序算法for (int i = 0; i studentCount - 1; i++) for (int j = 0; j studentCount - 1 - i; j++) if (students[j].score students[j + 1].score) // 交换两个结构体 struct Student temp = students[j]; students[j] = students[j + 1]; students[j + 1] = temp; 解析： 外层循环控制排序轮数（n个数需要n-1轮） 内层循环比较相邻元素 studentCount - 1 - i：每轮后最大元素已就位，减少比较次数 使用临时变量temp交换两个结构体 5. 输入验证// 检查学号是否重复for (int i = 0; i studentCount; i++) if (students[i].id == students[studentCount].id) printf(学号已存在！ ); return; **解析：**在添加学生前检查学号唯一性，避免数据重复。 📊 运行示例================================= 学生成绩管理系统（入门版）=================================1. 添加学生2. 显示所有学生3. 计算平均分4. 查找最高分学生5. 按成绩排序6. 退出系统=================================请选择操作（1-6）：1--- 添加学生 ---学号：1001姓名：张三成绩：85.5✅ 添加成功！请选择操作（1-6）：1--- 添加学生 ---学号：1002姓名：李四成绩：92.0✅ 添加成功！请选择操作（1-6）：2--- 所有学生信息 ---学号 姓名 成绩----------------------------------------1001 张三 85.501002 李四 92.00共 2 名学生请选择操作（1-6）：3--- 成绩统计 ---平均分：88.75最高分：92.00最低分：85.50 🎯 知识点总结 ✅ 结构体的定义和使用 ✅ 数组的遍历和操作 ✅ 函数的声明和调用 ✅ switch-case 多分支选择 ✅ 冒泡排序算法 ✅ 输入验证 ⚡ 扩展练习 添加删除学生功能 添加修改学生信息功能 实现按学号查找功能 将数据保存到文件（第8章内容） 添加成绩等级评定（优秀、良好、及格、不及格） 案例2：简易计算器📋 案例说明一个支持四则运算的简易计算器，可以处理连续运算，帮助理解函数调用和循环控制。 **涉及知识点：**函数、循环、switch、运算符、字符处理 难度等级：⭐ (入门) 💡 功能需求 支持加、减、乘、除四则运算 可以连续进行多次运算 除数为0时给出提示 支持清除和退出 💻 完整代码#include #include // 用于 toupper() 函数// 函数声明double add(double a, double b);double subtract(double a, double b);double multiply(double a, double b);double divide(double a, double b);void clearInputBuffer();int main() double num1, num2, result; char operator; char choice; printf(================================= ); printf( 简易计算器 ); printf(================================= ); do printf( 请输入第一个数字：); while (scanf(%lf, num1) != 1) clearInputBuffer(); printf(⚠️ 输入无效，请重新输入数字：); printf(请输入运算符 (+, -, *, /)：); clearInputBuffer(); scanf(%c, operator); printf(请输入第二个数字：); while (scanf(%lf, num2) != 1) clearInputBuffer(); printf(⚠️ 输入无效，请重新输入数字：); // 执行运算 switch (operator) case +: result = add(num1, num2); printf( 结果：%.2lf + %.2lf = %.2lf , num1, num2, result); break; case -: result = subtract(num1, num2); printf( 结果：%.2lf - %.2lf = %.2lf , num1, num2, result); break; case *: result = multiply(num1, num2); printf( 结果：%.2lf × %.2lf = %.2lf , num1, num2, result); break; case /: if (num2 == 0) printf( ⚠️ 错误：除数不能为0！ ); else result = divide(num1, num2); printf( 结果：%.2lf ÷ %.2lf = %.2lf , num1, num2, result); break; default: printf( ⚠️ 错误：无效的运算符 %c , operator); // 询问是否继续 printf( 是否继续计算？(Y/N)：); clearInputBuffer(); scanf(%c, choice); while (toupper(choice) == Y); printf( 感谢使用计算器，再见！ ); return 0;// 加法double add(double a, double b) return a + b;// 减法double subtract(double a, double b) return a - b;// 乘法double multiply(double a, double b) return a * b;// 除法double divide(double a, double b) return a / b;// 清空输入缓冲区void clearInputBuffer() int c; while ((c = getchar()) != c != EOF); 🔍 代码解析1. 函数的模块化设计double add(double a, double b) return a + b; 解析： 每种运算封装为独立函数 使用double类型支持小数运算 函数参数和返回值都是double类型 2. 输入验证while (scanf(%lf, num1) != 1) clearInputBuffer(); printf(⚠️ 输入无效，请重新输入数字：); 解析： scanf返回成功读取的项目数 如果用户输入非数字，scanf返回0 clearInputBuffer()清空错误的输入 3. 除零检查case /: if (num2 == 0) printf( ⚠️ 错误：除数不能为0！ ); else result = divide(num1, num2); printf( 结果：%.2lf ÷ %.2lf = %.2lf , num1, num2, result); break; **解析：**在执行除法前检查除数，防止程序崩溃。 4. 输入缓冲区处理void clearInputBuffer() int c; while ((c = getchar()) != c != EOF); 解析： 读取并丢弃缓冲区中的剩余字符 直到遇到换行符或文件结束符 避免scanf读取残留字符 5. 大小写不敏感的判断 while (toupper(choice) == Y); **解析：**使用toupper()函数将输入转换为大写，用户输入Y或y都可以继续。 📊 运行示例================================= 简易计算器=================================请输入第一个数字：10请输入运算符 (+, -, *, /)：*请输入第二个数字：5结果：10.00 × 5.00 = 50.00是否继续计算？(Y/N)：y请输入第一个数字：20请输入运算符 (+, -, *, /)：/请输入第二个数字：0⚠️ 错误：除数不能为0！是否继续计算？(Y/N)：n感谢使用计算器，再见！ 🎯 知识点总结 ✅ 函数的定义和调用 ✅ switch-case 语句 ✅ do-while 循环 ✅ 输入验证 ✅ 字符处理函数 ✅ 浮点数运算 ⚡ 扩展练习 添加幂运算（^）和取模运算（%） 支持多个运算符的连续计算（如：5 + 3 * 2） 添加括号支持 记录计算历史 添加科学计算器功能（三角函数、对数等） 案例3：猜数字游戏📋 案例说明经典的猜数字游戏，计算机随机生成一个数字，玩家通过输入数字来猜测，系统会提示”大了”或”小了”。 **涉及知识点：**随机数、循环、条件判断、函数 难度等级：⭐ (入门) 💡 功能需求 随机生成1-100之间的数字 玩家输入猜测的数字 提示”大了”、”小了”或”猜对了” 记录猜测次数 提供有限次机会（如10次） 💻 完整代码#include #include #include #define MAX_ATTEMPTS 10#define MIN_NUM 1#define MAX_NUM 100// 函数声明int generateRandomNumber(int min, int max);void playGame();void printWelcome();void printGameOver(int secret, int attempts);int main() char choice; // 初始化随机数种子 srand(time(NULL)); printWelcome(); do playGame(); printf( 想再玩一次吗？(Y/N)：); scanf( %c, choice); // 清空输入缓冲区 while (getchar() != ); while (choice == Y || choice == y); printf( 感谢游玩，再见！ ); return 0;// 生成指定范围内的随机数int generateRandomNumber(int min, int max) return min + rand() % (max - min + 1);// 打印欢迎信息void printWelcome() printf( ); printf(================================= ); printf( 猜数字游戏 ); printf(================================= ); printf(规则： ); printf(- 我已经想好了一个 %d 到 %d 之间的数字 , MIN_NUM, MAX_NUM); printf(- 你有 %d 次机会来猜它 , MAX_ATTEMPTS); printf(- 我会告诉你猜大了还是小了 ); printf(================================= );// 打印游戏结束信息void printGameOver(int secret, int attempts) printf( ================================= ); printf( 游戏结束 ); printf(================================= ); printf(正确答案是：%d , secret); printf(你用了 %d 次机会 , attempts);// 游戏主逻辑void playGame() int secret = generateRandomNumber(MIN_NUM, MAX_NUM); int guess; int attempts = 0; int found = 0; printf( 游戏开始！你有 %d 次机会。 , MAX_ATTEMPTS); while (attempts MAX_ATTEMPTS !found) printf( 剩余机会：%d 次 , MAX_ATTEMPTS - attempts); printf(请输入你的猜测 (%d-%d)：, MIN_NUM, MAX_NUM); // 输入验证 if (scanf(%d, guess) != 1) printf(⚠️ 请输入有效的数字！ ); // 清空输入缓冲区 while (getchar() != ); continue; // 检查范围 if (guess MIN_NUM || guess MAX_NUM) printf(⚠️ 请输入 %d 到 %d 之间的数字！ , MIN_NUM, MAX_NUM); continue; attempts++; // 比较猜测 if (guess == secret) printf( 🎉 恭喜你，猜对了！ ); printf(你用了 %d 次就猜到了答案 %d , attempts, secret); // 评价 if (attempts = 3) printf(评价：太厉害了！简直是神猜手！ ); else if (attempts = 6) printf(评价：很不错！继续加油！ ); else printf(评价：运气还是不错的！ ); found = 1; else if (guess secret) printf(📈 太小了！再大一点！ ); // 提示范围 if (secret - guess = 10) printf(💡 提示：非常接近了！ ); else if (secret - guess = 30) printf(💡 提示：有点接近了！ ); else printf(📉 太大了！再小一点！ ); // 提示范围 if (guess - secret = 10) printf(💡 提示：非常接近了！ ); else if (guess - secret = 30) printf(💡 提示：有点接近了！ ); // 游戏结束 if (!found) printf( 😢 很遗憾，你没有在 %d 次内猜中。 , MAX_ATTEMPTS); printGameOver(secret, attempts); 🔍 代码解析1. 随机数生成srand(time(NULL)); // 初始化随机数种子int secret = rand() % (MAX_NUM - MIN_NUM + 1) + MIN_NUM; 解析： srand(time(NULL))：使用当前时间作为种子，确保每次运行结果不同 rand()：生成0到RAND_MAX之间的随机数 rand() % (max - min + 1) + min：生成[min, max]范围内的随机数 2. 输入验证if (scanf(%d, guess) != 1) printf(⚠️ 请输入有效的数字！ ); while (getchar() != ); continue;if (guess MIN_NUM || guess MAX_NUM) printf(⚠️ 请输入 %d 到 %d 之间的数字！ , MIN_NUM, MAX_NUM); continue; **解析：**验证输入是否为有效数字且在指定范围内。 3. 游戏循环控制while (attempts MAX_ATTEMPTS !found) // 游戏逻辑 解析： 两个条件：未超过最大尝试次数 且 未猜中 found标志控制游戏是否结束 4. 智能提示if (secret - guess = 10) printf(💡 提示：非常接近了！ ); else if (secret - guess = 30) printf(💡 提示：有点接近了！ ); **解析：**根据差距大小提供不同的提示信息，增强游戏性。 5. 评价系统if (attempts = 3) printf(评价：太厉害了！简直是神猜手！ ); else if (attempts = 6) printf(评价：很不错！继续加油！ ); else printf(评价：运气还是不错的！ ); **解析：**根据猜测次数给出不同的评价，增加趣味性。 📊 运行示例================================= 猜数字游戏=================================规则：- 我已经想好了一个 1 到 100 之间的数字- 你有 10 次机会来猜它- 我会告诉你猜大了还是小了=================================游戏开始！你有 10 次机会。剩余机会：10 次请输入你的猜测 (1-100)：50📈 太小了！再大一点！💡 提示：有点接近了！剩余机会：9 次请输入你的猜测 (1-100)：75📉 太大了！再小一点！💡 提示：非常接近了！剩余机会：8 次请输入你的猜测 (1-100)：65📉 太大了！再小一点！💡 提示：非常接近了！剩余机会：7 次请输入你的猜测 (1-100)：60📉 太大了！再小一点！💡 提示：非常接近了！剩余机会：6 次请输入你的猜测 (1-100)：58🎉 恭喜你，猜对了！你用了 5 次就猜到了答案 58评价：很不错！继续加油！ 🎯 知识点总结 ✅ 随机数生成和使用 ✅ 循环控制 ✅ 条件判断 ✅ 函数的模块化设计 ✅ 输入验证 ✅ 标志变量的使用 ⚡ 扩展练习 添加难度选择（简单：1-50，中等：1-100，困难：1-200） 记录并显示历史猜测 添加计时功能 实现排行榜功能 添加多人对战模式 更多案例由于篇幅限制，以下是其他经典案例的简要说明和代码框架。 04图书管理系统（进阶版）**功能：**图书信息的增删改查、借阅管理、文件存储 **涉及知识点：**链表、文件操作、结构体、动态内存 难度：⭐⭐⭐⭐ (中高级) 查看完整代码 → 05通讯录管理系统**功能：**联系人管理、分组、搜索、导入导出 **涉及知识点：**字符串处理、文件操作、动态数组 难度：⭐⭐⭐ (中级) 查看完整代码 → 06贪吃蛇游戏**功能：**经典贪吃蛇游戏，界面控制、碰撞检测 **涉及知识点：**二维数组、游戏循环、键盘控制 难度：⭐⭐⭐⭐⭐ (高级) 查看完整代码 → 学习建议💡 理解原理不要只是复制粘贴代码，要理解每一行代码的作用和背后的原理。 💡 动手实践自己动手敲一遍代码，然后尝试修改和扩展功能。 💡 调试技巧学会使用printf调试，在关键位置输出变量值，观察程序运行过程。 💡 举一反三从一个案例出发，思考如何实现类似的其他功能。 常见问题解答Q1: 为什么要使用函数而不是把所有代码写在main里？A: 使用函数有以下好处： 模块化：将复杂问题分解为小问题 复用性：同一功能可以在多处调用 可维护性：修改某个功能只需修改对应的函数 可读性：代码结构清晰，易于理解 Q2: scanf后面的getchar()是干什么的？A: 这是用来清空输入缓冲区的。scanf读取数字后，缓冲区可能残留换行符等字符，会影响后续的字符读取。getchar()会读取并丢弃这些残留字符。 Q3: 什么时候使用数组，什么时候使用链表？A: 数组：大小固定，访问快速（O(1)），适合元素数量已知的情况 链表：大小可变，插入删除方便（O(1)），适合频繁增删的情况 Q4: 如何避免数组越界？A: 始终从0开始遍历到size-1 使用#define定义数组大小，避免硬编码 添加边界检查 使用安全的函数（如fgets代替gets） Q5: 什么时候应该使用动态内存分配？A: 当满足以下条件之一时： 编译时不知道需要多少内存 需要大数组，可能超出栈大小 数据结构需要动态增长 需要在函数间传递大量数据"},{"title":"第2章 C语言基础","path":"/wiki/c/chapter2.html","content":"第2章 C语言基础⭐基础章节 重点掌握 数据类型、常量变量、运算符表达式是编程的基础 本章概述本章介绍C语言的基础知识，包括： 基本数据类型 常量与变量 运算符与表达式 数据类型转换 输入输出函数 这些知识是学习C语言的基石，必须扎实掌握。 基本数据类型整型int a = 100; // 基本整型short b = 10; // 短整型long c = 100000; // 长整型unsigned int d = 200; // 无符号整型 字符型char ch = A; // 字符型signed char sc = -1; // 有符号字符型unsigned char uc = 255; // 无符号字符型 浮点型float f = 3.14f; // 单精度浮点型double d = 3.14159; // 双精度浮点型 💡 数据类型选择原则 整数使用int 小数使用double（精度更高） 字符使用char 需要大范围数值时使用long 常量与变量常量常量是值不能改变的量： // 整型常量100 // 十进制077 // 八进制0xFF // 十六进制// 实型常量3.14 // 小数形式3.14e2 // 指数形式，表示3.14×10²// 字符常量A // 单个字符 // 转义字符// 字符串常量Hello World // 字符串// 符号常量#define PI 3.14159const int MAX = 100; 变量变量是值可以改变的量，必须先定义后使用： int age = 20; // 定义并初始化float salary;salary = 5000.50; // 赋值// 批量定义int a = 1, b = 2, c = 3; 变量命名规则 只能由字母、数字、下划线组成 不能以数字开头 不能使用关键字 区分大小写 见名知意（推荐） // 好的变量名int studentAge;float averageScore;// 不好的变量名int x; // 含义不明int 2number; // 错误：不能以数字开头int int; // 错误：不能使用关键字 运算符与表达式算术运算符 运算符 说明 示例 + 加法 a + b - 减法 a - b * 乘法 a * b / 除法 a / b % 取余（模） a % b ++ 自增 a++或++a -- 自减 a--或--a int a = 10, b = 3;printf(%d , a + b); // 输出：13printf(%d , a / b); // 输出：3（整数除法）printf(%d , a % b); // 输出：1// 自增自减int x = 5;printf(%d , x++); // 输出：5，然后x变为6printf(%d , ++x); // x先变为7，输出：7 关系运算符 运算符 说明 示例 == 等于 a == b != 不等于 a != b 大于 a b 小于 a b = 大于等于 a = b = 小于等于 a = b 逻辑运算符 运算符 说明 示例 逻辑与 a b ! 逻辑非 !a 赋值运算符int a = 10;a += 5; // 等价于 a = a + 5，结果为15a -= 3; // 等价于 a = a - 3，结果为12a *= 2; // 等价于 a = a * 2，结果为24a /= 4; // 等价于 a = a / 4，结果为6a %= 4; // 等价于 a = a % 4，结果为2 💡 运算符优先级优先级从高到低：括号 自增自减 乘除模 加减 关系 逻辑 赋值 int result = 2 + 3 * 4; // 结果为14，不是20int result = (2 + 3) * 4; // 结果为20 数据类型转换自动类型转换int a = 10;float b = 3.5;float c = a + b; // a自动转换为float，结果为13.5// 转换规则：低精度 → 高精度// char → int → long → float → double 强制类型转换int a = 10, b = 3;float result = (float)a / b; // 结果为3.33333int result2 = a / (int)b; // 结果为3 输入输出函数格式化输出 printf#include int main() int age = 20; float height = 1.75; char grade = A; printf(年龄：%d , age); printf(身高：%.2f , height); printf(等级：%c , grade); printf(格式化：%s是%d岁 , 小明, age); return 0; 常用格式占位符： 占位符 说明 %d 有符号十进制整数 %f 浮点数 %c 单个字符 %s 字符串 %.2f 保留2位小数 格式化输入 scanf#include int main() int age; float height; printf(请输入年龄：); scanf(%d, age); // 注意：必须使用取地址 printf(请输入身高：); scanf(%f, height); printf(年龄：%d，身高：%.2f , age, height); return 0; ⚠️ scanf注意事项 除数组外，必须使用获取变量地址 输入数据时用空格或回车分隔 scanf(%c, ch)会读取缓冲区的换行符 完整示例#include #define PI 3.14159int main() // 计算圆的面积 double radius, area; printf(请输入圆的半径：); scanf(%lf, radius); area = PI * radius * radius; printf(半径为%.2f的圆的面积为：%.2f , radius, area); return 0; 实战案例：温度转换器📋 案例说明编写一个程序，实现摄氏温度和华氏温度的相互转换。 **涉及知识点：**变量、输入输出、算术运算、数据类型 💡 需求分析 用户选择转换方向（摄氏→华氏 或 华氏→摄氏） 输入要转换的温度值 输出转换结果 📝 转换公式 华氏温度 摄氏温度 × 95 + 32 摄氏温度 (华氏温度 - 32) × 59 💻 完整代码#include int main() int choice; float temperature, converted; printf(================================= ); printf( 温度转换器 ); printf(================================= ); printf(1. 摄氏温度 → 华氏温度 ); printf(2. 华氏温度 → 摄氏温度 ); printf(================================= ); printf(请选择（1或2）：); scanf(%d, choice); if (choice == 1) // 摄氏转华氏 printf( 请输入摄氏温度：); scanf(%f, temperature); converted = temperature * 9.0f / 5.0f + 32; printf( 转换结果： ); printf(%.2f°C = %.2f°F , temperature, converted); else if (choice == 2) // 华氏转摄氏 printf( 请输入华氏温度：); scanf(%f, temperature); converted = (temperature - 32) * 5.0f / 9.0f; printf( 转换结果： ); printf(%.2f°F = %.2f°C , temperature, converted); else printf( ⚠️ 无效的选择！ ); return 0; 🔍 代码解析1. 浮点数运算注意事项converted = temperature * 9.0f / 5.0f + 32; 解析： 使用9.0f而不是9，确保进行浮点除法 如果写成9/5，结果会是1（整数除法） f后缀表示float类型，9.0会被当作double 2. 格式化输出printf(%.2f°C = %.2f°F , temperature, converted); 解析： %.2f：保留2位小数 °C和°F：直接输出的特殊字符 注意这里需要使用UTF-8编码才能正确显示度数符号 3. 变量命名float temperature, converted; 解析： temperature：原始温度值 converted：转换后的温度值 见名知意的命名使代码更易读 📊 运行示例================================= 温度转换器=================================1. 摄氏温度 → 华氏温度2. 华氏温度 → 摄氏温度=================================请选择（1或2）：1请输入摄氏温度：25转换结果：25.00°C = 77.00°F ⚡ 扩展练习 添加开尔文温度的转换 支持批量转换多个温度值 添加温度范围提示（如：水在0°C结冰，100°C沸腾） 实现温度单位的历史记录 实战案例：简单计算器（基础版）📋 案例说明实现两个数的四则运算，帮助理解运算符和表达式。 **涉及知识点：**算术运算符、scanf、printf、条件判断 💻 完整代码#include int main() float num1, num2, result; char op; printf(请输入第一个数字：); scanf(%f, num1); printf(请输入运算符 (+, -, *, /)：); scanf( %c, op); // 注意空格，用于跳过空白字符 printf(请输入第二个数字：); scanf(%f, num2); switch (op) case +: result = num1 + num2; printf(%.2f + %.2f = %.2f , num1, num2, result); break; case -: result = num1 - num2; printf(%.2f - %.2f = %.2f , num1, num2, result); break; case *: result = num1 * num2; printf(%.2f × %.2f = %.2f , num1, num2, result); break; case /: if (num2 == 0) printf(⚠️ 错误：除数不能为0！ ); else result = num1 / num2; printf(%.2f ÷ %.2f = %.2f , num1, num2, result); break; default: printf(⚠️ 错误：无效的运算符！ ); return 0; 🔍 重点解析1. scanf中的空格scanf( %c, op); // 注意前面的空格 **解析：**空格告诉scanf跳过之前的空白字符（包括换行符），直接读取下一个非空白字符。 2. 除零检查if (num2 == 0) printf(⚠️ 错误：除数不能为0！ ); else result = num1 / num2; **解析：**除数为0会导致运行时错误，必须提前检查。 3. 浮点数比较if (num2 == 0.0f) ... **注意：**浮点数直接比较可能不精确，实际应用中应该使用容差比较： if (fabs(num2) 1e-6) // 需要 #include printf(除数接近0 ); 📊 运行示例请输入第一个数字：10请输入运算符 (+, -, *, /)：*请输入第二个数字：510.00 × 5.00 = 50.00 本章小结 ✓ 掌握了基本数据类型的使用 ✓ 理解了常量和变量的区别 ✓ 学会了各种运算符的使用 ✓ 掌握了输入输出函数 下一步学习 第3章 程序设计基本结构 - 学习控制流程 main函数详解 - 复习程序入口"},{"title":"第3章 程序设计基本结构","path":"/wiki/c/chapter3.html","content":"第3章 程序设计基本结构⭐核心章节 必须掌握 三种基本控制结构是程序设计的基石 本章概述C语言有三种基本的程序结构： 顺序结构：按顺序执行语句 选择结构：根据条件选择执行不同语句 循环结构：重复执行某些语句 任何复杂的程序都可以由这三种基本结构组合而成。 顺序结构顺序结构是最简单的结构，程序按照语句的书写顺序依次执行： #include int main() int a, b, sum; printf(请输入两个整数：); scanf(%d %d, a, b); sum = a + b; printf(两数之和为：%d , sum); return 0; 顺序结构的执行流程：输入 → 处理 → 输出 选择结构if语句单分支if语句if (条件表达式) // 条件为真时执行的语句 #include int main() int score; printf(请输入成绩：); scanf(%d, score); if (score = 60) printf(恭喜及格！ ); return 0; 双分支if-else语句if (条件表达式) // 条件为真时执行 else // 条件为假时执行 #include int main() int score; printf(请输入成绩：); scanf(%d, score); if (score = 60) printf(恭喜及格！ ); else printf(需要继续努力！ ); return 0; 多分支if-else if语句if (条件1) // 条件1为真时执行 else if (条件2) // 条件2为真时执行 else // 所有条件都不为真时执行 #include int main() int score; printf(请输入成绩：); scanf(%d, score); if (score = 90) printf(优秀 ); else if (score = 80) printf(良好 ); else if (score = 70) printf(中等 ); else if (score = 60) printf(及格 ); else printf(不及格 ); return 0; switch语句switch语句用于多分支选择，特别适合处理等值判断： switch (表达式) case 常量1: // 语句1 break; case 常量2: // 语句2 break; ... default: // 默认语句 #include int main() int day; printf(请输入星期几（1-7）：); scanf(%d, day); switch (day) case 1: printf(星期一 ); break; case 2: printf(星期二 ); break; case 3: printf(星期三 ); break; case 4: printf(星期四 ); break; case 5: printf(星期五 ); break; case 6: printf(星期六 ); break; case 7: printf(星期日 ); break; default: printf(输入错误 ); return 0; 💡 注意事项 break语句用于跳出switch，如果没有break，会继续执行后面的case case后面的常量必须是整数或字符 各个case的常量值不能相同 default可以省略 循环结构while循环先判断条件，再执行循环体： while (条件表达式) // 循环体 #include int main() int i = 1; int sum = 0; while (i = 100) sum += i; i++; printf(1到100的和为：%d , sum); return 0; do-while循环先执行循环体，再判断条件，至少执行一次： do // 循环体 while (条件表达式); #include int main() int number; do printf(请输入一个正数：); scanf(%d, number); while (number = 0); printf(输入的正数是：%d , number); return 0; for循环最灵活的循环语句： for (初始化表达式; 条件表达式; 更新表达式) // 循环体 #include int main() int sum = 0; // 计算1到100的和 for (int i = 1; i = 100; i++) sum += i; printf(1到100的和为：%d , sum); // 九九乘法表 for (int i = 1; i = 9; i++) for (int j = 1; j = i; j++) printf(%d×%d=%-2d , i, j, i * j); printf( ); return 0; 💡 三种循环的选择 while：不确定循环次数时使用 do-while：至少需要执行一次时使用 for：知道循环次数时使用 循环控制语句break语句立即跳出当前循环： #include int main() for (int i = 1; i = 10; i++) if (i == 5) break; // 跳出循环 printf(%d , i); // 输出：1 2 3 4 return 0; continue语句跳过本次循环，继续下一次循环： #include int main() for (int i = 1; i = 10; i++) if (i % 2 == 0) continue; // 跳过偶数 printf(%d , i); // 输出：1 3 5 7 9 return 0; 嵌套结构循环和选择结构可以互相嵌套： #include int main() // 打印1-100之间的所有质数 for (int i = 2; i = 100; i++) int isPrime = 1; for (int j = 2; j * j = i; j++) if (i % j == 0) isPrime = 0; break; if (isPrime) printf(%d , i); return 0; 综合示例#include int main() int choice; float num1, num2, result; printf(简单计算器 ); printf(1. 加法 ); printf(2. 减法 ); printf(3. 乘法 ); printf(4. 除法 ); printf(请选择操作（1-4）：); scanf(%d, choice); if (choice 1 || choice 4) printf(无效的选择！ ); return 1; printf(请输入两个数：); scanf(%f %f, num1, num2); switch (choice) case 1: result = num1 + num2; printf(%.2f + %.2f = %.2f , num1, num2, result); break; case 2: result = num1 - num2; printf(%.2f - %.2f = %.2f , num1, num2, result); break; case 3: result = num1 * num2; printf(%.2f × %.2f = %.2f , num1, num2, result); break; case 4: if (num2 == 0) printf(错误：除数不能为0 ); else result = num1 / num2; printf(%.2f ÷ %.2f = %.2f , num1, num2, result); break; return 0; 本章小结 ✓ 掌握了顺序结构、选择结构、循环结构 ✓ 学会了if语句和switch语句的使用 ✓ 掌握了while、do-while、for三种循环 ✓ 理解了break和continue的作用 下一步学习 第4章 数组 - 学习批量数据的处理 第2章 C语言基础 - 复习基础知识"},{"title":"第4章 数组","path":"/wiki/c/chapter4.html","content":"第4章 数组⭐进阶章节 重点掌握 数组是处理批量数据的重要工具 本章概述数组是一组相同类型数据的集合，这些数据在内存中连续存放。数组是C语言中最基本的数据结构。 本章主要内容： 一维数组的定义和使用 二维数组的定义和使用 字符数组与字符串 数组作为函数参数 常见算法：排序、查找 一维数组定义和初始化// 定义方式类型 数组名[大小];// 示例int arr[5]; // 定义一个包含5个整数的数组float scores[10]; // 定义一个包含10个浮点数的数组// 初始化int arr1[5] = 1, 2, 3, 4, 5; // 完全初始化int arr2[5] = 1, 2, 3; // 部分初始化，其余为0int arr3[] = 1, 2, 3, 4, 5; // 自动确定大小int arr4[5] = 0; // 全部初始化为0 访问数组元素#include int main() int arr[5] = 10, 20, 30, 40, 50; // 访问单个元素 printf(第一个元素：%d , arr[0]); // 输出：10 printf(第三个元素：%d , arr[2]); // 输出：30 // 遍历数组 for (int i = 0; i 5; i++) printf(arr[%d] = %d , i, arr[i]); return 0; ⚠️ 注意事项 数组下标从0开始 访问数组时不要越界 数组名是常量，不能修改 二维数组定义和初始化// 定义方式类型 数组名[行数][列数];// 示例int matrix[3][4]; // 3行4列的二维数组// 初始化int mat1[2][3] = 1, 2, 3, 4, 5, 6;int mat2[2][3] = 1, 2, 3, 4, 5, 6; // 自动分行int mat3[][3] = 1, 2, 3, 4, 5, 6; // 省略行数 访问二维数组#include int main() int matrix[2][3] = 1, 2, 3, 4, 5, 6 ; // 访问元素 printf(matrix[0][0] = %d , matrix[0][0]); // 输出：1 printf(matrix[1][2] = %d , matrix[1][2]); // 输出：6 // 遍历二维数组 for (int i = 0; i 2; i++) for (int j = 0; j 3; j++) printf(%d , matrix[i][j]); printf( ); return 0; 💡 二维数组的应用二维数组常用于表示矩阵、表格、游戏地图等二维数据结构。 字符数组与字符串字符数组char str1[5] = H, e, l, l, o; // 字符数组char str2[] = Hello; // 字符串 字符串字符串是以\\0（空字符）结尾的字符数组： #include #include int main() char str[] = Hello; // 字符串长度（不包括\\0） printf(长度：%lu , strlen(str)); // 输出：5 // 输出字符串 printf(字符串：%s , str); // 字符串拷贝 char str2[20]; strcpy(str2, str); printf(拷贝：%s , str2); // 字符串连接 strcat(str2, World); printf(连接：%s , str2); // 字符串比较 if (strcmp(str, Hello) == 0) printf(相等 ); return 0; 常用字符串函数 函数 说明 strlen(s) 返回字符串s的长度 strcpy(dest, src) 将src复制到dest strcat(dest, src) 将src连接到dest后面 strcmp(s1, s2) 比较两个字符串 strstr(s1, s2) 在s1中查找s2首次出现的位置 数组作为函数参数#include // 函数声明void printArray(int arr[], int size);int sumArray(int arr[], int size);void reverseArray(int arr[], int size);int main() int arr[] = 1, 2, 3, 4, 5; int size = sizeof(arr) / sizeof(arr[0]); printf(原始数组：); printArray(arr, size); printf(数组之和：%d , sumArray(arr, size)); reverseArray(arr, size); printf(反转后：); printArray(arr, size); return 0;// 打印数组void printArray(int arr[], int size) for (int i = 0; i size; i++) printf(%d , arr[i]); printf( );// 计算数组元素之和int sumArray(int arr[], int size) int sum = 0; for (int i = 0; i size; i++) sum += arr[i]; return sum;// 反转数组void reverseArray(int arr[], int size) for (int i = 0; i size / 2; i++) int temp = arr[i]; arr[i] = arr[size - 1 - i]; arr[size - 1 - i] = temp; 💡 注意数组作为函数参数时会退化为指针，sizeof(arr)返回的是指针大小，需要在调用时传递数组大小。 常见算法冒泡排序#include void bubbleSort(int arr[], int size) for (int i = 0; i size - 1; i++) for (int j = 0; j size - 1 - i; j++) if (arr[j] arr[j + 1]) // 交换 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; int main() int arr[] = 64, 34, 25, 12, 22, 11, 90; int size = sizeof(arr) / sizeof(arr[0]); bubbleSort(arr, size); printf(排序后：); for (int i = 0; i size; i++) printf(%d , arr[i]); return 0; 二分查找#include int binarySearch(int arr[], int size, int target) int left = 0, right = size - 1; while (left = right) int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; if (arr[mid] target) left = mid + 1; else right = mid - 1; return -1; // 未找到int main() int arr[] = 2, 5, 8, 12, 16, 23, 38, 56, 72, 91; int size = sizeof(arr) / sizeof(arr[0]); int target = 23; int result = binarySearch(arr, size, target); if (result != -1) printf(找到元素，位置：%d , result); else printf(未找到元素 ); return 0; 综合示例：学生成绩管理#include #define MAX_STUDENTS 100#define MAX_NAME 50struct Student char name[MAX_NAME]; int score;;int main() struct Student students[MAX_STUDENTS]; int count = 0; int choice; while (1) printf( 1. 添加学生 ); printf(2. 显示所有学生 ); printf(3. 计算平均分 ); printf(4. 退出 ); printf(请选择：); scanf(%d, choice); if (choice == 1) printf(姓名：); scanf(%s, students[count].name); printf(成绩：); scanf(%d, students[count].score); count++; else if (choice == 2) for (int i = 0; i count; i++) printf(%s: %d , students[i].name, students[i].score); else if (choice == 3) int sum = 0; for (int i = 0; i count; i++) sum += students[i].score; printf(平均分：%.2f , (float)sum / count); else if (choice == 4) break; return 0; 本章小结 ✓ 掌握了一维数组和二维数组的使用 ✓ 理解了字符数组与字符串的关系 ✓ 学会了数组作为函数参数 ✓ 掌握了基本的排序和查找算法 下一步学习 第5章 指针 - 学习C语言的核心特性 第3章 程序设计基本结构 - 复习控制结构"},{"title":"第5章 指针","path":"/wiki/c/chapter5.html","content":"第5章 指针⭐核心章节 重点掌握 指针是C语言最强大也是最难掌握的特性 本章概述指针是C语言最强大的特性之一，也是C语言的灵魂。掌握指针是成为优秀C程序员的必经之路。 本章主要内容： 指针的基本概念 指针的运算 指针与数组 指针与函数 指针数组与多级指针 动态内存分配 什么是指针？基本概念指针是一个变量，其值为另一个变量的地址。通过指针，我们可以间接访问和操作内存中的数据。 int a = 10; // 整型变量int *p; // 指针变量p = a // p指向a的地址 💡 关键符号 ：取地址运算符，获取变量的地址 *：指针运算符，访问指针指向的变量 指针的定义和使用#include int main() int a = 10; int *p; // 定义指针变量 p = a // p指向a printf(a的值：%d , a); // 输出：10 printf(a的地址：%p , a); // 输出：a的地址 printf(p的值：%p , p); // 输出：a的地址 printf(*p的值：%d , *p); // 输出：10 *p = 20; // 通过指针修改a的值 printf(修改后a的值：%d , a); // 输出：20 return 0; 指针的运算指针的算术运算#include int main() int arr[5] = 10, 20, 30, 40, 50; int *p = arr; // 指向数组首元素 printf(%d , *p); // 输出：10 printf(%d , *(p + 1)); // 输出：20 printf(%d , *(p + 2)); // 输出：30 p++; // 指针后移 printf(%d , *p); // 输出：20 return 0; 指针的关系运算int arr[5];int *p1 = arr[0];int *p2 = arr[4];if (p1 p2) printf(p1在p2前面 ); ⚠️ 注意 指针运算只在数组中有意义 不要对未初始化的指针进行运算 注意指针越界问题 指针与数组数组名与指针数组名在很多情况下会退化为指向首元素的指针： #include int main() int arr[5] = 10, 20, 30, 40, 50; int *p = arr; // 等价于 int *p = arr[0]; // 使用指针遍历数组 for (int i = 0; i 5; i++) printf(%d , *(p + i)); // 等价于 arr[i] // 数组名是指针常量，不能修改 // arr++; // 错误！ p++; // 正确 return 0; 指针遍历数组// 方法1：使用数组下标for (int i = 0; i 5; i++) printf(%d , arr[i]);// 方法2：使用指针算术for (int *p = arr; p arr + 5; p++) printf(%d , *p); 指针与函数指针作为函数参数指针参数可以实现”传引用”的效果： #include // 值传递：不会改变原变量void swapByValue(int a, int b) int temp = a; a = b; b = temp;// 指针传递：会改变原变量void swapByPointer(int *a, int *b) int temp = *a; *a = *b; *b = temp;int main() int x = 10, y = 20; swapByValue(x, y); printf(值传递后：x=%d, y=%d , x, y); // 输出：x=10, y=20 swapByPointer(x, y); printf(指针传递后：x=%d, y=%d , x, y); // 输出：x=20, y=10 return 0; 函数返回指针#include int* max(int *a, int *b) return (*a *b) ? a : b;int main() int x = 10, y = 20; int *p = max(x, y); printf(最大值：%d , *p); // 输出：20 return 0; ⚠️ 注意不要返回指向局部变量的指针，因为函数返回后局部变量会被销毁。 指针数组与数组指针指针数组指针数组是数组的每个元素都是指针： int *arr[5]; // 5个int指针的数组 数组指针数组指针是指向整个数组的指针： int (*p)[5]; // 指向包含5个int的数组的指针 #include int main() int arr[3][4] = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ; int (*p)[4] = arr; // 数组指针 for (int i = 0; i 3; i++) for (int j = 0; j 4; j++) printf(%d , *(*(p + i) + j)); printf( ); return 0; 多级指针指向指针的指针称为二级指针： #include int main() int a = 10; int *p = a // 一级指针 int **pp = p // 二级指针 printf(a的值：%d , a); // 输出：10 printf(*p的值：%d , *p); // 输出：10 printf(**pp的值：%d , **pp); // 输出：10 **pp = 20; printf(修改后a的值：%d , a); // 输出：20 return 0; 💡 应用场景多级指针常用于修改指针变量的值，或在函数中返回指针。 动态内存分配malloc和free#include #include int main() // 动态分配内存 int *p = (int*)malloc(5 * sizeof(int)); if (p == NULL) printf(内存分配失败 ); return 1; // 使用内存 for (int i = 0; i 5; i++) p[i] = i + 1; for (int i = 0; i 5; i++) printf(%d , p[i]); // 释放内存 free(p); p = NULL; // 防止悬空指针 return 0; calloc和realloc#include // calloc：分配并初始化为0int *p1 = (int*)calloc(5, sizeof(int));// realloc：重新分配内存大小int *p2 = (int*)realloc(p, 10 * sizeof(int)); 内存分配函数对比 函数 说明 malloc(size) 分配size字节内存 calloc(n, size) 分配n个size字节，并初始化为0 realloc(ptr, size) 重新分配内存大小 free(ptr) 释放动态分配的内存 ⚠️ 内存管理原则 谁分配，谁释放 释放后置NULL，防止悬空指针 避免内存泄漏 常见指针错误未初始化的指针int *p; // 危险！p指向未知位置*p = 10; // 可能导致程序崩溃 野指针int *p = (int*)malloc(sizeof(int));free(p);*p = 10; // 错误！p指向已释放的内存 指针越界int arr[5];int *p = arr;for (int i = 0; i = 5; i++) *(p + i) = i; // 错误！i=5时越界 💡 安全使用指针 初始化指针为NULL 使用前检查指针是否为NULL 释放后置NULL 使用const保护不应修改的数据 综合示例：链表#include #include struct Node int data; struct Node *next;;// 创建节点struct Node* createNode(int data) struct Node *newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-data = data; newNode-next = NULL; return newNode;// 插入节点void insertNode(struct Node **head, int data) struct Node *newNode = createNode(data); newNode-next = *head; *head = newNode;// 打印链表void printList(struct Node *head) while (head != NULL) printf(%d - , head-data); head = head-next; printf(NULL );int main() struct Node *head = NULL; insertNode(head, 10); insertNode(head, 20); insertNode(head, 30); printList(head); return 0; 本章小结 ✓ 理解了指针的基本概念 ✓ 掌握了指针的运算 ✓ 学会了指针与数组、函数的结合使用 ✓ 了解了动态内存分配 ✓ 认识了指针使用的常见错误 下一步学习 第6章 函数 - 深入学习函数 第7章 结构体与共用体 - 学习自定义数据类型"},{"title":"第6章 函数","path":"/wiki/c/chapter6.html","content":"第6章 函数⭐核心章节 重点掌握 函数是模块化程序设计的基础 本章概述函数是执行特定任务的独立代码块，是C语言模块化程序设计的核心。通过函数，我们可以将复杂问题分解为若干小问题，使程序结构清晰、易于维护。 本章主要内容： 函数的定义和声明 函数的调用 参数传递机制 递归函数 变量的作用域和存储类别 预处理命令 函数的定义和声明函数定义返回类型 函数名(参数列表) // 函数体 return 返回值; // 示例1：无参无返回值void printHello() printf(Hello, World! );// 示例2：有参无返回值void printNumber(int num) printf(数字：%d , num);// 示例3：有参有返回值int add(int a, int b) return a + b;// 示例4：返回指针int* max(int *a, int *b) return (*a *b) ? a : b; 函数声明函数声明告诉编译器函数的名称、返回类型和参数。通常在头文件或文件开头进行声明： // 函数声明int add(int a, int b);void printHello();int main() int result = add(10, 20); printf(结果：%d , result); printHello(); return 0;// 函数定义int add(int a, int b) return a + b;void printHello() printf(Hello, World! ); 💡 为什么需要函数声明？如果函数定义在main函数之后，必须在调用前声明函数，否则编译器会报错。 函数的调用基本调用#include int square(int num);int main() int x = 5; int result = square(x); // 函数调用 printf(%d的平方是%d , x, result); return 0;int square(int num) return num * num; 嵌套调用#include int add(int a, int b) return a + b;int multiply(int a, int b) return a * b;int calculate(int a, int b, int c) // 嵌套调用 return multiply(add(a, b), c);int main() int result = calculate(2, 3, 4); // (2 + 3) * 4 = 20 printf(结果：%d , result); return 0; 递归调用#include // 计算阶乘long factorial(int n) if (n = 1) return 1; return n * factorial(n - 1); // 递归调用// 斐波那契数列int fibonacci(int n) if (n = 1) return n; return fibonacci(n - 1) + fibonacci(n - 2);int main() printf(5的阶乘：%ld , factorial(5)); printf(斐波那契第10项：%d , fibonacci(10)); return 0; 参数传递机制值传递C语言默认使用值传递，将实参的值复制给形参： #include void swap(int a, int b) int temp = a; a = b; b = temp; printf(函数内：a=%d, b=%d , a, b);int main() int x = 10, y = 20; printf(调用前：x=%d, y=%d , x, y); swap(x, y); printf(调用后：x=%d, y=%d , x, y); // x和y的值没有改变 return 0; 地址传递通过传递指针实现地址传递，可以修改原变量的值： #include void swap(int *a, int *b) int temp = *a; *a = *b; *b = temp;int main() int x = 10, y = 20; printf(调用前：x=%d, y=%d , x, y); swap(x, y); printf(调用后：x=%d, y=%d , x, y); // x和y的值已交换 return 0; 数组作为参数#include // 数组作为参数会退化为指针void printArray(int arr[], int size) for (int i = 0; i size; i++) printf(%d , arr[i]); printf( );void modifyArray(int arr[], int size) for (int i = 0; i size; i++) arr[i] *= 2; int main() int arr[] = 1, 2, 3, 4, 5; int size = sizeof(arr) / sizeof(arr[0]); printf(原数组：); printArray(arr, size); modifyArray(arr, size); printf(修改后：); printArray(arr, size); return 0; 变量的作用域和存储类别局部变量void func() int x = 10; // 局部变量，只在函数内有效 printf(%d , x); 全局变量#include int global = 100; // 全局变量，整个文件都可以访问void func1() printf(func1: %d , global);void func2() printf(func2: %d , global);int main() func1(); func2(); printf(main: %d , global); return 0; static变量#include void count() static int count = 0; // 静态局部变量，只初始化一次 count++; printf(调用次数：%d , count);int main() count(); // 输出：调用次数：1 count(); // 输出：调用次数：2 count(); // 输出：调用次数：3 return 0; 作用域对比 变量类型 作用域 生命周期 局部变量 函数内部 函数调用期间 全局变量 整个程序 整个程序运行期间 静态局部变量 函数内部 整个程序运行期间 静态全局变量 当前文件 整个程序运行期间 预处理命令#define 宏定义#define PI 3.14159 // 常量宏#define MAX(a, b) ((a) (b) ? (a) : (b)) // 函数宏int main() printf(PI = %f , PI); int max = MAX(10, 20); printf(最大值 = %d , max); return 0; #include 文件包含#include // 系统头文件#include myheader.h // 自定义头文件 条件编译#define DEBUG 1int main() #ifdef DEBUG printf(调试模式 ); #endif #if DEBUG == 1 printf(调试级别1 ); #elif DEBUG == 2 printf(调试级别2 ); #else printf(发布模式 ); #endif return 0; 💡 预处理命令的使用 #define用于定义常量和宏 #include用于包含头文件 条件编译用于跨平台代码和调试 常用库函数数学函数 math.h#include #include int main() printf(sqrt(16) = %f , sqrt(16)); printf(pow(2, 3) = %f , pow(2, 3)); printf(abs(-5) = %d , abs(-5)); printf(sin(PI/2) = %f , sin(3.14159/2)); return 0; 字符串函数 string.h#include #include int main() char s1[] = Hello; char s2[] = World; printf(长度：%lu , strlen(s1)); strcat(s1, s2); printf(连接：%s , s1); printf(比较：%d , strcmp(abc, abd)); return 0; 内存操作函数#include #include int main() int arr[5] = 1, 2, 3, 4, 5; memset(arr, 0, sizeof(arr)); memcpy(arr, arr + 2, 2 * sizeof(int)); return 0; 综合示例：学生成绩管理系统#include #include #define MAX_STUDENTS 100struct Student char name[50]; int id; float score;;int studentCount = 0;struct Student students[MAX_STUDENTS];// 添加学生void addStudent() if (studentCount = MAX_STUDENTS) printf(学生人数已满！ ); return; printf(姓名：); scanf(%s, students[studentCount].name); printf(学号：); scanf(%d, students[studentCount].id); printf(成绩：); scanf(%f, students[studentCount].score); studentCount++; printf(添加成功！ );// 显示所有学生void displayStudents() if (studentCount == 0) printf(暂无学生信息！ ); return; printf( %-20s %-10s %s , 姓名, 学号, 成绩); printf(-------------------------------- ); for (int i = 0; i studentCount; i++) printf(%-20s %-10d %.2f , students[i].name, students[i].id, students[i].score); // 计算平均分float calculateAverage() if (studentCount == 0) return 0; float sum = 0; for (int i = 0; i studentCount; i++) sum += students[i].score; return sum / studentCount;// 查找最高分学生void findTopStudent() if (studentCount == 0) printf(暂无学生信息！ ); return; int topIndex = 0; for (int i = 1; i studentCount; i++) if (students[i].score students[topIndex].score) topIndex = i; printf( 最高分学生： ); printf(姓名：%s , students[topIndex].name); printf(成绩：%.2f , students[topIndex].score);int main() int choice; while (1) printf( 1. 添加学生 ); printf(2. 显示所有学生 ); printf(3. 计算平均分 ); printf(4. 查找最高分 ); printf(5. 退出 ); printf(请选择：); scanf(%d, choice); switch (choice) case 1: addStudent(); break; case 2: displayStudents(); break; case 3: printf(平均分：%.2f , calculateAverage()); break; case 4: findTopStudent(); break; case 5: return 0; default: printf(无效选择！ ); return 0; 本章小结 ✓ 掌握了函数的定义和声明 ✓ 理解了参数传递机制 ✓ 学会了递归函数的使用 ✓ 了解了变量的作用域和存储类别 ✓ 掌握了预处理命令 下一步学习 第7章 结构体与共用体 - 学习自定义数据类型 第8章 文件操作 - 学习数据持久化"},{"title":"第7章 结构体与共用体","path":"/wiki/c/chapter7.html","content":"第7章 结构体与共用体⭐高级章节 重点掌握 结构体是组织复杂数据的重要工具 本章概述前几章我们学习了基本数据类型（整型、浮点型、字符型等），但这些类型只能表示单一的数据。实际应用中，我们经常需要处理由多个不同类型数据组成的复合数据。 本章主要内容： 结构体的定义和使用 结构体数组 结构体指针 共用体 枚举类型 typedef类型定义 结构体什么是结构体？结构体（struct）是一种用户自定义的数据类型，它可以将不同类型的数据组合在一起，形成一个整体。 💡 结构体的特点 由不同类型的数据成员组成 所有成员共享同一块内存，各自占用不同的空间 可以嵌套定义 大小是所有成员大小之和（可能存在填充） 定义结构体// 方式1：先定义类型，再定义变量struct Student char name[50]; int age; float score;;struct Student stu1, stu2;// 方式2：定义类型的同时定义变量struct Student char name[50]; int age; float score; stu1, stu2;// 方式3：使用typedef简化类型名typedef struct char name[50]; int age; float score; Student;Student stu1, stu2; // 不需要再写struct 初始化结构体struct Student char name[50]; int age; float score;;// 初始化方式1：按顺序初始化struct Student stu1 = 张三, 20, 85.5;// 初始化方式2：指定成员初始化struct Student stu2 = .name = 李四, .age = 21, .score = 90.0;// 初始化方式3：先定义后赋值struct Student stu3;strcpy(stu3.name, 王五);stu3.age = 22;stu3.score = 88.5; 访问结构体成员#include #include struct Student char name[50]; int age; float score;;int main() struct Student stu; // 访问成员 strcpy(stu.name, 张三); stu.age = 20; stu.score = 85.5; // 输出成员 printf(姓名：%s , stu.name); printf(年龄：%d , stu.age); printf(成绩：%.2f , stu.score); return 0; 结构体数组结构体数组的每个元素都是一个结构体： #include struct Student char name[50]; int age; float score;;int main() // 定义结构体数组 struct Student students[3] = 张三, 20, 85.5, 李四, 21, 90.0, 王五, 22, 88.5 ; // 遍历结构体数组 for (int i = 0; i 3; i++) printf(学生%d：%s, %d岁, %.2f分 , i + 1, students[i].name, students[i].age, students[i].score); return 0; 结构体指针指向结构体的指针#include struct Student char name[50]; int age; float score;;int main() struct Student stu = 张三, 20, 85.5; struct Student *p = stu // 方式1：使用解引用和点运算符 printf(姓名：%s , (*p).name); // 方式2：使用箭头运算符（推荐） printf(年龄：%d , p-age); printf(成绩：%.2f , p-score); return 0; 结构体指针作为函数参数#include struct Student char name[50]; int age; float score;;// 使用结构体指针作为参数，避免拷贝整个结构体void printStudent(struct Student *p) printf(姓名：%s , p-name); printf(年龄：%d , p-age); printf(成绩：%.2f , p-score);void updateScore(struct Student *p, float newScore) p-score = newScore;int main() struct Student stu = 张三, 20, 85.5; printStudent(stu); updateScore(stu, 90.0); printf(更新后成绩：%.2f , stu.score); return 0; 结构体嵌套结构体可以包含另一个结构体作为成员： #include struct Date int year; int month; int day;;struct Student char name[50]; struct Date birthday; // 嵌套结构体 float score;;int main() struct Student stu = 张三, 2000, 5, 15, 85.5 ; printf(姓名：%s , stu.name); printf(生日：%d年%d月%d日 , stu.birthday.year, stu.birthday.month, stu.birthday.day); printf(成绩：%.2f , stu.score); return 0; 共用体什么是共用体？共用体（union）是一种特殊的数据类型，它允许在相同的内存位置存储不同的数据类型。所有成员共享同一块内存，同时只能有一个成员有效。 #include union Data int i; float f; char str[20];;int main() union Data data; data.i = 10; printf(data.i: %d , data.i); // 输出：10 data.f = 220.5; printf(data.f: %.2f , data.f); // 输出：220.50 strcpy(data.str, C Programming); printf(data.str: %s , data.str); // 输出：C Programming // 注意：现在data.i和data.f的值已经失效 printf(data.i: %d , data.i); // 输出不确定的值 return 0; 结构体与共用体的区别 特性 结构体 共用体 内存占用 所有成员大小之和 最大成员的大小 成员同时有效 是 否，同时只有一个成员有效 用途 组合不同类型的数据 节省内存或实现多态 💡 共用体的应用共用体常用于节省内存或实现数据的多种解释方式，如在嵌入式系统中。 枚举类型定义枚举枚举（enum）是一组命名的整数常量： // 定义枚举类型enum Weekday SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;// 使用枚举enum Weekday today = WEDNESDAY; 枚举的使用#include enum Weekday SUNDAY = 0, // 可以指定值 MONDAY, // 自动为1 TUESDAY, // 自动为2 WEDNESDAY, // 自动为3 THURSDAY, // 自动为4 FRIDAY, // 自动为5 SATURDAY // 自动为6;int main() enum Weekday today = WEDNESDAY; if (today == WEDNESDAY) printf(今天是星期%d , today); // 输出：今天是星期3 // 枚举可以用在switch中 switch (today) case MONDAY: printf(星期一 ); break; case WEDNESDAY: printf(星期三 ); break; default: printf(其他 ); return 0; typedef类型定义typedef用于为已有类型定义新的名称： #include // 为基本类型定义别名typedef int INTEGER;typedef float REAL;// 为结构体定义别名typedef struct char name[50]; int age; Person;// 为指针定义别名typedef int* IntPtr;int main() INTEGER x = 10; REAL y = 3.14; Person p = 张三, 20; IntPtr ptr = x printf(x = %d , *ptr); return 0; 💡 typedef的优点 提高代码可读性 简化复杂的类型声明 便于跨平台移植 综合示例：学生信息管理系统#include #include #define MAX_STUDENTS 100// 定义日期结构体typedef struct int year; int month; int day; Date;// 定义性别枚举typedef enum MALE, FEMALE Gender;// 定义学生结构体typedef struct int id; // 学号 char name[50]; // 姓名 Gender gender; // 性别 Date birthday; // 生日 float score; // 成绩 Student;int studentCount = 0;Student students[MAX_STUDENTS];// 添加学生void addStudent() if (studentCount = MAX_STUDENTS) printf(学生人数已满！ ); return; Student s; printf(学号：); scanf(%d, s.id); printf(姓名：); scanf(%s, s.name); int g; printf(性别（0-男，1-女）：); scanf(%d, g); s.gender = (Gender)g; printf(生日（年 月 日）：); scanf(%d %d %d, s.birthday.year, s.birthday.month, s.birthday.day); printf(成绩：); scanf(%f, s.score); students[studentCount++] = s; printf(添加成功！ );// 显示所有学生void displayStudents() if (studentCount == 0) printf(暂无学生信息！ ); return; printf( %-10s %-20s %-10s %-15s %s , 学号, 姓名, 性别, 生日, 成绩); printf(-------------------------------------------------------- ); for (int i = 0; i studentCount; i++) printf(%-10d %-20s %-10s %04d-%02d-%02d %.2f , students[i].id, students[i].name, students[i].gender == MALE ? 男 : 女, students[i].birthday.year, students[i].birthday.month, students[i].birthday.day, students[i].score); // 按学号查找学生void searchStudent() int id; printf(请输入学号：); scanf(%d, id); for (int i = 0; i studentCount; i++) if (students[i].id == id) printf( 找到学生： ); printf(学号：%d , students[i].id); printf(姓名：%s , students[i].name); printf(性别：%s , students[i].gender == MALE ? 男 : 女); printf(生日：%04d-%02d-%02d , students[i].birthday.year, students[i].birthday.month, students[i].birthday.day); printf(成绩：%.2f , students[i].score); return; printf(未找到该学生！ );int main() int choice; while (1) printf( ===== 学生信息管理系统 ===== ); printf(1. 添加学生 ); printf(2. 显示所有学生 ); printf(3. 查找学生 ); printf(4. 退出 ); printf(请选择：); scanf(%d, choice); switch (choice) case 1: addStudent(); break; case 2: displayStudents(); break; case 3: searchStudent(); break; case 4: return 0; default: printf(无效选择！ ); return 0; 本章小结 ✓ 掌握了结构体的定义和使用 ✓ 学会了结构体数组和指针 ✓ 理解了共用体与结构体的区别 ✓ 掌握了枚举类型的使用 ✓ 学会了typedef定义类型别名 下一步学习 第8章 文件操作 - 学习数据持久化 第6章 函数 - 复习函数相关知识"},{"title":"第8章 文件操作","path":"/wiki/c/chapter8.html","content":"第8章 文件操作⭐实用章节 重点掌握 文件操作实现数据的持久化存储 本章概述前面学习的程序中，数据都存储在内存中，程序结束后数据就会丢失。文件操作允许我们将数据存储到磁盘上，实现数据的持久化。 本章主要内容： 文件的基本概念 文件的打开与关闭 文本文件的读写 二进制文件的读写 文件的随机读写 文件检测函数 文件的基本概念什么是文件？文件是存储在外部介质（如硬盘、U盘）上的数据的集合。从程序的角度看，文件是数据源或数据目的地。 文件的分类 分类方式 类型 说明 按数据组织 文本文件 以ASCII码存储，可读性好 按数据组织 二进制文件 以二进制存储，效率高 按存取方式 顺序文件 只能顺序读写 按存取方式 随机文件 可以随机读写任意位置 文件指针C语言使用FILE结构体来表示文件，通过文件指针来操作文件： FILE *fp; // 文件指针 文件的打开与关闭打开文件 fopenFILE *fopen(const char *filename, const char *mode); 常用模式： 模式 说明 r 以只读方式打开文本文件 w 以写入方式打开文本文件（会覆盖原有内容） a 以追加方式打开文本文件 rb 以只读方式打开二进制文件 wb 以写入方式打开二进制文件 r+ 以读写方式打开文件 w+ 以读写方式打开文件（会覆盖） 关闭文件 fcloseint fclose(FILE *stream); #include int main() FILE *fp; // 打开文件 fp = fopen(test.txt, r); if (fp == NULL) printf(文件打开失败！ ); return 1; printf(文件打开成功！ ); // 关闭文件 fclose(fp); return 0; ⚠️ 注意事项 打开文件后必须检查是否成功 使用完文件后必须关闭 关闭后文件指针会被释放，不应再使用 文本文件的读写字符读写 fgetcfputc#include int main() FILE *fp; char ch; // 写入文件 fp = fopen(output.txt, w); if (fp == NULL) return 1; fputc(H, fp); fputc(e, fp); fputc(l, fp); fputc(l, fp); fputc(o, fp); fclose(fp); // 读取文件 fp = fopen(output.txt, r); if (fp == NULL) return 1; while ((ch = fgetc(fp)) != EOF) putchar(ch); fclose(fp); return 0; 字符串读写 fgetsfputs#include int main() FILE *fp; char str[100]; // 写入字符串 fp = fopen(output.txt, w); fputs(Hello, World! , fp); fputs(This is a test. , fp); fclose(fp); // 读取字符串 fp = fopen(output.txt, r); while (fgets(str, sizeof(str), fp) != NULL) printf(%s, str); fclose(fp); return 0; 格式化读写 fprintffscanf#include struct Student char name[50]; int age; float score;;int main() FILE *fp; struct Student stu = 张三, 20, 85.5; struct Student s; // 写入文件 fp = fopen(student.txt, w); if (fp == NULL) return 1; fprintf(fp, %s %d %.2f , stu.name, stu.age, stu.score); fclose(fp); // 读取文件 fp = fopen(student.txt, r); if (fp == NULL) return 1; fscanf(fp, %s %d %f, s.name, s.age, s.score); printf(姓名：%s , s.name); printf(年龄：%d , s.age); printf(成绩：%.2f , s.score); fclose(fp); return 0; 二进制文件的读写数据块读写 freadfwritesize_t fread(void *ptr, size_t size, size_t count, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream); #include struct Student char name[50]; int age; float score;;int main() FILE *fp; struct Student students[3] = 张三, 20, 85.5, 李四, 21, 90.0, 王五, 22, 88.5 ; struct Student s[3]; // 写入二进制文件 fp = fopen(students.dat, wb); if (fp == NULL) return 1; fwrite(students, sizeof(struct Student), 3, fp); fclose(fp); // 读取二进制文件 fp = fopen(students.dat, rb); if (fp == NULL) return 1; fread(s, sizeof(struct Student), 3, fp); fclose(fp); // 显示数据 for (int i = 0; i 3; i++) printf(%s %d %.2f , s[i].name, s[i].age, s[i].score); return 0; 💡 二进制文件 vs 文本文件 二进制文件：存储效率高，读写速度快，但不可读 文本文件：可读性好，便于调试，但效率较低 文件的随机读写文件定位函数 函数 说明 rewind(fp) 将文件位置指针移到文件开头 fseek(fp, offset, origin) 将文件位置指针移到指定位置 ftell(fp) 获取当前文件位置 fseek的使用#include int main() FILE *fp; fp = fopen(test.txt, w+); if (fp == NULL) return 1; // 写入数据 fputs(ABCDEFGHIJKLMNOPQRSTUVWXYZ, fp); // 定位到第10个字符 fseek(fp, 10, SEEK_SET); printf(当前位置：%ld , ftell(fp)); // 定位到文件末尾前5个字符 fseek(fp, -5, SEEK_END); printf(当前位置：%ld , ftell(fp)); // 回到文件开头 rewind(fp); printf(当前位置：%ld , ftell(fp)); fclose(fp); return 0; fseek的origin参数： SEEK_SET：文件开头 SEEK_CUR：当前位置 SEEK_END：文件末尾 文件检测函数 函数 说明 feof(fp) 检测是否到达文件末尾 ferror(fp) 检测是否发生错误 clearerr(fp) 清除文件错误标志 #include int main() FILE *fp; char ch; fp = fopen(test.txt, r); if (fp == NULL) return 1; // 检测文件结束 while (!feof(fp)) ch = fgetc(fp); if (!feof(fp)) putchar(ch); // 检测错误 if (ferror(fp)) printf(读取文件时发生错误！ ); clearerr(fp); fclose(fp); return 0; 标准文件流C语言定义了三个标准文件流： 文件流 说明 默认设备 stdin 标准输入 键盘 stdout 标准输出 屏幕 stderr 标准错误 屏幕 #include int main() // 从标准输入读取 fprintf(stdout, 请输入内容：); char str[100]; fscanf(stdin, %s, str); // 输出到标准输出 fprintf(stdout, 你输入了：%s , str); // 输出到标准错误 fprintf(stderr, 这是错误信息 ); return 0; 综合示例：学生成绩管理系统#include #include #include #define FILENAME students.datstruct Student int id; char name[50]; float score;;// 添加学生void addStudent() FILE *fp = fopen(FILENAME, ab); if (fp == NULL) printf(无法打开文件！ ); return; struct Student s; printf(学号：); scanf(%d, s.id); printf(姓名：); scanf(%s, s.name); printf(成绩：); scanf(%f, s.score); fwrite(s, sizeof(struct Student), 1, fp); fclose(fp); printf(添加成功！ );// 显示所有学生void displayStudents() FILE *fp = fopen(FILENAME, rb); if (fp == NULL) printf(暂无学生信息！ ); return; struct Student s; printf( %-10s %-20s %s , 学号, 姓名, 成绩); printf(-------------------------------- ); while (fread(s, sizeof(struct Student), 1, fp) == 1) printf(%-10d %-20s %.2f , s.id, s.name, s.score); fclose(fp);// 查找学生void searchStudent() int id; printf(请输入学号：); scanf(%d, id); FILE *fp = fopen(FILENAME, rb); if (fp == NULL) printf(文件不存在！ ); return; struct Student s; int found = 0; while (fread(s, sizeof(struct Student), 1, fp) == 1) if (s.id == id) printf( 找到学生： ); printf(学号：%d , s.id); printf(姓名：%s , s.name); printf(成绩：%.2f , s.score); found = 1; break; if (!found) printf(未找到该学生！ ); fclose(fp);// 修改学生成绩void updateScore() int id; printf(请输入学号：); scanf(%d, id); FILE *fp = fopen(FILENAME, rb+); if (fp == NULL) printf(文件不存在！ ); return; struct Student s; int found = 0; while (fread(s, sizeof(struct Student), 1, fp) == 1) if (s.id == id) printf(当前成绩：%.2f , s.score); printf(新成绩：); scanf(%f, s.score); // 移动回该记录的起始位置 fseek(fp, -sizeof(struct Student), SEEK_CUR); fwrite(s, sizeof(struct Student), 1, fp); printf(修改成功！ ); found = 1; break; if (!found) printf(未找到该学生！ ); fclose(fp);int main() int choice; while (1) printf( ===== 学生成绩管理系统 ===== ); printf(1. 添加学生 ); printf(2. 显示所有学生 ); printf(3. 查找学生 ); printf(4. 修改成绩 ); printf(5. 退出 ); printf(请选择：); scanf(%d, choice); switch (choice) case 1: addStudent(); break; case 2: displayStudents(); break; case 3: searchStudent(); break; case 4: updateScore(); break; case 5: return 0; default: printf(无效选择！ ); return 0; 本章小结 ✓ 理解了文件的基本概念 ✓ 掌握了文件的打开和关闭 ✓ 学会了文本文件和二进制文件的读写 ✓ 掌握了文件的随机读写 ✓ 了解了文件检测函数 学习完成恭喜！你已经完成了C语言程序设计的全部学习内容。 建议继续学习： 数据结构与算法 操作系统原理 计算机网络 数据库系统 💡 持续学习建议 多编写实际项目巩固知识 阅读优秀开源代码 学习调试技巧 关注编程规范和最佳实践"},{"title":"C语言期末考试易错知识点总结","path":"/wiki/c/exam-tips.html","content":"C语言期末考试易错知识点总结⭐重点复习 考试必看 结合考试题型整理的易错知识点 内容导航 一、选择题判断题易错点 二、程序填空题易错点 三、编程题易错点 四、高频考点清单 五、复习建议 一、选择题判断题易错点1. 指针与数组的混淆易错点1：数组名作为参数void func(int arr[]) // 错误！这里sizeof(arr)返回指针大小(4/8字节) // 而不是数组总长度 int size = sizeof(arr); // 错误！ **正确做法：**传递数组长度作为额外参数 void func(int arr[], int n) // n是数组元素个数 for (int i = 0; i n; i++) // ... 易错点2：指针运算int* p;p++; // 跳过 sizeof(int) 字节（通常是4字节） // 而不是1字节！ **关键理解：**指针的算术运算基于其指向的数据类型 int arr[5] = 1, 2, 3, 4, 5;int* p = arr;p + 1; // 指向arr[1]，地址增加 sizeof(int) = 4字节*(p + 2); // 等价于 arr[2] 2. 结构体内存对齐易错点：sizeof(结构体) ≠ 成员大小之和struct Student char name; // 1字节 int age; // 4字节 float score; // 4字节;// sizeof(struct Student) 可能是 12 字节// 而不是 1 + 4 + 4 = 9 字节！ **原因：**编译器会对结构体成员进行内存对齐（通常4字节对齐） // 实际内存布局（假设4字节对齐）：// [name][空][空][空][age][age][age][age][score][score][score][score]// 1B + 3B填充 + 4B + 4B = 12B 位域的使用struct Flags unsigned int a : 2; // a只占2位 unsigned int b : 3; // b只占3位 unsigned int c : 1; // c只占1位; // 总共可能只占1个int（4字节） **注意：**位域可能因平台不同导致跨字节问题 3. 宏定义的副作用易错点：宏参数未加括号// 错误的宏定义#define MAX(a, b) a b ? a : b// 调用时int result = MAX(x + y, z);// 展开为：x + y z ? x + y : z// 由于运算符优先级，可能得到错误结果！ **正确写法：**参数和整体都加括号 #define MAX(a, b) ((a) (b) ? (a) : (b)) 易错点：宏替换导致多次求值#define SQUARE(x) ((x) * (x))int a = 5;int result = SQUARE(a++); // 危险！// 展开为：((a++) * (a++))// a被自增了两次！ 💡 建议 宏参数都要加括号 避免在宏参数中使用有副作用的表达式（如++、–） 考虑使用inline函数替代复杂宏 4. 全局变量与静态变量 变量类型 初始化默认值 生命周期 作用域 全局变量 0 整个程序运行期 整个文件（可用extern扩展） 局部变量 随机值 函数执行期 函数内部 static局部变量 0 整个程序运行期 函数内部 static全局变量 0 整个程序运行期 当前文件 void func() int a; // 随机值！ static int b; // 自动初始化为0 printf(%d %d , a, b); // a的值不确定 二、程序填空题易错点1. 循环条件与边界处理易错点1：循环条件写反// 遍历数组for (int i = 0; i = n; i++) // 错误！越界for (int i = 0; i n; i++) // 正确for (int i = 1; i = n; i++) // 从1开始，到n结束for (int i = 0; i n; i++) // 从0开始，到n-1结束 易错点2：二维数组行列顺序混淆int matrix[3][4];// 遍历：先行后列for (int i = 0; i 3; i++) // 行 for (int j = 0; j 4; j++) // 列 printf(%d , matrix[i][j]); // 错误示例：行列颠倒for (int i = 0; i 4; i++) // 错误！i应该到3 for (int j = 0; j 3; j++) // 错误！j应该到4 // ... 2. 指针与数组下标易错点：指针算术类型不匹配int arr[5];int* p = arr;// 正确的指针访问*(p + i) // 等价于 arr[i]*(arr + i) // 等价于 arr[i]// 错误示例int x = *(arr + i); // 正确int y = arr + i; // 错误！arr+i是指针，不能直接赋给int 易错点：字符串输入处理char str[10];// 方法1：scanf（遇到空格停止）scanf(%s, str);// 方法2：scanf读取整行（包括空格）scanf(%[^ ], str);// 方法3：fgets（推荐）fgets(str, sizeof(str), stdin); 3. 函数参数传递易错点：值传递vs地址传递// 值传递：修改形参不影响实参void swap1(int a, int b) int temp = a; a = b; b = temp; // ❌ 无法交换实际参数// 地址传递：通过指针修改实参void swap2(int* a, int* b) int temp = *a; *a = *b; *b = temp; // ✅ 可以交换int x = 10, y = 20;swap1(x, y); // x,y不变swap2(x, y); // x,y被交换 4. 动态内存分配易错点：忘记释放内存// 正确做法int* p = (int*)malloc(n * sizeof(int));if (p == NULL) // 处理内存分配失败// 使用内存...// 释放内存free(p);p = NULL; // 避免野指针 ⚠️ 记忆口诀 谁malloc，谁free free后置NULL 配对使用，防止泄漏 三、编程题易错点1. 数组越界与字符串处理易错点：缓冲区溢出char src[] = Hello, World!;char dest[5]; // 只有5字节空间// 危险！src有13字节，dest只有5字节strcpy(dest, src); // ❌ 缓冲区溢出！// 正确做法：先检查长度if (strlen(src) sizeof(dest)) strcpy(dest, src); // ✅ 安全 else printf(目标空间不足 ); 安全函数替代方案// 使用strncpy替代strcpystrncpy(dest, src, sizeof(dest) - 1);dest[sizeof(dest) - 1] = \\0; // 确保以\\0结尾// 使用strncat替代strcatstrncat(dest, src, sizeof(dest) - strlen(dest) - 1);// 使用snprintf替代sprintfsnprintf(dest, sizeof(dest), %s, src); 2. 递归函数易错点：缺少递归终止条件// 错误示例：缺少终止条件int factorial(int n) return n * factorial(n - 1); // ❌ 无限递归！// 正确示例int factorial(int n) if (n = 1) // ✅ 递归终止条件 return 1; return n * factorial(n - 1); 递归过深导致栈溢出// 递归深度过大时，改用迭代int factorial_iterative(int n) int result = 1; for (int i = 2; i = n; i++) result *= i; return result; 3. 文件读写易错点1：忘记检查文件是否成功打开FILE* fp = fopen(data.txt, r);// ❌ 直接使用，可能导致崩溃fscanf(fp, %d, n);// ✅ 正确做法：检查返回值if (fp == NULL) printf(无法打开文件 ); return 1;// 使用完记得关闭fclose(fp); 易错点2：处理文件结束符EOF// 错误示例while (!feof(fp)) // ❌ 可能多读一次 fscanf(fp, %d, n); printf(%d , n);// 正确示例while (fscanf(fp, %d, n) == 1) // ✅ 检查返回值 printf(%d , n); 易错点3：二进制文件读写参数顺序int arr[10];// fread参数：指针, 元素大小, 元素个数, 文件指针fread(arr, sizeof(int), 10, fp); // ✅ 正确// 错误示例fread(arr, 10, sizeof(int), fp); // ❌ 参数顺序错误 四、高频考点清单 知识点 易错点 考试频率 指针与数组 数组名作为参数传递时的类型差异、指针算术运算 ⭐⭐⭐⭐⭐ 结构体与共用体 内存对齐、位域、共用体成员覆盖 ⭐⭐⭐⭐⭐ 宏定义与预处理 宏参数未加括号、宏替换的副作用 ⭐⭐⭐⭐ 动态内存 malloccalloc的区别、free后置空指针 ⭐⭐⭐⭐⭐ 文件操作 模式字符串误用、文件指针位置（fseekftell） ⭐⭐⭐⭐ 字符串处理 缓冲区溢出、strcatstrcpy的安全使用 ⭐⭐⭐⭐⭐ 递归函数 递归终止条件、栈溢出 ⭐⭐⭐ 函数参数传递 值传递vs地址传递、数组退化为指针 ⭐⭐⭐⭐⭐ 五、复习建议1. 针对性练习多做历年真题中的易错题型，特别是： 指针相关题目 结构体和共用体 文件操作 动态内存分配 2. 代码调试用printf或调试工具检查： 指针的值是否正确 数组下标是否越界 内存分配是否成功 文件是否正确打开 3. 记忆口诀 指针数组：”指针数组，数组指针，弄清顺序” 宏定义：”宏定义，参数括号，避免陷阱” 文件操作：”文件操作，模式选对，EOF处理” 动态内存：”谁malloc谁free，free后置NULL” 4. 重点章节优先按重要性排序： 指针（最重要，最难） 函数 数组 结构体 文件操作 📚 祝你考试顺利！加油！💪 相关资源 经典案例与解析 - 通过实例加深理解 第5章 指针 - 指针专题学习 第6章 函数 - 函数专题学习 面试常见题 - 巩固基础知识"},{"title":"C语言面试常见题","path":"/wiki/c/interview-questions.html","content":"C语言面试常见题⭐面试必备 基础题+算法题+编程题全覆盖 题目分类 一、基础概念题 二、指针与内存 三、数组与字符串 四、函数与递归 五、位运算 六、算法实现 一、基础概念题Q1: strlen() 和 sizeof() 的区别？答案：char str[] = Hello;sizeof(str) // 返回 6（包含\\0）strlen(str) // 返回 5（不包含\\0）char* p = Hello;sizeof(p) // 返回指针大小（4或8字节）strlen(p) // 返回 5 关键区别： sizeof是运算符，编译时确定，计算变量类型占用的字节数 strlen是函数，运行时计算，统计字符串长度（不包含’\\0’） Q2: ++i 和 i++ 的区别？答案：int i = 5;// 前置++：先加1，再使用int a = ++i; // a=6, i=6// 后置++：先使用，再加1int b = i++; // b=6, i=7 **效率：**前置++效率更高，因为不需要保存临时值 Q3: static 关键字的作用？答案：1. 修饰局部变量： void func() static int count = 0; // 只初始化一次 count++; printf(%d , count);int main() func(); // 输出: 1 func(); // 输出: 2 func(); // 输出: 3 2. 修饰全局变量： static int g_var = 10; // 只在本文件内可见 3. 修饰函数： static void helper() // 只在本文件内可见 // ... Q4: const 关键字的作用？答案：// 1. 常量const int MAX = 100;// 2. 指向常量的指针（内容不能改）const int* p;*p = 10; // ❌ 错误p++; // ✅ 可以// 3. 常量指针（指向不能改）int* const p = a*p = 10; // ✅ 可以p++; // ❌ 错误// 4. 指向常量的常量指针const int* const p = a*p = 10; // ❌ 错误p++; // ❌ 错误 二、指针与内存Q5: 指针和引用的区别？答案：C语言没有引用，这是C++概念。但在面试中常问： 特性 指针 引用(C++) 本质 变量 别名 是否占用内存 是 否 能否为空 可以(NULL) 不可以 初始化 可以不初始化 必须初始化 改变指向 可以 不可以 Q6: 野指针是什么？如何避免？答案：**野指针：**指向不确定内存地址的指针 // 野指针的几种情况：// 1. 未初始化int* p; // 野指针！指向随机地址*p = 10; // 危险！// 2. 释放后未置空int* p = (int*)malloc(sizeof(int));free(p);*p = 10; // 野指针！p指向已释放的内存// 3. 指针超越变量作用域int* func() int a = 10; return a // 返回局部变量地址！ 避免方法： // 1. 初始化为NULLint* p = NULL;// 2. free后置NULLfree(p);p = NULL;// 3. 使用前检查if (p != NULL) *p = 10; Q7: malloc 和 calloc 的区别？答案： 特性 malloc calloc 参数 malloc(字节数) calloc(元素个数, 每个元素大小) 初始化 不初始化，内容随机 初始化为0 效率 稍快 稍慢 // mallocint* p1 = (int*)malloc(5 * sizeof(int));// 内容不确定// callocint* p2 = (int*)calloc(5, sizeof(int));// 内容全为0 三、数组与字符串Q8: 数组名和指针的区别？答案：int arr[5] = 1, 2, 3, 4, 5;int* p = arr;// 相同点arr[i] 等价于 p[i]*(arr+i) 等价于 *(p+i)// 不同点sizeof(arr) // 20 (整个数组大小)sizeof(p) // 4或8 (指针大小)arr++ // ❌ 错误！数组名是常量p++ // ✅ 正确 **关键：**数组名在某些情况下会退化为指针，但它们不是同一类型 Q9: 如何实现字符串反转？答案：#include void reverse(char* str) if (str == NULL) return; int len = strlen(str); for (int i = 0; i len / 2; i++) // 交换首尾字符 char temp = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = temp; int main() char str[] = Hello; reverse(str); printf(%s , str); // 输出: olleH Q10: 如何判断一个字符串是否是回文？答案：#include #include bool isPalindrome(char* str) if (str == NULL) return false; int len = strlen(str); int left = 0; int right = len - 1; while (left right) if (str[left] != str[right]) return false; left++; right--; return true;int main() printf(%d , isPalindrome(aba)); // 1 (true) printf(%d , isPalindrome(abc)); // 0 (false) 四、函数与递归Q11: 值传递和地址传递的区别？答案：// 值传递void swap1(int a, int b) int temp = a; a = b; b = temp; // 不影响实参// 地址传递void swap2(int* a, int* b) int temp = *a; *a = *b; *b = temp; // 修改实参int x = 10, y = 20;swap1(x, y); // x,y不变swap2(x, y); // x,y被交换 Q12: 递归的三个要素是什么？答案： 递归终止条件：必须有一个明确的结束条件 递归表达式：问题规模缩小的规律 向终止条件收敛：每次递归都要接近终止条件 // 示例：阶乘int factorial(int n) // 1. 终止条件 if (n = 1) return 1; // 2. 递归表达式 + 3. 收敛 return n * factorial(n - 1); 五、位运算Q13: 如何判断一个数是否是2的幂？答案：bool isPowerOfTwo(int n) // 2的幂：二进制只有一个1 // 1: 0001 // 2: 0010 // 4: 0100 // 8: 1000 // n (n-1) 可以去掉最低位的1 return (n 0) ((n (n - 1)) == 0);int main() printf(%d , isPowerOfTwo(1)); // 1 printf(%d , isPowerOfTwo(2)); // 1 printf(%d , isPowerOfTwo(3)); // 0 printf(%d , isPowerOfTwo(4)); // 1 printf(%d , isPowerOfTwo(5)); // 0 **原理：**2的幂的二进制表示只有一个1，n(n-1)会将这个1变为0 Q14: 如何交换两个变量的值（不使用第三个变量）？方法1：加减法int a = 10, b = 20;a = a + b; // a=30, b=20b = a - b; // a=30, b=10a = a - b; // a=20, b=10 **缺点：**可能溢出 方法2：异或法（推荐）int a = 10, b = 20;a = a ^ b;b = a ^ b; // b = (a^b)^b = aa = a ^ b; // a = (a^b)^a = b **优点：**不会溢出，效率高 六、算法实现Q15: 实现二分查找答案：int binarySearch(int arr[], int n, int target) int left = 0; int right = n - 1; while (left = right) // 防止溢出 int mid = left + (right - left) / 2; if (arr[mid] == target) return mid; else if (arr[mid] target) left = mid + 1; else right = mid - 1; return -1; // 未找到 **时间复杂度：**O(log n) Q16: 实现斐波那契数列方法1：递归（低效）int fib(int n) if (n = 1) return n; return fib(n - 1) + fib(n - 2); **时间复杂度：**O(2ⁿ) - 有大量重复计算 方法2：迭代（推荐）int fib(int n) if (n = 1) return n; int a = 0, b = 1, c; for (int i = 2; i = n; i++) c = a + b; a = b; b = c; return b; **时间复杂度：**O(n) Q17: 判断一个数是否是素数答案：#include #include bool isPrime(int n) if (n = 1) return false; if (n == 2) return true; if (n % 2 == 0) return false; // 只需检查到√n for (int i = 3; i = sqrt(n); i += 2) if (n % i == 0) return false; return true; **优化：**只检查到√n，跳过偶数 面试技巧💡 回答问题的技巧 先说结论，再解释原因 用代码示例佐证观点 分析不同方案的优缺点 考虑边界情况和错误处理 💡 编程题技巧 先明确需求，再动手编码 先写框架，再填细节 注意变量命名和代码风格 主动测试边界情况 💡 常见追问 “这个算法的时间复杂度是多少？” “有没有更优的解决方案？” “如果数据量很大怎么办？” “如何处理并发线程安全问题？” 相关资源 期末考试易错点 - 巩固基础知识 经典案例与解析 - 实战项目经验 第5章 指针 - 指针专题 第4章 数组 - 数组与字符串"},{"title":"main函数详解","path":"/wiki/c/main-function.html","content":"main函数详解⭐高优先级 核心概念 main函数是C语言程序的入口，所有程序都从这里开始执行 什么是main函数？main函数（主函数）是C语言程序执行的起点和终点。每个C语言程序都必须包含一个main函数，它是程序的主控函数。 核心特点： main是程序的入口点，程序从这里开始执行 main是相对而言的，如同音乐理论之主调与泛音 main可以调用其他函数，形成模块化的程序结构 main函数执行完毕，程序也就结束 💡 生活中的类比可以把main函数想象成公司的CEO，它负责协调和调用其他部门（函数）来完成各种任务。没有CEO，公司就无法正常运转。 main函数的作用1. 程序的入口点当你运行一个C程序时，操作系统会首先调用main函数。无论你的程序有多少个函数，main函数都是第一个被执行的。 2. 组织程序结构main函数将程序的各个部分组织在一起，形成一个完整的程序。比如一个”做菜”程序，main函数就是”做菜”这个过程，它会调用”买菜”、”切菜”、”炒菜”等子函数。 3. 参数传递和返回main函数可以接收命令行参数，并返回一个状态码给操作系统，表示程序的执行结果。 main函数的形式无参形式最简单的main函数形式，不带任何参数： int main(void) // 程序代码 return 0; 💡 返回值说明 return 0; 表示程序正常结束 return 非0值; 表示程序异常结束 返回值类型必须是int 带参形式main函数可以接收命令行参数： int main(int argc, char **argv) // argc: 参数个数 (argument count) // argv: 参数值数组 (argument vector) return 0; 参数说明： argc (argument count)：命令行参数的个数 argv (argument vector)：命令行参数的数组，每个元素是一个字符串指针 argv[0]：程序本身的名称 argv[1]到argv[argc-1]：用户提供的参数 实际示例#include int main(int argc, char **argv) printf(程序名称: %s , argv[0]); printf(参数个数: %d , argc); for (int i = 1; i argc; i++) printf(参数 %d: %s , i, argv[i]); return 0; 编译运行： $ gcc -o program program.c$ ./program hello world程序名称: ./program参数个数: 3参数 1: hello参数 2: world main函数的特殊性1. 必须性在绝大多数情况下，C程序必须有main函数。但有少数例外： Windows动态链接库（DLL）：DLL模块不是独立的程序，不需要main函数 嵌入式系统：某些特殊环境下的程序可能不需要main函数 驱动程序：操作系统驱动程序使用特殊的入口点 2. 唯一性一个程序只能有一个main函数。如果定义了多个main函数，链接器会报错。 3. 不能被调用main函数通常不能被其他函数调用（虽然技术上可以，但不推荐）。main函数是程序的起点，而不是可重用的函数。 函数调用关系main作为主调函数main函数可以调用其他函数，传递数据： #include // 函数声明int calculate_sum(int a, int b);void print_result(int result);int main(void) int x = 10, y = 20; // main调用其他函数 int sum = calculate_sum(x, y); print_result(sum); return 0;// 函数定义int calculate_sum(int a, int b) return a + b;void print_result(int result) printf(结果是: %d , result); 💡 调用层次main函数处于调用树的顶层，其他函数可以是主调函数，也可以是被调函数。这种层次结构使程序清晰易懂。 函数分类从用户使用角度 标准函数（库函数）：由系统提供，如printf()、scanf() 用户自定义函数：程序员自己编写的函数 从函数形式角度 无参函数：调用时不需要传递数据 有参函数：调用时需要传递数据 main函数的最佳实践1. 保持简洁main函数应该保持简洁，主要做以下几件事： 初始化程序 调用其他函数完成具体任务 清理资源 返回状态码 // 好的main函数示例int main(void) if (!initialize()) return 1; // 初始化失败 if (!process_data()) cleanup(); return 2; // 处理失败 cleanup(); return 0; // 成功 2. 返回适当的退出码 退出码 含义 0 成功 1 一般性错误 2 误用shell命令 126 命令无法执行 127 命令未找到 3. 错误处理#include #include int main(int argc, char **argv) // 检查参数 if (argc 2) fprintf(stderr, 用法: %s 文件名 , argv[0]); return 1; // 打开文件 FILE *file = fopen(argv[1], r); if (file == NULL) perror(无法打开文件); return 2; // 处理文件 // ... // 清理 fclose(file); return 0; 常见问题Q1: main函数可以有返回类型void吗？**答：**在某些编译器中可以（如Dev-C++），但这不符合C标准。标准C要求main函数返回int类型。 Q2: 可以递归调用main函数吗？答：技术上可以，但绝对不推荐。这会导致程序逻辑混乱，难以维护。 Q3: main函数可以声明为static吗？**答：**不可以。main函数必须对操作系统可见，因此不能是static。 Q4: 如果不写return 0会怎样？**答：**C99标准规定，如果main函数没有return语句，会自动返回0。但为了代码清晰，建议显式写上return 0。 总结main函数是C语言程序的核心，掌握它的要点： ✓ main是程序的入口点和出口点 ✓ main可以带参数（argc, argv）接收命令行参数 ✓ main应该返回int类型的退出码 ✓ main函数应该保持简洁，调用其他函数完成具体任务 ✓ 一个程序只能有一个main函数 下一步学习掌握了main函数后，建议继续学习： 第2章 C语言基础 - 学习数据类型和表达式 第6章 函数 - 深入学习函数的各个方面 C语言32个关键字 - 复习核心关键字"},{"title":"常见排序算法详解","path":"/wiki/c/sorting-algorithms.html","content":"常见排序算法详解⭐核心算法 排序是编程面试必考内容，必须熟练掌握 算法概览 算法 平均时间 最坏时间 空间 稳定性 冒泡排序 O(n²) O(n²) O(1) ✅ 稳定 选择排序 O(n²) O(n²) O(1) ❌ 不稳定 插入排序 O(n²) O(n²) O(1) ✅ 稳定 快速排序 O(n log n) O(n²) O(log n) ❌ 不稳定 一、冒泡排序 (Bubble Sort)📋 算法说明通过相邻元素比较和交换，将最大（或最小）元素”冒泡”到数组末尾。 **核心思想：**相邻比较，大数下沉 难度：⭐ (入门) 基本实现void bubbleSort(int arr[], int n) // 外层循环：控制排序轮数 for (int i = 0; i n - 1; i++) // 内层循环：相邻比较 for (int j = 0; j n - 1 - i; j++) if (arr[j] arr[j + 1]) // 交换 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; 优化版本void bubbleSortOptimized(int arr[], int n) for (int i = 0; i n - 1; i++) int swapped = 0; // 标记本轮是否发生交换 for (int j = 0; j n - 1 - i; j++) if (arr[j] arr[j + 1]) // 交换 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; swapped = 1; // 如果本轮没有交换，说明已经有序 if (!swapped) break; 🔍 算法解析1. 为什么是 j n - 1 - i？// 第一轮：最大元素冒泡到 arr[n-1]// 第二轮：次大元素冒泡到 arr[n-2]// 第i轮：第i大元素冒泡到 arr[n-i]// 所以内层循环只需要到 n-1-i 2. 执行过程示例对 [5, 2, 8, 1, 9] 进行升序排序： 轮次 数组状态 说明 初始 [5, 2, 8, 1, 9] - 第1轮 [2, 5, 1, 8, 9] 9冒泡到末尾 第2轮 [2, 1, 5, 8, 9] 8冒泡到位置3 第3轮 [1, 2, 5, 8, 9] 5冒泡到位置2 第4轮 [1, 2, 5, 8, 9] 2冒泡到位置1 3. 时间复杂度分析 **最好情况：**O(n) - 数组已经有序（优化版） **最坏情况：**O(n²) - 数组逆序 **平均情况：**O(n²) 易错点⚠️ 常见错误 内层循环写成 j n - 1（应该是 j n - 1 - i） 交换时忘记使用临时变量 数组越界：j + 1可能超出范围 二、选择排序 (Selection Sort)📋 算法说明每次从未排序部分选择最小元素，放到已排序部分的末尾。 **核心思想：**每次选最小，放到前面 难度：⭐ (入门) 基本实现void selectionSort(int arr[], int n) for (int i = 0; i n - 1; i++) // 假设当前元素是最小的 int minIndex = i; // 在未排序部分找最小元素 for (int j = i + 1; j n; j++) if (arr[j] arr[minIndex]) minIndex = j; // 将最小元素放到正确位置 if (minIndex != i) int temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; 🔍 算法解析1. 执行过程示例对 [5, 2, 8, 1, 9] 进行排序： 轮次 最小值 数组状态 第1轮 1 (位置3) [1, 5, 8, 2, 9] 第2轮 2 (位置3) [1, 2, 8, 5, 9] 第3轮 5 (位置3) [1, 2, 5, 8, 9] 第4轮 8 (位置3) [1, 2, 5, 8, 9] 2. 关键点 minIndex初始化为i，不是0 内层循环从i + 1开始 找到最小元素后才交换，减少交换次数 3. 为什么不稳定？// 示例：[5, 5, 2]// 第一轮：选2，与第一个5交换// 变成：[2, 5, 5]// 两个5的相对位置改变了！ 易错点⚠️ 常见错误 minIndex初始化为0（应该是i） 内层循环从i开始（应该从i+1开始） 忘记检查minIndex != i导致不必要的交换 三、插入排序 (Insertion Sort)📋 算法说明将未排序元素插入到已排序部分的正确位置。 **核心思想：**像整理扑克牌一样 难度：⭐⭐ (较简单) 基本实现void insertionSort(int arr[], int n) for (int i = 1; i n; i++) int key = arr[i]; // 待插入元素 int j = i - 1; // 将大于key的元素向后移 while (j = 0 arr[j] key) arr[j + 1] = arr[j]; j--; // 插入key到正确位置 arr[j + 1] = key; 🔍 算法解析1. 执行过程示例对 [5, 2, 8, 1, 9] 进行排序： 轮次 待插入 过程 结果 初始 - - [5] 第1轮 2 25，5后移 [2, 5] 第2轮 8 85，直接插入 [2, 5, 8] 第3轮 1 12,5,8，全部后移 [1, 2, 5, 8] 第4轮 9 98，直接插入 [1, 2, 5, 8, 9] 2. 关键点 key必须单独保存，否则在移动元素时丢失 j从i-1开始，向前扫描 循环条件j = 0 arr[j] key防止越界 3. 为什么稳定？// 只在 arr[j] key 时才移动// 相等的元素不移动，保持相对位置// 所以是稳定的 4. 时间复杂度特点 **最好情况：**O(n) - 数组已经有序 **最坏情况：**O(n²) - 数组逆序 **平均情况：**O(n²) 易错点⚠️ 常见错误 忘记保存key，导致数据丢失 j从i开始（应该从i-1开始） while循环条件缺少j = 0导致越界 插入位置写成arr[j]（应该是arr[j+1]） 四、快速排序 (Quick Sort)📋 算法说明选择基准元素，将数组分为两部分，左边小于基准，右边大于基准，递归排序。 **核心思想：**分而治之 难度：⭐⭐⭐⭐ (较难) 基本实现// 分区函数int partition(int arr[], int low, int high) int pivot = arr[high]; // 选择最后一个元素作为基准 int i = low - 1; // i是小于基准元素的边界 for (int j = low; j high; j++) if (arr[j] pivot) i++; // 交换arr[i]和arr[j] int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; // 将基准放到正确位置 int temp = arr[i + 1]; arr[i + 1] = arr[high]; arr[high] = temp; return i + 1;// 快速排序主函数void quickSort(int arr[], int low, int high) if (low high) // 分区 int pi = partition(arr, low, high); // 递归排序左半部分 quickSort(arr, low, pi - 1); // 递归排序右半部分 quickSort(arr, pi + 1, high); 🔍 算法解析1. 执行过程示例对 [5, 2, 8, 1, 9] 排序，选择9为基准： 初始: [5, 2, 8, 1, 9] 基准=9分区后: [5, 2, 8, 1] 9 左边都小于9递归左半部分: [5, 2, 8, 1]选择基准=1分区后: 1 [5, 2, 8] 1是基准继续分区...直到完全有序 2. 关键点 i从low-1开始，便于第一次i++ 基准选择影响效率，一般选最后一个元素 递归终止条件：low high 3. 时间复杂度 **最好情况：**O(n log n) - 每次基准恰好将数组平分 **最坏情况：**O(n²) - 每次基准是最小或最大元素 **平均情况：**O(n log n) 4. 空间复杂度O(log n) - 递归调用栈的深度 优化建议💡 快速排序优化 随机选择基准 - 避免最坏情况 三数取中法 - 选择首、中、尾的中位数作为基准 小数组改用插入排序 - 当n10时用插入排序 三路划分 - 处理大量重复元素的情况 五、排序算法对比与应用算法选择建议 场景 推荐算法 原因 小规模数据 (n50) 插入排序 常数因子小，实现简单 基本有序 插入排序 时间复杂度接近O(n) 大规模数据 快速排序 平均性能最优 要求稳定 归并排序 稳定且O(n log n) 内存受限 堆排序 空间复杂度O(1) 实际应用示例#include #include #include // 生成随机数组void generateRandomArray(int arr[], int n) srand(time(NULL)); for (int i = 0; i n; i++) arr[i] = rand() % 100; // 打印数组void printArray(int arr[], int n) for (int i = 0; i n; i++) printf(%d , arr[i]); printf( );// 测试各种排序算法int main() int arr1[10], arr2[10], arr3[10]; generateRandomArray(arr1, 10); // 复制数组 for (int i = 0; i 10; i++) arr2[i] = arr3[i] = arr1[i]; printf(原数组：); printArray(arr1, 10); // 测试冒泡排序 bubbleSort(arr1, 10); printf(冒泡排序：); printArray(arr1, 10); // 测试选择排序 selectionSort(arr2, 10); printf(选择排序：); printArray(arr2, 10); // 测试插入排序 insertionSort(arr3, 10); printf(插入排序：); printArray(arr3, 10); return 0; 练习题📝 基础练习 实现降序排序的冒泡排序 实现双向冒泡排序（鸡尾酒排序） 实现二分插入排序 📝 进阶练习 实现归并排序 实现堆排序 优化快速排序（三数取中） 📝 挑战练习 实现多路归并排序 实现带有计数功能的排序算法 对二维数组按某列排序 总结记忆口诀 冒泡排序：相邻比较，大数下沉 选择排序：每次选小，放到前面 插入排序：像理扑克，插入到位 快速排序：选定基准，分而治之 时间复杂度记忆 冒泡、选择、插入都是O(n²) 快速、归并、堆都是O(n log n) 插入排序对基本有序的数据效率高"},{"title":"1.1 计算机基础","path":"/wiki/python/chapter1-1.html","content":"1.1 计算机基础⭐掌握计算机基础知识是学习编程的第一步 计算机特点计算机作为一种通用的信息处理工具，具有极高的处理速度、很强的存储能力、精确的计算和逻辑判断能力。 1. 运算速度快当今计算机的运算速度已经达到每秒几十亿亿次，微机也可以达到每秒亿次以上。 2020年，Fugaku的峰值浮点性能高达537PFLOPS（一秒钟可以进行10^15次运算）。 2. 计算精确度高一般计算机可以有十几位甚至几十位（二进制）有效数字，计算精度可由千分之几到百万分之几。 3. 具有记忆和逻辑判断能力随着计算机的发展，计算机不仅能进行计算，还能把各种数据储存起来，来供人们随时调用。还可以通过编码技术对各种计算信息进行算术运算和逻辑运算，还可以进行推理和证明。 4. 自动控制能力计算机可以按照内部设定好的程序自动控制进行。 计算机常用的数制及编码数制也叫计数制，用一组固定的符号和统一的规则来表示数值的方法。 编码是通过采用少量的基本符号，选用一定的组合原则，以表示大量复杂多样的信息的技术。 1. 二进制二进制是一种数制，它使用两个符号（0和1）来表示所有的数值。在计算机科学中，二进制系统是非常重要的，因为它是大多数现代计算机处理数据的基础。 有两个不同的数字符号，0和1 逢二进一（二进制的基数为2） 2. 其他数制基本概念： 数位：数码在一个数所处的位置 基数：在某种进位数制中，每个数码上所能使用的数码的个数 必须逢N进1 （1）十进制数有十个不同的数码0、1、2、3、4、5、6、7、8、9，基数为10，特点是逢10进一。 （2）八进制八个不同的数码0、1、2、3、4、5、6、7，基数为8，逢八进一。 （3）十六进制有十六个不同的数码符号0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F（可小写）。 二进制数的不同进制对照表 二进制 十进制 八进制 十六进制 0000 0 0 0 0010 2 2 2 0110 6 6 6 1000 8 10 8 1010 10 12 A 1100 12 14 C ASCII 码ASCII码（American Standard Code for Information Interchange，美国信息交换标准代码）是一种基于拉丁字母的字符编码，主要用于显示现代英语和其他西欧语言。 原始的ASCII表使用7位二进制数来表示128个可能的不同字符。后来扩展到8位以支持更多的字符，总共可以表示256个不同的值。 常用ASCII码表 十进制 十六进制 字符 描述 0 0x00 NUL 空字符 10 0x0A LF 换行 13 0x0D CR 回车 32 0x20 (空格) 空格 48-57 0x30-0x39 0-9 数字0-9 65-90 0x41-0x5A A-Z 大写英文字母 97-122 0x61-0x7A a-z 小写英文字母 Unicode 编码和 UTF-8 编码Unicode 编码Unicode是一个国际标准，它为世界上几乎所有的字符集定义了一个统一的、唯一的数字编号。每个字符都被赋予了一个唯一的代码点（code point），这个代码点是用十六进制表示的。 例如，拉丁字母”A”的Unicode代码点是U+0041。 UTF-8 编码UTF-8 (Unicode Transformation Format - 8 bit) 是Unicode的一种实现方式，它是一种变长编码，可以使用1到4个字节来表示一个Unicode字符。 对于ASCII范围内的字符（U+0000至U+007F），UTF-8使用单个字节 对于其他基本多语言平面（BMP）内的字符（U+0080至U+FFFF），UTF-8使用两个或三个字节 对于超出BMP的字符，则需要四个字节 💡 UTF-8 的优势由于UTF-8的高效性和向后兼容性，它已成为互联网上最常用的字符编码之一。大多数现代操作系统和编程环境默认都支持UTF-8。 进制转换和二进制运算十进制转二进制整数部分除以2，直到余数为0，然后将余数倒序排列。 原码、反码和补码 正数的原码、反码和补码都一样 负数的反码是用它的原码转化得到的（符号位不变，其他0变1，1变0） 计算机内部用补码进行运算 # Python中的进制表示# 二进制binary_num = 0b1010 # 10的十进制# 八进制octal_num = 0o12 # 10的十进制# 十六进制hex_num = 0xA # 10的十进制print(binary_num) # 输出: 10print(octal_num) # 输出: 10print(hex_num) # 输出: 10 下一步学习掌握了计算机基础知识后，建议继续学习： Python语言简介 - 了解Python的运算符和基本语法 数字类型 - 学习Python中的数字类型"},{"title":"Python语言简介","path":"/wiki/python/chapter1-2.html","content":"Python语言简介⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"数字类型","path":"/wiki/python/chapter2-1.html","content":"数字类型⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"赋值语句","path":"/wiki/python/chapter2-5.html","content":"赋值语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"条件语句","path":"/wiki/python/chapter3-1.html","content":"条件语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"字符串","path":"/wiki/python/chapter2-2.html","content":"字符串⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"循环语句","path":"/wiki/python/chapter3-2.html","content":"循环语句⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"列表","path":"/wiki/python/chapter4-1.html","content":"列表⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"元组","path":"/wiki/python/chapter4-2.html","content":"元组⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"字典","path":"/wiki/python/chapter4-3.html","content":"字典⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"集合","path":"/wiki/python/chapter4-4.html","content":"集合⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"函数定义","path":"/wiki/python/chapter5-1.html","content":"函数定义⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"参数传递","path":"/wiki/python/chapter5-2.html","content":"参数传递⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"模块与包","path":"/wiki/python/chapter5-3.html","content":"模块与包⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"类与对象","path":"/wiki/python/chapter6-1.html","content":"类与对象⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"继承与多态","path":"/wiki/python/chapter6-2.html","content":"继承与多态⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"文件操作","path":"/wiki/python/chapter7-1.html","content":"文件操作⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"异常处理","path":"/wiki/python/chapter7-2.html","content":"异常处理⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"装饰器","path":"/wiki/python/chapter7-3.html","content":"装饰器⭐本章内容正在完善中 课程内容本章内容正在更新中，敬请期待… 请先学习其他章节，或者访问语雀文档查看完整内容。 相关章节 计算机基础 Python语言简介 数字类型"},{"title":"基础配置入门","path":"/wiki/theme/basic-config.html","content":"基础配置入门⭐掌握基础配置是主题装修的核心技能 配置文件概述Stellar 主题的配置分为多个层级，了解它们的关系对于定制非常重要。 配置层级 配置文件 优先级 用途 _config.stellar.yml 最高 站点级覆盖配置（推荐修改） themes/stellar/_config.yml 中等 主题默认配置 _config.yml 基础 Hexo 站点基础配置 **重要提示：**永远不要在 themes/stellar/_config.yml 中直接修改，而是创建 _config.stellar.yml 文件进行覆盖配置。这样主题更新时不会丢失你的定制。 创建覆盖配置文件步骤 1：创建文件在博客站点根目录（与 _config.yml 同级）创建 _config.stellar.yml 文件： # 在博客根目录执行touch _config.stellar.yml 步骤 2：基本结构在 _config.stellar.yml 中，你只需要写需要覆盖的配置项，不需要复制全部内容。 # _config.stellar.yml 示例# 站点基本信息site: name: 我的博客 icon: /img/favicon.ico# 导航菜单menubar: columns: 4 items: - id: home theme: #1BCDFC icon: title: 首页 url: / - id: wiki theme: #3DC550 icon: ... title: 文档 url: /wiki/ 常用配置项详解站点配置（site） 配置项 类型 说明 site.name string 站点名称 site.icon string 站点图标路径 site.desc string 站点描述 site.url string 站点 URL 颜色配置（color）color: # 主色调 - 用于链接、按钮、激活状态 theme: #7bcfa6 # 强调色 - 用于高亮、徽章 accent: #e0f0e9 # 文字颜色 text: #333333 # 次要文字 text-secondary: #666666 # 背景色 background: #ffffff # 代码块背景 code: #f5f5f5 # 边框颜色 border: #e8e8e8 导航栏配置（menubar）menubar: # 列数（1-6） columns: 4 items: - id: home theme: #1BCDFC icon: title: 首页 url: / - id: wiki theme: #3DC550 icon: ... title: 文档 url: /wiki/ 配置验证技巧1. 使用 YAML 检查工具YAML 对缩进非常敏感，建议使用以下方式检查： VS Code 插件：YAML（redhat.vscode-yaml） 在线工具：YAML Lint 2. 启用 Hexo 调试模式# 启动服务器时显示调试信息hexo server --debug# 生成时显示详细日志hexo generate --debug 3. 常见配置错误 错误类型 表现 解决方法 缩进错误 YAML 解析失败 统一使用空格缩进（不要用 Tab） 中文冒号 配置项不生效 使用英文冒号（:）并留空格 路径错误 资源加载失败 检查路径是否以 开头 小结与练习本章重点 理解配置层级：站点级 主题级 默认配置 掌握覆盖配置的方法：使用 _config.stellar.yml 了解常用配置项：站点信息、颜色、导航栏 学会验证配置：使用调试模式和 YAML 检查工具 动手练习 创建 _config.stellar.yml 文件 修改站点名称为你的名字 将主题色改为你喜欢的颜色 在导航栏添加一个新的菜单项 下一步掌握了基础配置后，让我们深入了解各项功能的详细配置： 站点信息配置 - 完善博客的基本信息"},{"title":"了解文件结构","path":"/wiki/theme/file-structure.html","content":"了解文件结构⭐理解文件结构是主题装修的第一步 Stellar 主题文件结构概览在开始定制之前，我们需要了解 Stellar 主题的文件组织结构。这有助于你快速定位需要修改的文件。 主题目录结构themes/stellar/├── _config.yml # 主题主配置文件├── _config.stellar.yml # 站点覆盖配置（推荐在这里修改）├── layout/ # 页面模板│ ├── _partial/ # 局部模板（头部、尾部、侧边栏等）│ ├── _widget/ # 小组件模板│ ├── archive.ejs # 归档页│ ├── index.ejs # 首页│ ├── page.ejs # 独立页面│ ├── post.ejs # 文章页│ └── wiki.ejs # Wiki 页├── source/ # 静态资源│ ├── css/ # 主题样式│ ├── js/ # 主题脚本│ └── fonts/ # 字体文件└── scripts/ # Hexo 脚本 └── ... 关键配置文件说明1. 主题配置文件Stellar 主题有两个主要配置文件： themes/stellar/_config.yml - 主题默认配置（不建议直接修改） _config.stellar.yml - 站点根目录下的覆盖配置（推荐） **最佳实践：**在站点根目录创建 _config.stellar.yml 文件来覆盖主题默认配置。这样主题更新时不会丢失你的定制。 2. 数据文件目录Stellar 主题使用 source/_data/ 目录存放各种数据配置： source/_data/├── authors.yml # 作者信息├── wiki.yml # Wiki 项目列表├── wiki/ # Wiki 项目配置│ ├── c.yaml│ └── python.yaml└── widgets.yml # 小组件库 目录与文件的作用布局模板（layout） 文件 用途 index.ejs 首页模板 post.ejs 博客文章页 wiki.ejs Wiki 文档页 page.ejs 独立页面 archive.ejs 归档页面 静态资源（source） 目录 用途 css/ 样式文件（.css、.styl、.scss） js/ JavaScript 脚本 fonts/ 字体文件 img/ 图片资源 装修前的重要提醒备份！备份！备份！在开始任何修改之前，务必备份以下文件： _config.yml - 站点主配置 _config.stellar.yml - 主题覆盖配置 source/_data/ 目录下的所有数据文件 source/ 目录下的自定义资源 修改原则 不修改主题源文件：避免直接修改 themes/stellar/ 下的文件 使用覆盖配置：通过 _config.stellar.yml 覆盖默认配置 使用自定义目录：将自定义资源放在 source/custom/ 或 source/css/ 渐进式修改：每次只修改一处，验证效果后再继续 推荐的开发流程： 本地运行 hexo server 开启开发服务器 修改配置文件或添加自定义样式 浏览器实时预览效果（大部分修改会自动刷新） 满意后提交修改到 Git 仓库 下一步现在你已经了解了 Stellar 主题的文件结构，接下来让我们开始学习基础配置： 基础配置入门 - 了解核心配置文件和常用设置"},{"title":"主题装修指南","path":"/wiki/theme/index.html","content":"主题装修指南⭐打造独一无二的个人博客，从主题装修开始 什么是主题装修？主题装修是指对 Hexo 博客的 Stellar 主题进行个性化定制和美化的过程。通过调整配置、修改样式、添加功能，你可以将默认的主题打造成符合个人风格的独特博客。 本专栏将带你从入门到精通，全面掌握 Stellar 主题的定制技巧，包括： 基础配置：站点信息、导航菜单、侧边栏设置 视觉美化：配色方案、字体定制、背景设置 功能扩展：评论系统、搜索功能、插件集成 进阶技巧：动画效果、自定义组件、性能优化 Stellar 主题简介Stellar 是一个专为博客设计的 Hexo 主题，具有以下特点： 设计理念 极简主义：真正的极简不是简单删减，而是在复杂中创造秩序 降低视觉密度：更多留白、更少颜色，让内容更突出 信息优先级：文章标题最大、对比度最高 消除无效信息：去除字数统计、浏览量等干扰元素 核心功能 多内容类型：文章、Wiki、笔记、说说等多种内容形态 强大的组件系统：丰富的标签插件和小组件 完善的导航：树形目录、面包屑、相关文章推荐 响应式设计：完美适配桌面和移动设备 学习路径本专栏按照由浅入深的原则组织内容，建议你按以下顺序学习： 第一阶段：入门准备 了解文件结构 - 认识 Stellar 主题的组织方式 第二阶段：基础配置 基础配置入门 - 掌握核心配置文件 站点信息配置 - 设置博客基本信息 第三阶段：界面定制 导航定制 - 自定义菜单和导航 侧边栏配置 - 设置左右侧边栏 页脚定制 - 自定义页脚内容 第四阶段：视觉美化 配色与字体 - 自定义颜色和字体 自定义 CSS - 编写自定义样式 背景设置 - 设置各种背景效果 第五阶段：功能扩展 评论系统 - 集成评论功能 搜索功能 - 配置站内搜索 插件集成 - 添加实用插件 第六阶段：进阶技巧 动画效果 - 添加交互动画 自定义组件 - 开发专属组件 性能优化 - 提升加载速度 第七阶段：实战案例 装修实例 - 完整案例分析 常见问题 - FAQ 与疑难解答 准备工作在开始主题装修之前，请确保你已经具备以下条件： 环境要求 已安装 Node.js (14.17.3+) 已安装 Hexo CLI 已克隆或下载 Stellar 主题 本地可以正常运行 hexo server 工具准备 代码编辑器 (VS Code 推荐) 浏览器开发者工具 YAML 语法检查工具 知识储备 基本的 HTMLCSS 知识 YAML 配置语法 Git 基本操作 开始你的装修之旅现在，你已经了解了本专栏的整体结构和学习路径。让我们从基础开始，一步步打造属于你的独特博客主题。 **提示：**主题装修是一个循序渐进的过程，不必急于求成。建议你在学习每个章节后，立即动手实践，这样才能真正掌握每个知识点。 准备好开始了吗？点击下面的链接，进入第一章：了解文件结构。"}]